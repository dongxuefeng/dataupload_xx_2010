/* soapC.cpp
   Generated by gSOAP 2.8.17r from OpenInterface.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.17r 2015-04-29 10:06:49 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTo_ns1__CheckUserInfoResponse:
		return soap_in_PointerTo_ns1__CheckUserInfoResponse(soap, NULL, NULL, "ns1:CheckUserInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__CheckUserInfo:
		return soap_in_PointerTo_ns1__CheckUserInfo(soap, NULL, NULL, "ns1:CheckUserInfo");
	case SOAP_TYPE_PointerTo_ns1__addTransRecInfoResponse:
		return soap_in_PointerTo_ns1__addTransRecInfoResponse(soap, NULL, NULL, "ns1:addTransRecInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__addTransRecInfo:
		return soap_in_PointerTo_ns1__addTransRecInfo(soap, NULL, NULL, "ns1:addTransRecInfo");
	case SOAP_TYPE_PointerTo_ns1__GetJdsbhRecoveryInfoResponse:
		return soap_in_PointerTo_ns1__GetJdsbhRecoveryInfoResponse(soap, NULL, NULL, "ns1:GetJdsbhRecoveryInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetJdsbhRecoveryInfo:
		return soap_in_PointerTo_ns1__GetJdsbhRecoveryInfo(soap, NULL, NULL, "ns1:GetJdsbhRecoveryInfo");
	case SOAP_TYPE_PointerTo_ns1__GetJdsbhRecoveryResponse:
		return soap_in_PointerTo_ns1__GetJdsbhRecoveryResponse(soap, NULL, NULL, "ns1:GetJdsbhRecoveryResponse");
	case SOAP_TYPE_PointerTo_ns1__GetJdsbhRecovery:
		return soap_in_PointerTo_ns1__GetJdsbhRecovery(soap, NULL, NULL, "ns1:GetJdsbhRecovery");
	case SOAP_TYPE_PointerTo_ns1__GetViolationInfoResponse:
		return soap_in_PointerTo_ns1__GetViolationInfoResponse(soap, NULL, NULL, "ns1:GetViolationInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetViolationInfo:
		return soap_in_PointerTo_ns1__GetViolationInfo(soap, NULL, NULL, "ns1:GetViolationInfo");
	case SOAP_TYPE_PointerTo_ns1__InViolationInfoResponse:
		return soap_in_PointerTo_ns1__InViolationInfoResponse(soap, NULL, NULL, "ns1:InViolationInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__InViolationInfo:
		return soap_in_PointerTo_ns1__InViolationInfo(soap, NULL, NULL, "ns1:InViolationInfo");
	case SOAP_TYPE_PointerTo_ns1__UpdataDeviceStateResponse:
		return soap_in_PointerTo_ns1__UpdataDeviceStateResponse(soap, NULL, NULL, "ns1:UpdataDeviceStateResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdataDeviceState:
		return soap_in_PointerTo_ns1__UpdataDeviceState(soap, NULL, NULL, "ns1:UpdataDeviceState");
	case SOAP_TYPE_PointerTo_ns1__GetAlarmInfoResponse:
		return soap_in_PointerTo_ns1__GetAlarmInfoResponse(soap, NULL, NULL, "ns1:GetAlarmInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetAlarmInfo:
		return soap_in_PointerTo_ns1__GetAlarmInfo(soap, NULL, NULL, "ns1:GetAlarmInfo");
	case SOAP_TYPE_PointerTo_ns1__UpdateVioPeccancyInfoResponse:
		return soap_in_PointerTo_ns1__UpdateVioPeccancyInfoResponse(soap, NULL, NULL, "ns1:UpdateVioPeccancyInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdateVioPeccancyInfo:
		return soap_in_PointerTo_ns1__UpdateVioPeccancyInfo(soap, NULL, NULL, "ns1:UpdateVioPeccancyInfo");
	case SOAP_TYPE_PointerTo_ns1__GetVioPeccancyNoCheckInfoResponse:
		return soap_in_PointerTo_ns1__GetVioPeccancyNoCheckInfoResponse(soap, NULL, NULL, "ns1:GetVioPeccancyNoCheckInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetVioPeccancyNoCheckInfo:
		return soap_in_PointerTo_ns1__GetVioPeccancyNoCheckInfo(soap, NULL, NULL, "ns1:GetVioPeccancyNoCheckInfo");
	case SOAP_TYPE_PointerTo_ns1__UpdatePeccancyInfoResponse:
		return soap_in_PointerTo_ns1__UpdatePeccancyInfoResponse(soap, NULL, NULL, "ns1:UpdatePeccancyInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdatePeccancyInfo:
		return soap_in_PointerTo_ns1__UpdatePeccancyInfo(soap, NULL, NULL, "ns1:UpdatePeccancyInfo");
	case SOAP_TYPE_PointerTo_ns1__GetPeccancyNoCheckInfoResponse:
		return soap_in_PointerTo_ns1__GetPeccancyNoCheckInfoResponse(soap, NULL, NULL, "ns1:GetPeccancyNoCheckInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPeccancyNoCheckInfo:
		return soap_in_PointerTo_ns1__GetPeccancyNoCheckInfo(soap, NULL, NULL, "ns1:GetPeccancyNoCheckInfo");
	case SOAP_TYPE_PointerTo_ns1__GetPeccancyInfoResponse:
		return soap_in_PointerTo_ns1__GetPeccancyInfoResponse(soap, NULL, NULL, "ns1:GetPeccancyInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPeccancyInfo:
		return soap_in_PointerTo_ns1__GetPeccancyInfo(soap, NULL, NULL, "ns1:GetPeccancyInfo");
	case SOAP_TYPE_PointerTo_ns1__GetPassCarInfoResponse:
		return soap_in_PointerTo_ns1__GetPassCarInfoResponse(soap, NULL, NULL, "ns1:GetPassCarInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPassCarInfo:
		return soap_in_PointerTo_ns1__GetPassCarInfo(soap, NULL, NULL, "ns1:GetPassCarInfo");
	case SOAP_TYPE_PointerTo_ns1__GetLocationInfoResponse:
		return soap_in_PointerTo_ns1__GetLocationInfoResponse(soap, NULL, NULL, "ns1:GetLocationInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetLocationInfo:
		return soap_in_PointerTo_ns1__GetLocationInfo(soap, NULL, NULL, "ns1:GetLocationInfo");
	case SOAP_TYPE_PointerTo_ns1__RevokeSuspicionInfoResponse:
		return soap_in_PointerTo_ns1__RevokeSuspicionInfoResponse(soap, NULL, NULL, "ns1:RevokeSuspicionInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__RevokeSuspicionInfo:
		return soap_in_PointerTo_ns1__RevokeSuspicionInfo(soap, NULL, NULL, "ns1:RevokeSuspicionInfo");
	case SOAP_TYPE_PointerTo_ns1__InSuspicionInfoResponse:
		return soap_in_PointerTo_ns1__InSuspicionInfoResponse(soap, NULL, NULL, "ns1:InSuspicionInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__InSuspicionInfo:
		return soap_in_PointerTo_ns1__InSuspicionInfo(soap, NULL, NULL, "ns1:InSuspicionInfo");
	case SOAP_TYPE_PointerTo_ns1__IntExtralistInfoResponse:
		return soap_in_PointerTo_ns1__IntExtralistInfoResponse(soap, NULL, NULL, "ns1:IntExtralistInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__IntExtralistInfo:
		return soap_in_PointerTo_ns1__IntExtralistInfo(soap, NULL, NULL, "ns1:IntExtralistInfo");
	case SOAP_TYPE_PointerTo_ns1__InChecklessInfoResponse:
		return soap_in_PointerTo_ns1__InChecklessInfoResponse(soap, NULL, NULL, "ns1:InChecklessInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__InChecklessInfo:
		return soap_in_PointerTo_ns1__InChecklessInfo(soap, NULL, NULL, "ns1:InChecklessInfo");
	case SOAP_TYPE_PointerTo_ns1__InBlacklistInfoResponse:
		return soap_in_PointerTo_ns1__InBlacklistInfoResponse(soap, NULL, NULL, "ns1:InBlacklistInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__InBlacklistInfo:
		return soap_in_PointerTo_ns1__InBlacklistInfo(soap, NULL, NULL, "ns1:InBlacklistInfo");
	case SOAP_TYPE_PointerTo_ns1__InCheckedPeccancyInfoResponse:
		return soap_in_PointerTo_ns1__InCheckedPeccancyInfoResponse(soap, NULL, NULL, "ns1:InCheckedPeccancyInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__InCheckedPeccancyInfo:
		return soap_in_PointerTo_ns1__InCheckedPeccancyInfo(soap, NULL, NULL, "ns1:InCheckedPeccancyInfo");
	case SOAP_TYPE_PointerTo_ns1__InPeccancyInfoResponse:
		return soap_in_PointerTo_ns1__InPeccancyInfoResponse(soap, NULL, NULL, "ns1:InPeccancyInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__InPeccancyInfo:
		return soap_in_PointerTo_ns1__InPeccancyInfo(soap, NULL, NULL, "ns1:InPeccancyInfo");
	case SOAP_TYPE_PointerTo_ns1__InPassCarInfoResponse:
		return soap_in_PointerTo_ns1__InPassCarInfoResponse(soap, NULL, NULL, "ns1:InPassCarInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__InPassCarInfo:
		return soap_in_PointerTo_ns1__InPassCarInfo(soap, NULL, NULL, "ns1:InPassCarInfo");
	case SOAP_TYPE_PointerTo_ns1__CarPlateRecogResponse:
		return soap_in_PointerTo_ns1__CarPlateRecogResponse(soap, NULL, NULL, "ns1:CarPlateRecogResponse");
	case SOAP_TYPE_PointerTo_ns1__CarPlateRecog:
		return soap_in_PointerTo_ns1__CarPlateRecog(soap, NULL, NULL, "ns1:CarPlateRecog");
	case SOAP_TYPE_PointerTo_ns1__GetXMlFormatResponse:
		return soap_in_PointerTo_ns1__GetXMlFormatResponse(soap, NULL, NULL, "ns1:GetXMlFormatResponse");
	case SOAP_TYPE_PointerTo_ns1__GetXMlFormat:
		return soap_in_PointerTo_ns1__GetXMlFormat(soap, NULL, NULL, "ns1:GetXMlFormat");
	case SOAP_TYPE_PointerTo_ns1__GetCurrentVersionResponse:
		return soap_in_PointerTo_ns1__GetCurrentVersionResponse(soap, NULL, NULL, "ns1:GetCurrentVersionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetCurrentVersion:
		return soap_in_PointerTo_ns1__GetCurrentVersion(soap, NULL, NULL, "ns1:GetCurrentVersion");
	case SOAP_TYPE_PointerTo_ns1__WebserviceTestResponse:
		return soap_in_PointerTo_ns1__WebserviceTestResponse(soap, NULL, NULL, "ns1:WebserviceTestResponse");
	case SOAP_TYPE_PointerTo_ns1__WebserviceTest:
		return soap_in_PointerTo_ns1__WebserviceTest(soap, NULL, NULL, "ns1:WebserviceTest");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:CheckUserInfoResponse"))
		{	*type = SOAP_TYPE__ns1__CheckUserInfoResponse;
			return soap_in__ns1__CheckUserInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CheckUserInfo"))
		{	*type = SOAP_TYPE__ns1__CheckUserInfo;
			return soap_in__ns1__CheckUserInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addTransRecInfoResponse"))
		{	*type = SOAP_TYPE__ns1__addTransRecInfoResponse;
			return soap_in__ns1__addTransRecInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addTransRecInfo"))
		{	*type = SOAP_TYPE__ns1__addTransRecInfo;
			return soap_in__ns1__addTransRecInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetJdsbhRecoveryInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetJdsbhRecoveryInfoResponse;
			return soap_in__ns1__GetJdsbhRecoveryInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetJdsbhRecoveryInfo"))
		{	*type = SOAP_TYPE__ns1__GetJdsbhRecoveryInfo;
			return soap_in__ns1__GetJdsbhRecoveryInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetJdsbhRecoveryResponse"))
		{	*type = SOAP_TYPE__ns1__GetJdsbhRecoveryResponse;
			return soap_in__ns1__GetJdsbhRecoveryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetJdsbhRecovery"))
		{	*type = SOAP_TYPE__ns1__GetJdsbhRecovery;
			return soap_in__ns1__GetJdsbhRecovery(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetViolationInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetViolationInfoResponse;
			return soap_in__ns1__GetViolationInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetViolationInfo"))
		{	*type = SOAP_TYPE__ns1__GetViolationInfo;
			return soap_in__ns1__GetViolationInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InViolationInfoResponse"))
		{	*type = SOAP_TYPE__ns1__InViolationInfoResponse;
			return soap_in__ns1__InViolationInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InViolationInfo"))
		{	*type = SOAP_TYPE__ns1__InViolationInfo;
			return soap_in__ns1__InViolationInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdataDeviceStateResponse"))
		{	*type = SOAP_TYPE__ns1__UpdataDeviceStateResponse;
			return soap_in__ns1__UpdataDeviceStateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdataDeviceState"))
		{	*type = SOAP_TYPE__ns1__UpdataDeviceState;
			return soap_in__ns1__UpdataDeviceState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAlarmInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetAlarmInfoResponse;
			return soap_in__ns1__GetAlarmInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAlarmInfo"))
		{	*type = SOAP_TYPE__ns1__GetAlarmInfo;
			return soap_in__ns1__GetAlarmInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateVioPeccancyInfoResponse"))
		{	*type = SOAP_TYPE__ns1__UpdateVioPeccancyInfoResponse;
			return soap_in__ns1__UpdateVioPeccancyInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdateVioPeccancyInfo"))
		{	*type = SOAP_TYPE__ns1__UpdateVioPeccancyInfo;
			return soap_in__ns1__UpdateVioPeccancyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetVioPeccancyNoCheckInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfoResponse;
			return soap_in__ns1__GetVioPeccancyNoCheckInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetVioPeccancyNoCheckInfo"))
		{	*type = SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfo;
			return soap_in__ns1__GetVioPeccancyNoCheckInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdatePeccancyInfoResponse"))
		{	*type = SOAP_TYPE__ns1__UpdatePeccancyInfoResponse;
			return soap_in__ns1__UpdatePeccancyInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UpdatePeccancyInfo"))
		{	*type = SOAP_TYPE__ns1__UpdatePeccancyInfo;
			return soap_in__ns1__UpdatePeccancyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPeccancyNoCheckInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetPeccancyNoCheckInfoResponse;
			return soap_in__ns1__GetPeccancyNoCheckInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPeccancyNoCheckInfo"))
		{	*type = SOAP_TYPE__ns1__GetPeccancyNoCheckInfo;
			return soap_in__ns1__GetPeccancyNoCheckInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPeccancyInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetPeccancyInfoResponse;
			return soap_in__ns1__GetPeccancyInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPeccancyInfo"))
		{	*type = SOAP_TYPE__ns1__GetPeccancyInfo;
			return soap_in__ns1__GetPeccancyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPassCarInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetPassCarInfoResponse;
			return soap_in__ns1__GetPassCarInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetPassCarInfo"))
		{	*type = SOAP_TYPE__ns1__GetPassCarInfo;
			return soap_in__ns1__GetPassCarInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLocationInfoResponse"))
		{	*type = SOAP_TYPE__ns1__GetLocationInfoResponse;
			return soap_in__ns1__GetLocationInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetLocationInfo"))
		{	*type = SOAP_TYPE__ns1__GetLocationInfo;
			return soap_in__ns1__GetLocationInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RevokeSuspicionInfoResponse"))
		{	*type = SOAP_TYPE__ns1__RevokeSuspicionInfoResponse;
			return soap_in__ns1__RevokeSuspicionInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RevokeSuspicionInfo"))
		{	*type = SOAP_TYPE__ns1__RevokeSuspicionInfo;
			return soap_in__ns1__RevokeSuspicionInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InSuspicionInfoResponse"))
		{	*type = SOAP_TYPE__ns1__InSuspicionInfoResponse;
			return soap_in__ns1__InSuspicionInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InSuspicionInfo"))
		{	*type = SOAP_TYPE__ns1__InSuspicionInfo;
			return soap_in__ns1__InSuspicionInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:IntExtralistInfoResponse"))
		{	*type = SOAP_TYPE__ns1__IntExtralistInfoResponse;
			return soap_in__ns1__IntExtralistInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:IntExtralistInfo"))
		{	*type = SOAP_TYPE__ns1__IntExtralistInfo;
			return soap_in__ns1__IntExtralistInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InChecklessInfoResponse"))
		{	*type = SOAP_TYPE__ns1__InChecklessInfoResponse;
			return soap_in__ns1__InChecklessInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InChecklessInfo"))
		{	*type = SOAP_TYPE__ns1__InChecklessInfo;
			return soap_in__ns1__InChecklessInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InBlacklistInfoResponse"))
		{	*type = SOAP_TYPE__ns1__InBlacklistInfoResponse;
			return soap_in__ns1__InBlacklistInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InBlacklistInfo"))
		{	*type = SOAP_TYPE__ns1__InBlacklistInfo;
			return soap_in__ns1__InBlacklistInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InCheckedPeccancyInfoResponse"))
		{	*type = SOAP_TYPE__ns1__InCheckedPeccancyInfoResponse;
			return soap_in__ns1__InCheckedPeccancyInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InCheckedPeccancyInfo"))
		{	*type = SOAP_TYPE__ns1__InCheckedPeccancyInfo;
			return soap_in__ns1__InCheckedPeccancyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InPeccancyInfoResponse"))
		{	*type = SOAP_TYPE__ns1__InPeccancyInfoResponse;
			return soap_in__ns1__InPeccancyInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InPeccancyInfo"))
		{	*type = SOAP_TYPE__ns1__InPeccancyInfo;
			return soap_in__ns1__InPeccancyInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InPassCarInfoResponse"))
		{	*type = SOAP_TYPE__ns1__InPassCarInfoResponse;
			return soap_in__ns1__InPassCarInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InPassCarInfo"))
		{	*type = SOAP_TYPE__ns1__InPassCarInfo;
			return soap_in__ns1__InPassCarInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CarPlateRecogResponse"))
		{	*type = SOAP_TYPE__ns1__CarPlateRecogResponse;
			return soap_in__ns1__CarPlateRecogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CarPlateRecog"))
		{	*type = SOAP_TYPE__ns1__CarPlateRecog;
			return soap_in__ns1__CarPlateRecog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetXMlFormatResponse"))
		{	*type = SOAP_TYPE__ns1__GetXMlFormatResponse;
			return soap_in__ns1__GetXMlFormatResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetXMlFormat"))
		{	*type = SOAP_TYPE__ns1__GetXMlFormat;
			return soap_in__ns1__GetXMlFormat(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetCurrentVersionResponse"))
		{	*type = SOAP_TYPE__ns1__GetCurrentVersionResponse;
			return soap_in__ns1__GetCurrentVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetCurrentVersion"))
		{	*type = SOAP_TYPE__ns1__GetCurrentVersion;
			return soap_in__ns1__GetCurrentVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WebserviceTestResponse"))
		{	*type = SOAP_TYPE__ns1__WebserviceTestResponse;
			return soap_in__ns1__WebserviceTestResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:WebserviceTest"))
		{	*type = SOAP_TYPE__ns1__WebserviceTest;
			return soap_in__ns1__WebserviceTest(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE__ns1__CheckUserInfoResponse:
		return ((_ns1__CheckUserInfoResponse *)ptr)->soap_out(soap, "ns1:CheckUserInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__CheckUserInfo:
		return ((_ns1__CheckUserInfo *)ptr)->soap_out(soap, "ns1:CheckUserInfo", id, NULL);
	case SOAP_TYPE__ns1__addTransRecInfoResponse:
		return ((_ns1__addTransRecInfoResponse *)ptr)->soap_out(soap, "ns1:addTransRecInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__addTransRecInfo:
		return ((_ns1__addTransRecInfo *)ptr)->soap_out(soap, "ns1:addTransRecInfo", id, NULL);
	case SOAP_TYPE__ns1__GetJdsbhRecoveryInfoResponse:
		return ((_ns1__GetJdsbhRecoveryInfoResponse *)ptr)->soap_out(soap, "ns1:GetJdsbhRecoveryInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__GetJdsbhRecoveryInfo:
		return ((_ns1__GetJdsbhRecoveryInfo *)ptr)->soap_out(soap, "ns1:GetJdsbhRecoveryInfo", id, NULL);
	case SOAP_TYPE__ns1__GetJdsbhRecoveryResponse:
		return ((_ns1__GetJdsbhRecoveryResponse *)ptr)->soap_out(soap, "ns1:GetJdsbhRecoveryResponse", id, NULL);
	case SOAP_TYPE__ns1__GetJdsbhRecovery:
		return ((_ns1__GetJdsbhRecovery *)ptr)->soap_out(soap, "ns1:GetJdsbhRecovery", id, NULL);
	case SOAP_TYPE__ns1__GetViolationInfoResponse:
		return ((_ns1__GetViolationInfoResponse *)ptr)->soap_out(soap, "ns1:GetViolationInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__GetViolationInfo:
		return ((_ns1__GetViolationInfo *)ptr)->soap_out(soap, "ns1:GetViolationInfo", id, NULL);
	case SOAP_TYPE__ns1__InViolationInfoResponse:
		return ((_ns1__InViolationInfoResponse *)ptr)->soap_out(soap, "ns1:InViolationInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__InViolationInfo:
		return ((_ns1__InViolationInfo *)ptr)->soap_out(soap, "ns1:InViolationInfo", id, NULL);
	case SOAP_TYPE__ns1__UpdataDeviceStateResponse:
		return ((_ns1__UpdataDeviceStateResponse *)ptr)->soap_out(soap, "ns1:UpdataDeviceStateResponse", id, NULL);
	case SOAP_TYPE__ns1__UpdataDeviceState:
		return ((_ns1__UpdataDeviceState *)ptr)->soap_out(soap, "ns1:UpdataDeviceState", id, NULL);
	case SOAP_TYPE__ns1__GetAlarmInfoResponse:
		return ((_ns1__GetAlarmInfoResponse *)ptr)->soap_out(soap, "ns1:GetAlarmInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__GetAlarmInfo:
		return ((_ns1__GetAlarmInfo *)ptr)->soap_out(soap, "ns1:GetAlarmInfo", id, NULL);
	case SOAP_TYPE__ns1__UpdateVioPeccancyInfoResponse:
		return ((_ns1__UpdateVioPeccancyInfoResponse *)ptr)->soap_out(soap, "ns1:UpdateVioPeccancyInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__UpdateVioPeccancyInfo:
		return ((_ns1__UpdateVioPeccancyInfo *)ptr)->soap_out(soap, "ns1:UpdateVioPeccancyInfo", id, NULL);
	case SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfoResponse:
		return ((_ns1__GetVioPeccancyNoCheckInfoResponse *)ptr)->soap_out(soap, "ns1:GetVioPeccancyNoCheckInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfo:
		return ((_ns1__GetVioPeccancyNoCheckInfo *)ptr)->soap_out(soap, "ns1:GetVioPeccancyNoCheckInfo", id, NULL);
	case SOAP_TYPE__ns1__UpdatePeccancyInfoResponse:
		return ((_ns1__UpdatePeccancyInfoResponse *)ptr)->soap_out(soap, "ns1:UpdatePeccancyInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__UpdatePeccancyInfo:
		return ((_ns1__UpdatePeccancyInfo *)ptr)->soap_out(soap, "ns1:UpdatePeccancyInfo", id, NULL);
	case SOAP_TYPE__ns1__GetPeccancyNoCheckInfoResponse:
		return ((_ns1__GetPeccancyNoCheckInfoResponse *)ptr)->soap_out(soap, "ns1:GetPeccancyNoCheckInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPeccancyNoCheckInfo:
		return ((_ns1__GetPeccancyNoCheckInfo *)ptr)->soap_out(soap, "ns1:GetPeccancyNoCheckInfo", id, NULL);
	case SOAP_TYPE__ns1__GetPeccancyInfoResponse:
		return ((_ns1__GetPeccancyInfoResponse *)ptr)->soap_out(soap, "ns1:GetPeccancyInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPeccancyInfo:
		return ((_ns1__GetPeccancyInfo *)ptr)->soap_out(soap, "ns1:GetPeccancyInfo", id, NULL);
	case SOAP_TYPE__ns1__GetPassCarInfoResponse:
		return ((_ns1__GetPassCarInfoResponse *)ptr)->soap_out(soap, "ns1:GetPassCarInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__GetPassCarInfo:
		return ((_ns1__GetPassCarInfo *)ptr)->soap_out(soap, "ns1:GetPassCarInfo", id, NULL);
	case SOAP_TYPE__ns1__GetLocationInfoResponse:
		return ((_ns1__GetLocationInfoResponse *)ptr)->soap_out(soap, "ns1:GetLocationInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__GetLocationInfo:
		return ((_ns1__GetLocationInfo *)ptr)->soap_out(soap, "ns1:GetLocationInfo", id, NULL);
	case SOAP_TYPE__ns1__RevokeSuspicionInfoResponse:
		return ((_ns1__RevokeSuspicionInfoResponse *)ptr)->soap_out(soap, "ns1:RevokeSuspicionInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__RevokeSuspicionInfo:
		return ((_ns1__RevokeSuspicionInfo *)ptr)->soap_out(soap, "ns1:RevokeSuspicionInfo", id, NULL);
	case SOAP_TYPE__ns1__InSuspicionInfoResponse:
		return ((_ns1__InSuspicionInfoResponse *)ptr)->soap_out(soap, "ns1:InSuspicionInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__InSuspicionInfo:
		return ((_ns1__InSuspicionInfo *)ptr)->soap_out(soap, "ns1:InSuspicionInfo", id, NULL);
	case SOAP_TYPE__ns1__IntExtralistInfoResponse:
		return ((_ns1__IntExtralistInfoResponse *)ptr)->soap_out(soap, "ns1:IntExtralistInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__IntExtralistInfo:
		return ((_ns1__IntExtralistInfo *)ptr)->soap_out(soap, "ns1:IntExtralistInfo", id, NULL);
	case SOAP_TYPE__ns1__InChecklessInfoResponse:
		return ((_ns1__InChecklessInfoResponse *)ptr)->soap_out(soap, "ns1:InChecklessInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__InChecklessInfo:
		return ((_ns1__InChecklessInfo *)ptr)->soap_out(soap, "ns1:InChecklessInfo", id, NULL);
	case SOAP_TYPE__ns1__InBlacklistInfoResponse:
		return ((_ns1__InBlacklistInfoResponse *)ptr)->soap_out(soap, "ns1:InBlacklistInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__InBlacklistInfo:
		return ((_ns1__InBlacklistInfo *)ptr)->soap_out(soap, "ns1:InBlacklistInfo", id, NULL);
	case SOAP_TYPE__ns1__InCheckedPeccancyInfoResponse:
		return ((_ns1__InCheckedPeccancyInfoResponse *)ptr)->soap_out(soap, "ns1:InCheckedPeccancyInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__InCheckedPeccancyInfo:
		return ((_ns1__InCheckedPeccancyInfo *)ptr)->soap_out(soap, "ns1:InCheckedPeccancyInfo", id, NULL);
	case SOAP_TYPE__ns1__InPeccancyInfoResponse:
		return ((_ns1__InPeccancyInfoResponse *)ptr)->soap_out(soap, "ns1:InPeccancyInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__InPeccancyInfo:
		return ((_ns1__InPeccancyInfo *)ptr)->soap_out(soap, "ns1:InPeccancyInfo", id, NULL);
	case SOAP_TYPE__ns1__InPassCarInfoResponse:
		return ((_ns1__InPassCarInfoResponse *)ptr)->soap_out(soap, "ns1:InPassCarInfoResponse", id, NULL);
	case SOAP_TYPE__ns1__InPassCarInfo:
		return ((_ns1__InPassCarInfo *)ptr)->soap_out(soap, "ns1:InPassCarInfo", id, NULL);
	case SOAP_TYPE__ns1__CarPlateRecogResponse:
		return ((_ns1__CarPlateRecogResponse *)ptr)->soap_out(soap, "ns1:CarPlateRecogResponse", id, NULL);
	case SOAP_TYPE__ns1__CarPlateRecog:
		return ((_ns1__CarPlateRecog *)ptr)->soap_out(soap, "ns1:CarPlateRecog", id, NULL);
	case SOAP_TYPE__ns1__GetXMlFormatResponse:
		return ((_ns1__GetXMlFormatResponse *)ptr)->soap_out(soap, "ns1:GetXMlFormatResponse", id, NULL);
	case SOAP_TYPE__ns1__GetXMlFormat:
		return ((_ns1__GetXMlFormat *)ptr)->soap_out(soap, "ns1:GetXMlFormat", id, NULL);
	case SOAP_TYPE__ns1__GetCurrentVersionResponse:
		return ((_ns1__GetCurrentVersionResponse *)ptr)->soap_out(soap, "ns1:GetCurrentVersionResponse", id, NULL);
	case SOAP_TYPE__ns1__GetCurrentVersion:
		return ((_ns1__GetCurrentVersion *)ptr)->soap_out(soap, "ns1:GetCurrentVersion", id, NULL);
	case SOAP_TYPE__ns1__WebserviceTestResponse:
		return ((_ns1__WebserviceTestResponse *)ptr)->soap_out(soap, "ns1:WebserviceTestResponse", id, NULL);
	case SOAP_TYPE__ns1__WebserviceTest:
		return ((_ns1__WebserviceTest *)ptr)->soap_out(soap, "ns1:WebserviceTest", id, NULL);
	case SOAP_TYPE_PointerTo_ns1__CheckUserInfoResponse:
		return soap_out_PointerTo_ns1__CheckUserInfoResponse(soap, tag, id, (_ns1__CheckUserInfoResponse *const*)ptr, "ns1:CheckUserInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__CheckUserInfo:
		return soap_out_PointerTo_ns1__CheckUserInfo(soap, tag, id, (_ns1__CheckUserInfo *const*)ptr, "ns1:CheckUserInfo");
	case SOAP_TYPE_PointerTo_ns1__addTransRecInfoResponse:
		return soap_out_PointerTo_ns1__addTransRecInfoResponse(soap, tag, id, (_ns1__addTransRecInfoResponse *const*)ptr, "ns1:addTransRecInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__addTransRecInfo:
		return soap_out_PointerTo_ns1__addTransRecInfo(soap, tag, id, (_ns1__addTransRecInfo *const*)ptr, "ns1:addTransRecInfo");
	case SOAP_TYPE_PointerTo_ns1__GetJdsbhRecoveryInfoResponse:
		return soap_out_PointerTo_ns1__GetJdsbhRecoveryInfoResponse(soap, tag, id, (_ns1__GetJdsbhRecoveryInfoResponse *const*)ptr, "ns1:GetJdsbhRecoveryInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetJdsbhRecoveryInfo:
		return soap_out_PointerTo_ns1__GetJdsbhRecoveryInfo(soap, tag, id, (_ns1__GetJdsbhRecoveryInfo *const*)ptr, "ns1:GetJdsbhRecoveryInfo");
	case SOAP_TYPE_PointerTo_ns1__GetJdsbhRecoveryResponse:
		return soap_out_PointerTo_ns1__GetJdsbhRecoveryResponse(soap, tag, id, (_ns1__GetJdsbhRecoveryResponse *const*)ptr, "ns1:GetJdsbhRecoveryResponse");
	case SOAP_TYPE_PointerTo_ns1__GetJdsbhRecovery:
		return soap_out_PointerTo_ns1__GetJdsbhRecovery(soap, tag, id, (_ns1__GetJdsbhRecovery *const*)ptr, "ns1:GetJdsbhRecovery");
	case SOAP_TYPE_PointerTo_ns1__GetViolationInfoResponse:
		return soap_out_PointerTo_ns1__GetViolationInfoResponse(soap, tag, id, (_ns1__GetViolationInfoResponse *const*)ptr, "ns1:GetViolationInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetViolationInfo:
		return soap_out_PointerTo_ns1__GetViolationInfo(soap, tag, id, (_ns1__GetViolationInfo *const*)ptr, "ns1:GetViolationInfo");
	case SOAP_TYPE_PointerTo_ns1__InViolationInfoResponse:
		return soap_out_PointerTo_ns1__InViolationInfoResponse(soap, tag, id, (_ns1__InViolationInfoResponse *const*)ptr, "ns1:InViolationInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__InViolationInfo:
		return soap_out_PointerTo_ns1__InViolationInfo(soap, tag, id, (_ns1__InViolationInfo *const*)ptr, "ns1:InViolationInfo");
	case SOAP_TYPE_PointerTo_ns1__UpdataDeviceStateResponse:
		return soap_out_PointerTo_ns1__UpdataDeviceStateResponse(soap, tag, id, (_ns1__UpdataDeviceStateResponse *const*)ptr, "ns1:UpdataDeviceStateResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdataDeviceState:
		return soap_out_PointerTo_ns1__UpdataDeviceState(soap, tag, id, (_ns1__UpdataDeviceState *const*)ptr, "ns1:UpdataDeviceState");
	case SOAP_TYPE_PointerTo_ns1__GetAlarmInfoResponse:
		return soap_out_PointerTo_ns1__GetAlarmInfoResponse(soap, tag, id, (_ns1__GetAlarmInfoResponse *const*)ptr, "ns1:GetAlarmInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetAlarmInfo:
		return soap_out_PointerTo_ns1__GetAlarmInfo(soap, tag, id, (_ns1__GetAlarmInfo *const*)ptr, "ns1:GetAlarmInfo");
	case SOAP_TYPE_PointerTo_ns1__UpdateVioPeccancyInfoResponse:
		return soap_out_PointerTo_ns1__UpdateVioPeccancyInfoResponse(soap, tag, id, (_ns1__UpdateVioPeccancyInfoResponse *const*)ptr, "ns1:UpdateVioPeccancyInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdateVioPeccancyInfo:
		return soap_out_PointerTo_ns1__UpdateVioPeccancyInfo(soap, tag, id, (_ns1__UpdateVioPeccancyInfo *const*)ptr, "ns1:UpdateVioPeccancyInfo");
	case SOAP_TYPE_PointerTo_ns1__GetVioPeccancyNoCheckInfoResponse:
		return soap_out_PointerTo_ns1__GetVioPeccancyNoCheckInfoResponse(soap, tag, id, (_ns1__GetVioPeccancyNoCheckInfoResponse *const*)ptr, "ns1:GetVioPeccancyNoCheckInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetVioPeccancyNoCheckInfo:
		return soap_out_PointerTo_ns1__GetVioPeccancyNoCheckInfo(soap, tag, id, (_ns1__GetVioPeccancyNoCheckInfo *const*)ptr, "ns1:GetVioPeccancyNoCheckInfo");
	case SOAP_TYPE_PointerTo_ns1__UpdatePeccancyInfoResponse:
		return soap_out_PointerTo_ns1__UpdatePeccancyInfoResponse(soap, tag, id, (_ns1__UpdatePeccancyInfoResponse *const*)ptr, "ns1:UpdatePeccancyInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__UpdatePeccancyInfo:
		return soap_out_PointerTo_ns1__UpdatePeccancyInfo(soap, tag, id, (_ns1__UpdatePeccancyInfo *const*)ptr, "ns1:UpdatePeccancyInfo");
	case SOAP_TYPE_PointerTo_ns1__GetPeccancyNoCheckInfoResponse:
		return soap_out_PointerTo_ns1__GetPeccancyNoCheckInfoResponse(soap, tag, id, (_ns1__GetPeccancyNoCheckInfoResponse *const*)ptr, "ns1:GetPeccancyNoCheckInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPeccancyNoCheckInfo:
		return soap_out_PointerTo_ns1__GetPeccancyNoCheckInfo(soap, tag, id, (_ns1__GetPeccancyNoCheckInfo *const*)ptr, "ns1:GetPeccancyNoCheckInfo");
	case SOAP_TYPE_PointerTo_ns1__GetPeccancyInfoResponse:
		return soap_out_PointerTo_ns1__GetPeccancyInfoResponse(soap, tag, id, (_ns1__GetPeccancyInfoResponse *const*)ptr, "ns1:GetPeccancyInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPeccancyInfo:
		return soap_out_PointerTo_ns1__GetPeccancyInfo(soap, tag, id, (_ns1__GetPeccancyInfo *const*)ptr, "ns1:GetPeccancyInfo");
	case SOAP_TYPE_PointerTo_ns1__GetPassCarInfoResponse:
		return soap_out_PointerTo_ns1__GetPassCarInfoResponse(soap, tag, id, (_ns1__GetPassCarInfoResponse *const*)ptr, "ns1:GetPassCarInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetPassCarInfo:
		return soap_out_PointerTo_ns1__GetPassCarInfo(soap, tag, id, (_ns1__GetPassCarInfo *const*)ptr, "ns1:GetPassCarInfo");
	case SOAP_TYPE_PointerTo_ns1__GetLocationInfoResponse:
		return soap_out_PointerTo_ns1__GetLocationInfoResponse(soap, tag, id, (_ns1__GetLocationInfoResponse *const*)ptr, "ns1:GetLocationInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__GetLocationInfo:
		return soap_out_PointerTo_ns1__GetLocationInfo(soap, tag, id, (_ns1__GetLocationInfo *const*)ptr, "ns1:GetLocationInfo");
	case SOAP_TYPE_PointerTo_ns1__RevokeSuspicionInfoResponse:
		return soap_out_PointerTo_ns1__RevokeSuspicionInfoResponse(soap, tag, id, (_ns1__RevokeSuspicionInfoResponse *const*)ptr, "ns1:RevokeSuspicionInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__RevokeSuspicionInfo:
		return soap_out_PointerTo_ns1__RevokeSuspicionInfo(soap, tag, id, (_ns1__RevokeSuspicionInfo *const*)ptr, "ns1:RevokeSuspicionInfo");
	case SOAP_TYPE_PointerTo_ns1__InSuspicionInfoResponse:
		return soap_out_PointerTo_ns1__InSuspicionInfoResponse(soap, tag, id, (_ns1__InSuspicionInfoResponse *const*)ptr, "ns1:InSuspicionInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__InSuspicionInfo:
		return soap_out_PointerTo_ns1__InSuspicionInfo(soap, tag, id, (_ns1__InSuspicionInfo *const*)ptr, "ns1:InSuspicionInfo");
	case SOAP_TYPE_PointerTo_ns1__IntExtralistInfoResponse:
		return soap_out_PointerTo_ns1__IntExtralistInfoResponse(soap, tag, id, (_ns1__IntExtralistInfoResponse *const*)ptr, "ns1:IntExtralistInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__IntExtralistInfo:
		return soap_out_PointerTo_ns1__IntExtralistInfo(soap, tag, id, (_ns1__IntExtralistInfo *const*)ptr, "ns1:IntExtralistInfo");
	case SOAP_TYPE_PointerTo_ns1__InChecklessInfoResponse:
		return soap_out_PointerTo_ns1__InChecklessInfoResponse(soap, tag, id, (_ns1__InChecklessInfoResponse *const*)ptr, "ns1:InChecklessInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__InChecklessInfo:
		return soap_out_PointerTo_ns1__InChecklessInfo(soap, tag, id, (_ns1__InChecklessInfo *const*)ptr, "ns1:InChecklessInfo");
	case SOAP_TYPE_PointerTo_ns1__InBlacklistInfoResponse:
		return soap_out_PointerTo_ns1__InBlacklistInfoResponse(soap, tag, id, (_ns1__InBlacklistInfoResponse *const*)ptr, "ns1:InBlacklistInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__InBlacklistInfo:
		return soap_out_PointerTo_ns1__InBlacklistInfo(soap, tag, id, (_ns1__InBlacklistInfo *const*)ptr, "ns1:InBlacklistInfo");
	case SOAP_TYPE_PointerTo_ns1__InCheckedPeccancyInfoResponse:
		return soap_out_PointerTo_ns1__InCheckedPeccancyInfoResponse(soap, tag, id, (_ns1__InCheckedPeccancyInfoResponse *const*)ptr, "ns1:InCheckedPeccancyInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__InCheckedPeccancyInfo:
		return soap_out_PointerTo_ns1__InCheckedPeccancyInfo(soap, tag, id, (_ns1__InCheckedPeccancyInfo *const*)ptr, "ns1:InCheckedPeccancyInfo");
	case SOAP_TYPE_PointerTo_ns1__InPeccancyInfoResponse:
		return soap_out_PointerTo_ns1__InPeccancyInfoResponse(soap, tag, id, (_ns1__InPeccancyInfoResponse *const*)ptr, "ns1:InPeccancyInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__InPeccancyInfo:
		return soap_out_PointerTo_ns1__InPeccancyInfo(soap, tag, id, (_ns1__InPeccancyInfo *const*)ptr, "ns1:InPeccancyInfo");
	case SOAP_TYPE_PointerTo_ns1__InPassCarInfoResponse:
		return soap_out_PointerTo_ns1__InPassCarInfoResponse(soap, tag, id, (_ns1__InPassCarInfoResponse *const*)ptr, "ns1:InPassCarInfoResponse");
	case SOAP_TYPE_PointerTo_ns1__InPassCarInfo:
		return soap_out_PointerTo_ns1__InPassCarInfo(soap, tag, id, (_ns1__InPassCarInfo *const*)ptr, "ns1:InPassCarInfo");
	case SOAP_TYPE_PointerTo_ns1__CarPlateRecogResponse:
		return soap_out_PointerTo_ns1__CarPlateRecogResponse(soap, tag, id, (_ns1__CarPlateRecogResponse *const*)ptr, "ns1:CarPlateRecogResponse");
	case SOAP_TYPE_PointerTo_ns1__CarPlateRecog:
		return soap_out_PointerTo_ns1__CarPlateRecog(soap, tag, id, (_ns1__CarPlateRecog *const*)ptr, "ns1:CarPlateRecog");
	case SOAP_TYPE_PointerTo_ns1__GetXMlFormatResponse:
		return soap_out_PointerTo_ns1__GetXMlFormatResponse(soap, tag, id, (_ns1__GetXMlFormatResponse *const*)ptr, "ns1:GetXMlFormatResponse");
	case SOAP_TYPE_PointerTo_ns1__GetXMlFormat:
		return soap_out_PointerTo_ns1__GetXMlFormat(soap, tag, id, (_ns1__GetXMlFormat *const*)ptr, "ns1:GetXMlFormat");
	case SOAP_TYPE_PointerTo_ns1__GetCurrentVersionResponse:
		return soap_out_PointerTo_ns1__GetCurrentVersionResponse(soap, tag, id, (_ns1__GetCurrentVersionResponse *const*)ptr, "ns1:GetCurrentVersionResponse");
	case SOAP_TYPE_PointerTo_ns1__GetCurrentVersion:
		return soap_out_PointerTo_ns1__GetCurrentVersion(soap, tag, id, (_ns1__GetCurrentVersion *const*)ptr, "ns1:GetCurrentVersion");
	case SOAP_TYPE_PointerTo_ns1__WebserviceTestResponse:
		return soap_out_PointerTo_ns1__WebserviceTestResponse(soap, tag, id, (_ns1__WebserviceTestResponse *const*)ptr, "ns1:WebserviceTestResponse");
	case SOAP_TYPE_PointerTo_ns1__WebserviceTest:
		return soap_out_PointerTo_ns1__WebserviceTest(soap, tag, id, (_ns1__WebserviceTest *const*)ptr, "ns1:WebserviceTest");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns1__CheckUserInfoResponse:
		((_ns1__CheckUserInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CheckUserInfo:
		((_ns1__CheckUserInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__addTransRecInfoResponse:
		((_ns1__addTransRecInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__addTransRecInfo:
		((_ns1__addTransRecInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetJdsbhRecoveryInfoResponse:
		((_ns1__GetJdsbhRecoveryInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetJdsbhRecoveryInfo:
		((_ns1__GetJdsbhRecoveryInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetJdsbhRecoveryResponse:
		((_ns1__GetJdsbhRecoveryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetJdsbhRecovery:
		((_ns1__GetJdsbhRecovery *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetViolationInfoResponse:
		((_ns1__GetViolationInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetViolationInfo:
		((_ns1__GetViolationInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InViolationInfoResponse:
		((_ns1__InViolationInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InViolationInfo:
		((_ns1__InViolationInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdataDeviceStateResponse:
		((_ns1__UpdataDeviceStateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdataDeviceState:
		((_ns1__UpdataDeviceState *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAlarmInfoResponse:
		((_ns1__GetAlarmInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAlarmInfo:
		((_ns1__GetAlarmInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdateVioPeccancyInfoResponse:
		((_ns1__UpdateVioPeccancyInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdateVioPeccancyInfo:
		((_ns1__UpdateVioPeccancyInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfoResponse:
		((_ns1__GetVioPeccancyNoCheckInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfo:
		((_ns1__GetVioPeccancyNoCheckInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdatePeccancyInfoResponse:
		((_ns1__UpdatePeccancyInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__UpdatePeccancyInfo:
		((_ns1__UpdatePeccancyInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPeccancyNoCheckInfoResponse:
		((_ns1__GetPeccancyNoCheckInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPeccancyNoCheckInfo:
		((_ns1__GetPeccancyNoCheckInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPeccancyInfoResponse:
		((_ns1__GetPeccancyInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPeccancyInfo:
		((_ns1__GetPeccancyInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPassCarInfoResponse:
		((_ns1__GetPassCarInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetPassCarInfo:
		((_ns1__GetPassCarInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLocationInfoResponse:
		((_ns1__GetLocationInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetLocationInfo:
		((_ns1__GetLocationInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RevokeSuspicionInfoResponse:
		((_ns1__RevokeSuspicionInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RevokeSuspicionInfo:
		((_ns1__RevokeSuspicionInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InSuspicionInfoResponse:
		((_ns1__InSuspicionInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InSuspicionInfo:
		((_ns1__InSuspicionInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__IntExtralistInfoResponse:
		((_ns1__IntExtralistInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__IntExtralistInfo:
		((_ns1__IntExtralistInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InChecklessInfoResponse:
		((_ns1__InChecklessInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InChecklessInfo:
		((_ns1__InChecklessInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InBlacklistInfoResponse:
		((_ns1__InBlacklistInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InBlacklistInfo:
		((_ns1__InBlacklistInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InCheckedPeccancyInfoResponse:
		((_ns1__InCheckedPeccancyInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InCheckedPeccancyInfo:
		((_ns1__InCheckedPeccancyInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InPeccancyInfoResponse:
		((_ns1__InPeccancyInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InPeccancyInfo:
		((_ns1__InPeccancyInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InPassCarInfoResponse:
		((_ns1__InPassCarInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__InPassCarInfo:
		((_ns1__InPassCarInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CarPlateRecogResponse:
		((_ns1__CarPlateRecogResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CarPlateRecog:
		((_ns1__CarPlateRecog *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetXMlFormatResponse:
		((_ns1__GetXMlFormatResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetXMlFormat:
		((_ns1__GetXMlFormat *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetCurrentVersionResponse:
		((_ns1__GetCurrentVersionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetCurrentVersion:
		((_ns1__GetCurrentVersion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__WebserviceTestResponse:
		((_ns1__WebserviceTestResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__WebserviceTest:
		((_ns1__WebserviceTest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__CheckUserInfo_:
		soap_serialize___ns1__CheckUserInfo_(soap, (const struct __ns1__CheckUserInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__addTransRecInfo_:
		soap_serialize___ns1__addTransRecInfo_(soap, (const struct __ns1__addTransRecInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetJdsbhRecoveryInfo_:
		soap_serialize___ns1__GetJdsbhRecoveryInfo_(soap, (const struct __ns1__GetJdsbhRecoveryInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetJdsbhRecovery_:
		soap_serialize___ns1__GetJdsbhRecovery_(soap, (const struct __ns1__GetJdsbhRecovery_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetViolationInfo_:
		soap_serialize___ns1__GetViolationInfo_(soap, (const struct __ns1__GetViolationInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InViolationInfo_:
		soap_serialize___ns1__InViolationInfo_(soap, (const struct __ns1__InViolationInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__UpdataDeviceState_:
		soap_serialize___ns1__UpdataDeviceState_(soap, (const struct __ns1__UpdataDeviceState_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAlarmInfo_:
		soap_serialize___ns1__GetAlarmInfo_(soap, (const struct __ns1__GetAlarmInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__UpdateVioPeccancyInfo_:
		soap_serialize___ns1__UpdateVioPeccancyInfo_(soap, (const struct __ns1__UpdateVioPeccancyInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetVioPeccancyNoCheckInfo_:
		soap_serialize___ns1__GetVioPeccancyNoCheckInfo_(soap, (const struct __ns1__GetVioPeccancyNoCheckInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__UpdatePeccancyInfo_:
		soap_serialize___ns1__UpdatePeccancyInfo_(soap, (const struct __ns1__UpdatePeccancyInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetPeccancyNoCheckInfo_:
		soap_serialize___ns1__GetPeccancyNoCheckInfo_(soap, (const struct __ns1__GetPeccancyNoCheckInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetPeccancyInfo_:
		soap_serialize___ns1__GetPeccancyInfo_(soap, (const struct __ns1__GetPeccancyInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetPassCarInfo_:
		soap_serialize___ns1__GetPassCarInfo_(soap, (const struct __ns1__GetPassCarInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetLocationInfo_:
		soap_serialize___ns1__GetLocationInfo_(soap, (const struct __ns1__GetLocationInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__RevokeSuspicionInfo_:
		soap_serialize___ns1__RevokeSuspicionInfo_(soap, (const struct __ns1__RevokeSuspicionInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InSuspicionInfo_:
		soap_serialize___ns1__InSuspicionInfo_(soap, (const struct __ns1__InSuspicionInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__IntExtralistInfo_:
		soap_serialize___ns1__IntExtralistInfo_(soap, (const struct __ns1__IntExtralistInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InChecklessInfo_:
		soap_serialize___ns1__InChecklessInfo_(soap, (const struct __ns1__InChecklessInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InBlacklistInfo_:
		soap_serialize___ns1__InBlacklistInfo_(soap, (const struct __ns1__InBlacklistInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InCheckedPeccancyInfo_:
		soap_serialize___ns1__InCheckedPeccancyInfo_(soap, (const struct __ns1__InCheckedPeccancyInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InPeccancyInfo_:
		soap_serialize___ns1__InPeccancyInfo_(soap, (const struct __ns1__InPeccancyInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__InPassCarInfo_:
		soap_serialize___ns1__InPassCarInfo_(soap, (const struct __ns1__InPassCarInfo_ *)ptr);
		break;
	case SOAP_TYPE___ns1__CarPlateRecog_:
		soap_serialize___ns1__CarPlateRecog_(soap, (const struct __ns1__CarPlateRecog_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetXMlFormat_:
		soap_serialize___ns1__GetXMlFormat_(soap, (const struct __ns1__GetXMlFormat_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetCurrentVersion_:
		soap_serialize___ns1__GetCurrentVersion_(soap, (const struct __ns1__GetCurrentVersion_ *)ptr);
		break;
	case SOAP_TYPE___ns1__WebserviceTest_:
		soap_serialize___ns1__WebserviceTest_(soap, (const struct __ns1__WebserviceTest_ *)ptr);
		break;
	case SOAP_TYPE___ns1__CheckUserInfo:
		soap_serialize___ns1__CheckUserInfo(soap, (const struct __ns1__CheckUserInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__addTransRecInfo:
		soap_serialize___ns1__addTransRecInfo(soap, (const struct __ns1__addTransRecInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GetJdsbhRecoveryInfo:
		soap_serialize___ns1__GetJdsbhRecoveryInfo(soap, (const struct __ns1__GetJdsbhRecoveryInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GetJdsbhRecovery:
		soap_serialize___ns1__GetJdsbhRecovery(soap, (const struct __ns1__GetJdsbhRecovery *)ptr);
		break;
	case SOAP_TYPE___ns1__GetViolationInfo:
		soap_serialize___ns1__GetViolationInfo(soap, (const struct __ns1__GetViolationInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__InViolationInfo:
		soap_serialize___ns1__InViolationInfo(soap, (const struct __ns1__InViolationInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__UpdataDeviceState:
		soap_serialize___ns1__UpdataDeviceState(soap, (const struct __ns1__UpdataDeviceState *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAlarmInfo:
		soap_serialize___ns1__GetAlarmInfo(soap, (const struct __ns1__GetAlarmInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__UpdateVioPeccancyInfo:
		soap_serialize___ns1__UpdateVioPeccancyInfo(soap, (const struct __ns1__UpdateVioPeccancyInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GetVioPeccancyNoCheckInfo:
		soap_serialize___ns1__GetVioPeccancyNoCheckInfo(soap, (const struct __ns1__GetVioPeccancyNoCheckInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__UpdatePeccancyInfo:
		soap_serialize___ns1__UpdatePeccancyInfo(soap, (const struct __ns1__UpdatePeccancyInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GetPeccancyNoCheckInfo:
		soap_serialize___ns1__GetPeccancyNoCheckInfo(soap, (const struct __ns1__GetPeccancyNoCheckInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GetPeccancyInfo:
		soap_serialize___ns1__GetPeccancyInfo(soap, (const struct __ns1__GetPeccancyInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GetPassCarInfo:
		soap_serialize___ns1__GetPassCarInfo(soap, (const struct __ns1__GetPassCarInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__GetLocationInfo:
		soap_serialize___ns1__GetLocationInfo(soap, (const struct __ns1__GetLocationInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__RevokeSuspicionInfo:
		soap_serialize___ns1__RevokeSuspicionInfo(soap, (const struct __ns1__RevokeSuspicionInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__InSuspicionInfo:
		soap_serialize___ns1__InSuspicionInfo(soap, (const struct __ns1__InSuspicionInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__IntExtralistInfo:
		soap_serialize___ns1__IntExtralistInfo(soap, (const struct __ns1__IntExtralistInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__InChecklessInfo:
		soap_serialize___ns1__InChecklessInfo(soap, (const struct __ns1__InChecklessInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__InBlacklistInfo:
		soap_serialize___ns1__InBlacklistInfo(soap, (const struct __ns1__InBlacklistInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__InCheckedPeccancyInfo:
		soap_serialize___ns1__InCheckedPeccancyInfo(soap, (const struct __ns1__InCheckedPeccancyInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__InPeccancyInfo:
		soap_serialize___ns1__InPeccancyInfo(soap, (const struct __ns1__InPeccancyInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__InPassCarInfo:
		soap_serialize___ns1__InPassCarInfo(soap, (const struct __ns1__InPassCarInfo *)ptr);
		break;
	case SOAP_TYPE___ns1__CarPlateRecog:
		soap_serialize___ns1__CarPlateRecog(soap, (const struct __ns1__CarPlateRecog *)ptr);
		break;
	case SOAP_TYPE___ns1__GetXMlFormat:
		soap_serialize___ns1__GetXMlFormat(soap, (const struct __ns1__GetXMlFormat *)ptr);
		break;
	case SOAP_TYPE___ns1__GetCurrentVersion:
		soap_serialize___ns1__GetCurrentVersion(soap, (const struct __ns1__GetCurrentVersion *)ptr);
		break;
	case SOAP_TYPE___ns1__WebserviceTest:
		soap_serialize___ns1__WebserviceTest(soap, (const struct __ns1__WebserviceTest *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CheckUserInfoResponse:
		soap_serialize_PointerTo_ns1__CheckUserInfoResponse(soap, (_ns1__CheckUserInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CheckUserInfo:
		soap_serialize_PointerTo_ns1__CheckUserInfo(soap, (_ns1__CheckUserInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addTransRecInfoResponse:
		soap_serialize_PointerTo_ns1__addTransRecInfoResponse(soap, (_ns1__addTransRecInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__addTransRecInfo:
		soap_serialize_PointerTo_ns1__addTransRecInfo(soap, (_ns1__addTransRecInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetJdsbhRecoveryInfoResponse:
		soap_serialize_PointerTo_ns1__GetJdsbhRecoveryInfoResponse(soap, (_ns1__GetJdsbhRecoveryInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetJdsbhRecoveryInfo:
		soap_serialize_PointerTo_ns1__GetJdsbhRecoveryInfo(soap, (_ns1__GetJdsbhRecoveryInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetJdsbhRecoveryResponse:
		soap_serialize_PointerTo_ns1__GetJdsbhRecoveryResponse(soap, (_ns1__GetJdsbhRecoveryResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetJdsbhRecovery:
		soap_serialize_PointerTo_ns1__GetJdsbhRecovery(soap, (_ns1__GetJdsbhRecovery *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetViolationInfoResponse:
		soap_serialize_PointerTo_ns1__GetViolationInfoResponse(soap, (_ns1__GetViolationInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetViolationInfo:
		soap_serialize_PointerTo_ns1__GetViolationInfo(soap, (_ns1__GetViolationInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InViolationInfoResponse:
		soap_serialize_PointerTo_ns1__InViolationInfoResponse(soap, (_ns1__InViolationInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InViolationInfo:
		soap_serialize_PointerTo_ns1__InViolationInfo(soap, (_ns1__InViolationInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdataDeviceStateResponse:
		soap_serialize_PointerTo_ns1__UpdataDeviceStateResponse(soap, (_ns1__UpdataDeviceStateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdataDeviceState:
		soap_serialize_PointerTo_ns1__UpdataDeviceState(soap, (_ns1__UpdataDeviceState *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAlarmInfoResponse:
		soap_serialize_PointerTo_ns1__GetAlarmInfoResponse(soap, (_ns1__GetAlarmInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAlarmInfo:
		soap_serialize_PointerTo_ns1__GetAlarmInfo(soap, (_ns1__GetAlarmInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdateVioPeccancyInfoResponse:
		soap_serialize_PointerTo_ns1__UpdateVioPeccancyInfoResponse(soap, (_ns1__UpdateVioPeccancyInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdateVioPeccancyInfo:
		soap_serialize_PointerTo_ns1__UpdateVioPeccancyInfo(soap, (_ns1__UpdateVioPeccancyInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetVioPeccancyNoCheckInfoResponse:
		soap_serialize_PointerTo_ns1__GetVioPeccancyNoCheckInfoResponse(soap, (_ns1__GetVioPeccancyNoCheckInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetVioPeccancyNoCheckInfo:
		soap_serialize_PointerTo_ns1__GetVioPeccancyNoCheckInfo(soap, (_ns1__GetVioPeccancyNoCheckInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdatePeccancyInfoResponse:
		soap_serialize_PointerTo_ns1__UpdatePeccancyInfoResponse(soap, (_ns1__UpdatePeccancyInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__UpdatePeccancyInfo:
		soap_serialize_PointerTo_ns1__UpdatePeccancyInfo(soap, (_ns1__UpdatePeccancyInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPeccancyNoCheckInfoResponse:
		soap_serialize_PointerTo_ns1__GetPeccancyNoCheckInfoResponse(soap, (_ns1__GetPeccancyNoCheckInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPeccancyNoCheckInfo:
		soap_serialize_PointerTo_ns1__GetPeccancyNoCheckInfo(soap, (_ns1__GetPeccancyNoCheckInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPeccancyInfoResponse:
		soap_serialize_PointerTo_ns1__GetPeccancyInfoResponse(soap, (_ns1__GetPeccancyInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPeccancyInfo:
		soap_serialize_PointerTo_ns1__GetPeccancyInfo(soap, (_ns1__GetPeccancyInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPassCarInfoResponse:
		soap_serialize_PointerTo_ns1__GetPassCarInfoResponse(soap, (_ns1__GetPassCarInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetPassCarInfo:
		soap_serialize_PointerTo_ns1__GetPassCarInfo(soap, (_ns1__GetPassCarInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetLocationInfoResponse:
		soap_serialize_PointerTo_ns1__GetLocationInfoResponse(soap, (_ns1__GetLocationInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetLocationInfo:
		soap_serialize_PointerTo_ns1__GetLocationInfo(soap, (_ns1__GetLocationInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RevokeSuspicionInfoResponse:
		soap_serialize_PointerTo_ns1__RevokeSuspicionInfoResponse(soap, (_ns1__RevokeSuspicionInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RevokeSuspicionInfo:
		soap_serialize_PointerTo_ns1__RevokeSuspicionInfo(soap, (_ns1__RevokeSuspicionInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InSuspicionInfoResponse:
		soap_serialize_PointerTo_ns1__InSuspicionInfoResponse(soap, (_ns1__InSuspicionInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InSuspicionInfo:
		soap_serialize_PointerTo_ns1__InSuspicionInfo(soap, (_ns1__InSuspicionInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__IntExtralistInfoResponse:
		soap_serialize_PointerTo_ns1__IntExtralistInfoResponse(soap, (_ns1__IntExtralistInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__IntExtralistInfo:
		soap_serialize_PointerTo_ns1__IntExtralistInfo(soap, (_ns1__IntExtralistInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InChecklessInfoResponse:
		soap_serialize_PointerTo_ns1__InChecklessInfoResponse(soap, (_ns1__InChecklessInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InChecklessInfo:
		soap_serialize_PointerTo_ns1__InChecklessInfo(soap, (_ns1__InChecklessInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InBlacklistInfoResponse:
		soap_serialize_PointerTo_ns1__InBlacklistInfoResponse(soap, (_ns1__InBlacklistInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InBlacklistInfo:
		soap_serialize_PointerTo_ns1__InBlacklistInfo(soap, (_ns1__InBlacklistInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InCheckedPeccancyInfoResponse:
		soap_serialize_PointerTo_ns1__InCheckedPeccancyInfoResponse(soap, (_ns1__InCheckedPeccancyInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InCheckedPeccancyInfo:
		soap_serialize_PointerTo_ns1__InCheckedPeccancyInfo(soap, (_ns1__InCheckedPeccancyInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InPeccancyInfoResponse:
		soap_serialize_PointerTo_ns1__InPeccancyInfoResponse(soap, (_ns1__InPeccancyInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InPeccancyInfo:
		soap_serialize_PointerTo_ns1__InPeccancyInfo(soap, (_ns1__InPeccancyInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InPassCarInfoResponse:
		soap_serialize_PointerTo_ns1__InPassCarInfoResponse(soap, (_ns1__InPassCarInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__InPassCarInfo:
		soap_serialize_PointerTo_ns1__InPassCarInfo(soap, (_ns1__InPassCarInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CarPlateRecogResponse:
		soap_serialize_PointerTo_ns1__CarPlateRecogResponse(soap, (_ns1__CarPlateRecogResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CarPlateRecog:
		soap_serialize_PointerTo_ns1__CarPlateRecog(soap, (_ns1__CarPlateRecog *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetXMlFormatResponse:
		soap_serialize_PointerTo_ns1__GetXMlFormatResponse(soap, (_ns1__GetXMlFormatResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetXMlFormat:
		soap_serialize_PointerTo_ns1__GetXMlFormat(soap, (_ns1__GetXMlFormat *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetCurrentVersionResponse:
		soap_serialize_PointerTo_ns1__GetCurrentVersionResponse(soap, (_ns1__GetCurrentVersionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetCurrentVersion:
		soap_serialize_PointerTo_ns1__GetCurrentVersion(soap, (_ns1__GetCurrentVersion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__WebserviceTestResponse:
		soap_serialize_PointerTo_ns1__WebserviceTestResponse(soap, (_ns1__WebserviceTestResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__WebserviceTest:
		soap_serialize_PointerTo_ns1__WebserviceTest(soap, (_ns1__WebserviceTest *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE__ns1__WebserviceTest:
		return (void*)soap_instantiate__ns1__WebserviceTest(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__WebserviceTestResponse:
		return (void*)soap_instantiate__ns1__WebserviceTestResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetCurrentVersion:
		return (void*)soap_instantiate__ns1__GetCurrentVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetCurrentVersionResponse:
		return (void*)soap_instantiate__ns1__GetCurrentVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetXMlFormat:
		return (void*)soap_instantiate__ns1__GetXMlFormat(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetXMlFormatResponse:
		return (void*)soap_instantiate__ns1__GetXMlFormatResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CarPlateRecog:
		return (void*)soap_instantiate__ns1__CarPlateRecog(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CarPlateRecogResponse:
		return (void*)soap_instantiate__ns1__CarPlateRecogResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InPassCarInfo:
		return (void*)soap_instantiate__ns1__InPassCarInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InPassCarInfoResponse:
		return (void*)soap_instantiate__ns1__InPassCarInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InPeccancyInfo:
		return (void*)soap_instantiate__ns1__InPeccancyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InPeccancyInfoResponse:
		return (void*)soap_instantiate__ns1__InPeccancyInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InCheckedPeccancyInfo:
		return (void*)soap_instantiate__ns1__InCheckedPeccancyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InCheckedPeccancyInfoResponse:
		return (void*)soap_instantiate__ns1__InCheckedPeccancyInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InBlacklistInfo:
		return (void*)soap_instantiate__ns1__InBlacklistInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InBlacklistInfoResponse:
		return (void*)soap_instantiate__ns1__InBlacklistInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InChecklessInfo:
		return (void*)soap_instantiate__ns1__InChecklessInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InChecklessInfoResponse:
		return (void*)soap_instantiate__ns1__InChecklessInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__IntExtralistInfo:
		return (void*)soap_instantiate__ns1__IntExtralistInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__IntExtralistInfoResponse:
		return (void*)soap_instantiate__ns1__IntExtralistInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InSuspicionInfo:
		return (void*)soap_instantiate__ns1__InSuspicionInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InSuspicionInfoResponse:
		return (void*)soap_instantiate__ns1__InSuspicionInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RevokeSuspicionInfo:
		return (void*)soap_instantiate__ns1__RevokeSuspicionInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RevokeSuspicionInfoResponse:
		return (void*)soap_instantiate__ns1__RevokeSuspicionInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLocationInfo:
		return (void*)soap_instantiate__ns1__GetLocationInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetLocationInfoResponse:
		return (void*)soap_instantiate__ns1__GetLocationInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPassCarInfo:
		return (void*)soap_instantiate__ns1__GetPassCarInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPassCarInfoResponse:
		return (void*)soap_instantiate__ns1__GetPassCarInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPeccancyInfo:
		return (void*)soap_instantiate__ns1__GetPeccancyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPeccancyInfoResponse:
		return (void*)soap_instantiate__ns1__GetPeccancyInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPeccancyNoCheckInfo:
		return (void*)soap_instantiate__ns1__GetPeccancyNoCheckInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetPeccancyNoCheckInfoResponse:
		return (void*)soap_instantiate__ns1__GetPeccancyNoCheckInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdatePeccancyInfo:
		return (void*)soap_instantiate__ns1__UpdatePeccancyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdatePeccancyInfoResponse:
		return (void*)soap_instantiate__ns1__UpdatePeccancyInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfo:
		return (void*)soap_instantiate__ns1__GetVioPeccancyNoCheckInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfoResponse:
		return (void*)soap_instantiate__ns1__GetVioPeccancyNoCheckInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdateVioPeccancyInfo:
		return (void*)soap_instantiate__ns1__UpdateVioPeccancyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdateVioPeccancyInfoResponse:
		return (void*)soap_instantiate__ns1__UpdateVioPeccancyInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAlarmInfo:
		return (void*)soap_instantiate__ns1__GetAlarmInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAlarmInfoResponse:
		return (void*)soap_instantiate__ns1__GetAlarmInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdataDeviceState:
		return (void*)soap_instantiate__ns1__UpdataDeviceState(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__UpdataDeviceStateResponse:
		return (void*)soap_instantiate__ns1__UpdataDeviceStateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InViolationInfo:
		return (void*)soap_instantiate__ns1__InViolationInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__InViolationInfoResponse:
		return (void*)soap_instantiate__ns1__InViolationInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetViolationInfo:
		return (void*)soap_instantiate__ns1__GetViolationInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetViolationInfoResponse:
		return (void*)soap_instantiate__ns1__GetViolationInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetJdsbhRecovery:
		return (void*)soap_instantiate__ns1__GetJdsbhRecovery(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetJdsbhRecoveryResponse:
		return (void*)soap_instantiate__ns1__GetJdsbhRecoveryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetJdsbhRecoveryInfo:
		return (void*)soap_instantiate__ns1__GetJdsbhRecoveryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetJdsbhRecoveryInfoResponse:
		return (void*)soap_instantiate__ns1__GetJdsbhRecoveryInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addTransRecInfo:
		return (void*)soap_instantiate__ns1__addTransRecInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__addTransRecInfoResponse:
		return (void*)soap_instantiate__ns1__addTransRecInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CheckUserInfo:
		return (void*)soap_instantiate__ns1__CheckUserInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CheckUserInfoResponse:
		return (void*)soap_instantiate__ns1__CheckUserInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__WebserviceTest:
		return (void*)soap_instantiate___ns1__WebserviceTest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetCurrentVersion:
		return (void*)soap_instantiate___ns1__GetCurrentVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetXMlFormat:
		return (void*)soap_instantiate___ns1__GetXMlFormat(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CarPlateRecog:
		return (void*)soap_instantiate___ns1__CarPlateRecog(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InPassCarInfo:
		return (void*)soap_instantiate___ns1__InPassCarInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InPeccancyInfo:
		return (void*)soap_instantiate___ns1__InPeccancyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InCheckedPeccancyInfo:
		return (void*)soap_instantiate___ns1__InCheckedPeccancyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InBlacklistInfo:
		return (void*)soap_instantiate___ns1__InBlacklistInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InChecklessInfo:
		return (void*)soap_instantiate___ns1__InChecklessInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__IntExtralistInfo:
		return (void*)soap_instantiate___ns1__IntExtralistInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InSuspicionInfo:
		return (void*)soap_instantiate___ns1__InSuspicionInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__RevokeSuspicionInfo:
		return (void*)soap_instantiate___ns1__RevokeSuspicionInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetLocationInfo:
		return (void*)soap_instantiate___ns1__GetLocationInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetPassCarInfo:
		return (void*)soap_instantiate___ns1__GetPassCarInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetPeccancyInfo:
		return (void*)soap_instantiate___ns1__GetPeccancyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetPeccancyNoCheckInfo:
		return (void*)soap_instantiate___ns1__GetPeccancyNoCheckInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpdatePeccancyInfo:
		return (void*)soap_instantiate___ns1__UpdatePeccancyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetVioPeccancyNoCheckInfo:
		return (void*)soap_instantiate___ns1__GetVioPeccancyNoCheckInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpdateVioPeccancyInfo:
		return (void*)soap_instantiate___ns1__UpdateVioPeccancyInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAlarmInfo:
		return (void*)soap_instantiate___ns1__GetAlarmInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpdataDeviceState:
		return (void*)soap_instantiate___ns1__UpdataDeviceState(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InViolationInfo:
		return (void*)soap_instantiate___ns1__InViolationInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetViolationInfo:
		return (void*)soap_instantiate___ns1__GetViolationInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetJdsbhRecovery:
		return (void*)soap_instantiate___ns1__GetJdsbhRecovery(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetJdsbhRecoveryInfo:
		return (void*)soap_instantiate___ns1__GetJdsbhRecoveryInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addTransRecInfo:
		return (void*)soap_instantiate___ns1__addTransRecInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CheckUserInfo:
		return (void*)soap_instantiate___ns1__CheckUserInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__WebserviceTest_:
		return (void*)soap_instantiate___ns1__WebserviceTest_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetCurrentVersion_:
		return (void*)soap_instantiate___ns1__GetCurrentVersion_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetXMlFormat_:
		return (void*)soap_instantiate___ns1__GetXMlFormat_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CarPlateRecog_:
		return (void*)soap_instantiate___ns1__CarPlateRecog_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InPassCarInfo_:
		return (void*)soap_instantiate___ns1__InPassCarInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InPeccancyInfo_:
		return (void*)soap_instantiate___ns1__InPeccancyInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InCheckedPeccancyInfo_:
		return (void*)soap_instantiate___ns1__InCheckedPeccancyInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InBlacklistInfo_:
		return (void*)soap_instantiate___ns1__InBlacklistInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InChecklessInfo_:
		return (void*)soap_instantiate___ns1__InChecklessInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__IntExtralistInfo_:
		return (void*)soap_instantiate___ns1__IntExtralistInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InSuspicionInfo_:
		return (void*)soap_instantiate___ns1__InSuspicionInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__RevokeSuspicionInfo_:
		return (void*)soap_instantiate___ns1__RevokeSuspicionInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetLocationInfo_:
		return (void*)soap_instantiate___ns1__GetLocationInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetPassCarInfo_:
		return (void*)soap_instantiate___ns1__GetPassCarInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetPeccancyInfo_:
		return (void*)soap_instantiate___ns1__GetPeccancyInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetPeccancyNoCheckInfo_:
		return (void*)soap_instantiate___ns1__GetPeccancyNoCheckInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpdatePeccancyInfo_:
		return (void*)soap_instantiate___ns1__UpdatePeccancyInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetVioPeccancyNoCheckInfo_:
		return (void*)soap_instantiate___ns1__GetVioPeccancyNoCheckInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpdateVioPeccancyInfo_:
		return (void*)soap_instantiate___ns1__UpdateVioPeccancyInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAlarmInfo_:
		return (void*)soap_instantiate___ns1__GetAlarmInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__UpdataDeviceState_:
		return (void*)soap_instantiate___ns1__UpdataDeviceState_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__InViolationInfo_:
		return (void*)soap_instantiate___ns1__InViolationInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetViolationInfo_:
		return (void*)soap_instantiate___ns1__GetViolationInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetJdsbhRecovery_:
		return (void*)soap_instantiate___ns1__GetJdsbhRecovery_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetJdsbhRecoveryInfo_:
		return (void*)soap_instantiate___ns1__GetJdsbhRecoveryInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addTransRecInfo_:
		return (void*)soap_instantiate___ns1__addTransRecInfo_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CheckUserInfo_:
		return (void*)soap_instantiate___ns1__CheckUserInfo_(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE__ns1__WebserviceTest:
		if (p->size < 0)
			SOAP_DELETE((_ns1__WebserviceTest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__WebserviceTest*)p->ptr);
		break;
	case SOAP_TYPE__ns1__WebserviceTestResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__WebserviceTestResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__WebserviceTestResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetCurrentVersion:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetCurrentVersion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetCurrentVersion*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetCurrentVersionResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetCurrentVersionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetCurrentVersionResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetXMlFormat:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetXMlFormat*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetXMlFormat*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetXMlFormatResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetXMlFormatResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetXMlFormatResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__CarPlateRecog:
		if (p->size < 0)
			SOAP_DELETE((_ns1__CarPlateRecog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__CarPlateRecog*)p->ptr);
		break;
	case SOAP_TYPE__ns1__CarPlateRecogResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__CarPlateRecogResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__CarPlateRecogResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__InPassCarInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__InPassCarInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__InPassCarInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__InPassCarInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__InPassCarInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__InPassCarInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__InPeccancyInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__InPeccancyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__InPeccancyInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__InPeccancyInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__InPeccancyInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__InPeccancyInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__InCheckedPeccancyInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__InCheckedPeccancyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__InCheckedPeccancyInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__InCheckedPeccancyInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__InCheckedPeccancyInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__InCheckedPeccancyInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__InBlacklistInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__InBlacklistInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__InBlacklistInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__InBlacklistInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__InBlacklistInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__InBlacklistInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__InChecklessInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__InChecklessInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__InChecklessInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__InChecklessInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__InChecklessInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__InChecklessInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__IntExtralistInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__IntExtralistInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__IntExtralistInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__IntExtralistInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__IntExtralistInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__IntExtralistInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__InSuspicionInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__InSuspicionInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__InSuspicionInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__InSuspicionInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__InSuspicionInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__InSuspicionInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__RevokeSuspicionInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__RevokeSuspicionInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__RevokeSuspicionInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__RevokeSuspicionInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__RevokeSuspicionInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__RevokeSuspicionInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetLocationInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetLocationInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetLocationInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetLocationInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetLocationInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetLocationInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPassCarInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPassCarInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPassCarInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPassCarInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPassCarInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPassCarInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPeccancyInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPeccancyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPeccancyInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPeccancyInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPeccancyInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPeccancyInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPeccancyNoCheckInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPeccancyNoCheckInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPeccancyNoCheckInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetPeccancyNoCheckInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetPeccancyNoCheckInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetPeccancyNoCheckInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UpdatePeccancyInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UpdatePeccancyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UpdatePeccancyInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UpdatePeccancyInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UpdatePeccancyInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UpdatePeccancyInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetVioPeccancyNoCheckInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetVioPeccancyNoCheckInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetVioPeccancyNoCheckInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetVioPeccancyNoCheckInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UpdateVioPeccancyInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UpdateVioPeccancyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UpdateVioPeccancyInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UpdateVioPeccancyInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UpdateVioPeccancyInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UpdateVioPeccancyInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetAlarmInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetAlarmInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetAlarmInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetAlarmInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetAlarmInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetAlarmInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UpdataDeviceState:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UpdataDeviceState*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UpdataDeviceState*)p->ptr);
		break;
	case SOAP_TYPE__ns1__UpdataDeviceStateResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__UpdataDeviceStateResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__UpdataDeviceStateResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__InViolationInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__InViolationInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__InViolationInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__InViolationInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__InViolationInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__InViolationInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetViolationInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetViolationInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetViolationInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetViolationInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetViolationInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetViolationInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetJdsbhRecovery:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetJdsbhRecovery*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetJdsbhRecovery*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetJdsbhRecoveryResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetJdsbhRecoveryResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetJdsbhRecoveryResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetJdsbhRecoveryInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetJdsbhRecoveryInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetJdsbhRecoveryInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__GetJdsbhRecoveryInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__GetJdsbhRecoveryInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__GetJdsbhRecoveryInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__addTransRecInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__addTransRecInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__addTransRecInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__addTransRecInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__addTransRecInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__addTransRecInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE__ns1__CheckUserInfo:
		if (p->size < 0)
			SOAP_DELETE((_ns1__CheckUserInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__CheckUserInfo*)p->ptr);
		break;
	case SOAP_TYPE__ns1__CheckUserInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_ns1__CheckUserInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_ns1__CheckUserInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE___ns1__WebserviceTest:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__WebserviceTest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__WebserviceTest*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetCurrentVersion:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetCurrentVersion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetCurrentVersion*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetXMlFormat:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetXMlFormat*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetXMlFormat*)p->ptr);
		break;
	case SOAP_TYPE___ns1__CarPlateRecog:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__CarPlateRecog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__CarPlateRecog*)p->ptr);
		break;
	case SOAP_TYPE___ns1__InPassCarInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__InPassCarInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__InPassCarInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__InPeccancyInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__InPeccancyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__InPeccancyInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__InCheckedPeccancyInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__InCheckedPeccancyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__InCheckedPeccancyInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__InBlacklistInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__InBlacklistInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__InBlacklistInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__InChecklessInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__InChecklessInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__InChecklessInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__IntExtralistInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__IntExtralistInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__IntExtralistInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__InSuspicionInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__InSuspicionInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__InSuspicionInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__RevokeSuspicionInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__RevokeSuspicionInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__RevokeSuspicionInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetLocationInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetLocationInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetLocationInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetPassCarInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetPassCarInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetPassCarInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetPeccancyInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetPeccancyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetPeccancyInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetPeccancyNoCheckInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetPeccancyNoCheckInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetPeccancyNoCheckInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__UpdatePeccancyInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__UpdatePeccancyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__UpdatePeccancyInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetVioPeccancyNoCheckInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetVioPeccancyNoCheckInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetVioPeccancyNoCheckInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__UpdateVioPeccancyInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__UpdateVioPeccancyInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__UpdateVioPeccancyInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetAlarmInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetAlarmInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetAlarmInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__UpdataDeviceState:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__UpdataDeviceState*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__UpdataDeviceState*)p->ptr);
		break;
	case SOAP_TYPE___ns1__InViolationInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__InViolationInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__InViolationInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetViolationInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetViolationInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetViolationInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetJdsbhRecovery:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetJdsbhRecovery*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetJdsbhRecovery*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetJdsbhRecoveryInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetJdsbhRecoveryInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetJdsbhRecoveryInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__addTransRecInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__addTransRecInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__addTransRecInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__CheckUserInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__CheckUserInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__CheckUserInfo*)p->ptr);
		break;
	case SOAP_TYPE___ns1__WebserviceTest_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__WebserviceTest_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__WebserviceTest_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetCurrentVersion_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetCurrentVersion_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetCurrentVersion_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetXMlFormat_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetXMlFormat_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetXMlFormat_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__CarPlateRecog_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__CarPlateRecog_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__CarPlateRecog_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__InPassCarInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__InPassCarInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__InPassCarInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__InPeccancyInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__InPeccancyInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__InPeccancyInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__InCheckedPeccancyInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__InCheckedPeccancyInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__InCheckedPeccancyInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__InBlacklistInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__InBlacklistInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__InBlacklistInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__InChecklessInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__InChecklessInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__InChecklessInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__IntExtralistInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__IntExtralistInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__IntExtralistInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__InSuspicionInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__InSuspicionInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__InSuspicionInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__RevokeSuspicionInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__RevokeSuspicionInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__RevokeSuspicionInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetLocationInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetLocationInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetLocationInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetPassCarInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetPassCarInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetPassCarInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetPeccancyInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetPeccancyInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetPeccancyInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetPeccancyNoCheckInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetPeccancyNoCheckInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetPeccancyNoCheckInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__UpdatePeccancyInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__UpdatePeccancyInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__UpdatePeccancyInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetVioPeccancyNoCheckInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetVioPeccancyNoCheckInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetVioPeccancyNoCheckInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__UpdateVioPeccancyInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__UpdateVioPeccancyInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__UpdateVioPeccancyInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetAlarmInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetAlarmInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetAlarmInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__UpdataDeviceState_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__UpdataDeviceState_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__UpdataDeviceState_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__InViolationInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__InViolationInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__InViolationInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetViolationInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetViolationInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetViolationInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetJdsbhRecovery_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetJdsbhRecovery_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetJdsbhRecovery_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__GetJdsbhRecoveryInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__GetJdsbhRecoveryInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__GetJdsbhRecoveryInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__addTransRecInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__addTransRecInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__addTransRecInfo_*)p->ptr);
		break;
	case SOAP_TYPE___ns1__CheckUserInfo_:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__CheckUserInfo_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__CheckUserInfo_*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CheckUserInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_ns1__CheckUserInfoResponse::CheckUserInfoResult);
	/* transient soap skipped */
}

void _ns1__CheckUserInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns1__CheckUserInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CheckUserInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CheckUserInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__CheckUserInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CheckUserInfoResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:CheckUserInfoResult");
	if (soap_out_bool(soap, "ns1:CheckUserInfoResult", -1, &(a->_ns1__CheckUserInfoResponse::CheckUserInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__CheckUserInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CheckUserInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CheckUserInfoResponse * SOAP_FMAC4 soap_in__ns1__CheckUserInfoResponse(struct soap *soap, const char *tag, _ns1__CheckUserInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CheckUserInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CheckUserInfoResponse, sizeof(_ns1__CheckUserInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__CheckUserInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__CheckUserInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CheckUserInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CheckUserInfoResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "ns1:CheckUserInfoResult", &(a->_ns1__CheckUserInfoResponse::CheckUserInfoResult), "xsd:boolean"))
				{	soap_flag_CheckUserInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:CheckUserInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CheckUserInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CheckUserInfoResponse, 0, sizeof(_ns1__CheckUserInfoResponse), 0, soap_copy__ns1__CheckUserInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CheckUserInfoResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _ns1__CheckUserInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__CheckUserInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:CheckUserInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CheckUserInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CheckUserInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CheckUserInfoResponse * SOAP_FMAC4 soap_get__ns1__CheckUserInfoResponse(struct soap *soap, _ns1__CheckUserInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CheckUserInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__CheckUserInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__CheckUserInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CheckUserInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__CheckUserInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__CheckUserInfoResponse);
		if (size)
			*size = sizeof(_ns1__CheckUserInfoResponse);
		((_ns1__CheckUserInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__CheckUserInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__CheckUserInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__CheckUserInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__CheckUserInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__CheckUserInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__CheckUserInfoResponse %p -> %p\n", q, p));
	*(_ns1__CheckUserInfoResponse*)p = *(_ns1__CheckUserInfoResponse*)q;
}

void _ns1__CheckUserInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__CheckUserInfo::xmlBody);
	/* transient soap skipped */
}

void _ns1__CheckUserInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__CheckUserInfo::xmlBody);
	/* transient soap skipped */
#endif
}

int _ns1__CheckUserInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CheckUserInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CheckUserInfo(struct soap *soap, const char *tag, int id, const _ns1__CheckUserInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CheckUserInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xmlBody", -1, &(a->_ns1__CheckUserInfo::xmlBody), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__CheckUserInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CheckUserInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CheckUserInfo * SOAP_FMAC4 soap_in__ns1__CheckUserInfo(struct soap *soap, const char *tag, _ns1__CheckUserInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CheckUserInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CheckUserInfo, sizeof(_ns1__CheckUserInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__CheckUserInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__CheckUserInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlBody1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlBody1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:xmlBody", &(a->_ns1__CheckUserInfo::xmlBody), "xsd:string"))
				{	soap_flag_xmlBody1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CheckUserInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CheckUserInfo, 0, sizeof(_ns1__CheckUserInfo), 0, soap_copy__ns1__CheckUserInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__CheckUserInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__CheckUserInfo);
	if (this->soap_out(soap, tag?tag:"ns1:CheckUserInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CheckUserInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CheckUserInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CheckUserInfo * SOAP_FMAC4 soap_get__ns1__CheckUserInfo(struct soap *soap, _ns1__CheckUserInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CheckUserInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__CheckUserInfo * SOAP_FMAC2 soap_instantiate__ns1__CheckUserInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CheckUserInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__CheckUserInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__CheckUserInfo);
		if (size)
			*size = sizeof(_ns1__CheckUserInfo);
		((_ns1__CheckUserInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__CheckUserInfo, n);
		if (size)
			*size = n * sizeof(_ns1__CheckUserInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__CheckUserInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__CheckUserInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__CheckUserInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__CheckUserInfo %p -> %p\n", q, p));
	*(_ns1__CheckUserInfo*)p = *(_ns1__CheckUserInfo*)q;
}

void _ns1__addTransRecInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__addTransRecInfoResponse::addTransRecInfoResult);
	/* transient soap skipped */
}

void _ns1__addTransRecInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__addTransRecInfoResponse::addTransRecInfoResult);
	/* transient soap skipped */
#endif
}

int _ns1__addTransRecInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addTransRecInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addTransRecInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__addTransRecInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addTransRecInfoResponse), type))
		return soap->error;
	if (a->addTransRecInfoResult)
		soap_element_result(soap, "ns1:addTransRecInfoResult");
	if (soap_out_string(soap, "ns1:addTransRecInfoResult", -1, &(a->_ns1__addTransRecInfoResponse::addTransRecInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__addTransRecInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addTransRecInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addTransRecInfoResponse * SOAP_FMAC4 soap_in__ns1__addTransRecInfoResponse(struct soap *soap, const char *tag, _ns1__addTransRecInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__addTransRecInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addTransRecInfoResponse, sizeof(_ns1__addTransRecInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__addTransRecInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__addTransRecInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_addTransRecInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_addTransRecInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:addTransRecInfoResult", &(a->_ns1__addTransRecInfoResponse::addTransRecInfoResult), "xsd:string"))
				{	soap_flag_addTransRecInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:addTransRecInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__addTransRecInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addTransRecInfoResponse, 0, sizeof(_ns1__addTransRecInfoResponse), 0, soap_copy__ns1__addTransRecInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__addTransRecInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__addTransRecInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:addTransRecInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__addTransRecInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addTransRecInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addTransRecInfoResponse * SOAP_FMAC4 soap_get__ns1__addTransRecInfoResponse(struct soap *soap, _ns1__addTransRecInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addTransRecInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__addTransRecInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__addTransRecInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addTransRecInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addTransRecInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addTransRecInfoResponse);
		if (size)
			*size = sizeof(_ns1__addTransRecInfoResponse);
		((_ns1__addTransRecInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__addTransRecInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__addTransRecInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__addTransRecInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__addTransRecInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__addTransRecInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__addTransRecInfoResponse %p -> %p\n", q, p));
	*(_ns1__addTransRecInfoResponse*)p = *(_ns1__addTransRecInfoResponse*)q;
}

void _ns1__addTransRecInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__addTransRecInfo::sjly);
	soap_default_string(soap, &this->_ns1__addTransRecInfo::sbcj);
	soap_default_string(soap, &this->_ns1__addTransRecInfo::sbbh);
	soap_default_string(soap, &this->_ns1__addTransRecInfo::cjsj);
	soap_default_string(soap, &this->_ns1__addTransRecInfo::wfxw);
	soap_default_string(soap, &this->_ns1__addTransRecInfo::wfnr);
	soap_default_string(soap, &this->_ns1__addTransRecInfo::zjwjlj);
	soap_default_string(soap, &this->_ns1__addTransRecInfo::bz);
	/* transient soap skipped */
}

void _ns1__addTransRecInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__addTransRecInfo::sjly);
	soap_serialize_string(soap, &this->_ns1__addTransRecInfo::sbcj);
	soap_serialize_string(soap, &this->_ns1__addTransRecInfo::sbbh);
	soap_serialize_string(soap, &this->_ns1__addTransRecInfo::cjsj);
	soap_serialize_string(soap, &this->_ns1__addTransRecInfo::wfxw);
	soap_serialize_string(soap, &this->_ns1__addTransRecInfo::wfnr);
	soap_serialize_string(soap, &this->_ns1__addTransRecInfo::zjwjlj);
	soap_serialize_string(soap, &this->_ns1__addTransRecInfo::bz);
	/* transient soap skipped */
#endif
}

int _ns1__addTransRecInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__addTransRecInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__addTransRecInfo(struct soap *soap, const char *tag, int id, const _ns1__addTransRecInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__addTransRecInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:sjly", -1, &(a->_ns1__addTransRecInfo::sjly), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:sbcj", -1, &(a->_ns1__addTransRecInfo::sbcj), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:sbbh", -1, &(a->_ns1__addTransRecInfo::sbbh), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:cjsj", -1, &(a->_ns1__addTransRecInfo::cjsj), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:wfxw", -1, &(a->_ns1__addTransRecInfo::wfxw), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:wfnr", -1, &(a->_ns1__addTransRecInfo::wfnr), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:zjwjlj", -1, &(a->_ns1__addTransRecInfo::zjwjlj), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:bz", -1, &(a->_ns1__addTransRecInfo::bz), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__addTransRecInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__addTransRecInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__addTransRecInfo * SOAP_FMAC4 soap_in__ns1__addTransRecInfo(struct soap *soap, const char *tag, _ns1__addTransRecInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__addTransRecInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__addTransRecInfo, sizeof(_ns1__addTransRecInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__addTransRecInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__addTransRecInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sjly1 = 1;
	size_t soap_flag_sbcj1 = 1;
	size_t soap_flag_sbbh1 = 1;
	size_t soap_flag_cjsj1 = 1;
	size_t soap_flag_wfxw1 = 1;
	size_t soap_flag_wfnr1 = 1;
	size_t soap_flag_zjwjlj1 = 1;
	size_t soap_flag_bz1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sjly1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sjly", &(a->_ns1__addTransRecInfo::sjly), "xsd:string"))
				{	soap_flag_sjly1--;
					continue;
				}
			if (soap_flag_sbcj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sbcj", &(a->_ns1__addTransRecInfo::sbcj), "xsd:string"))
				{	soap_flag_sbcj1--;
					continue;
				}
			if (soap_flag_sbbh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:sbbh", &(a->_ns1__addTransRecInfo::sbbh), "xsd:string"))
				{	soap_flag_sbbh1--;
					continue;
				}
			if (soap_flag_cjsj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:cjsj", &(a->_ns1__addTransRecInfo::cjsj), "xsd:string"))
				{	soap_flag_cjsj1--;
					continue;
				}
			if (soap_flag_wfxw1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:wfxw", &(a->_ns1__addTransRecInfo::wfxw), "xsd:string"))
				{	soap_flag_wfxw1--;
					continue;
				}
			if (soap_flag_wfnr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:wfnr", &(a->_ns1__addTransRecInfo::wfnr), "xsd:string"))
				{	soap_flag_wfnr1--;
					continue;
				}
			if (soap_flag_zjwjlj1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:zjwjlj", &(a->_ns1__addTransRecInfo::zjwjlj), "xsd:string"))
				{	soap_flag_zjwjlj1--;
					continue;
				}
			if (soap_flag_bz1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:bz", &(a->_ns1__addTransRecInfo::bz), "xsd:string"))
				{	soap_flag_bz1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__addTransRecInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__addTransRecInfo, 0, sizeof(_ns1__addTransRecInfo), 0, soap_copy__ns1__addTransRecInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__addTransRecInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__addTransRecInfo);
	if (this->soap_out(soap, tag?tag:"ns1:addTransRecInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__addTransRecInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__addTransRecInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__addTransRecInfo * SOAP_FMAC4 soap_get__ns1__addTransRecInfo(struct soap *soap, _ns1__addTransRecInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__addTransRecInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__addTransRecInfo * SOAP_FMAC2 soap_instantiate__ns1__addTransRecInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__addTransRecInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__addTransRecInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__addTransRecInfo);
		if (size)
			*size = sizeof(_ns1__addTransRecInfo);
		((_ns1__addTransRecInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__addTransRecInfo, n);
		if (size)
			*size = n * sizeof(_ns1__addTransRecInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__addTransRecInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__addTransRecInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__addTransRecInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__addTransRecInfo %p -> %p\n", q, p));
	*(_ns1__addTransRecInfo*)p = *(_ns1__addTransRecInfo*)q;
}

void _ns1__GetJdsbhRecoveryInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetJdsbhRecoveryInfoResponse::GetJdsbhRecoveryInfoResult);
	/* transient soap skipped */
}

void _ns1__GetJdsbhRecoveryInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetJdsbhRecoveryInfoResponse::GetJdsbhRecoveryInfoResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetJdsbhRecoveryInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetJdsbhRecoveryInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetJdsbhRecoveryInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetJdsbhRecoveryInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetJdsbhRecoveryInfoResponse), type))
		return soap->error;
	if (a->GetJdsbhRecoveryInfoResult)
		soap_element_result(soap, "ns1:GetJdsbhRecoveryInfoResult");
	if (soap_out_string(soap, "ns1:GetJdsbhRecoveryInfoResult", -1, &(a->_ns1__GetJdsbhRecoveryInfoResponse::GetJdsbhRecoveryInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetJdsbhRecoveryInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetJdsbhRecoveryInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetJdsbhRecoveryInfoResponse * SOAP_FMAC4 soap_in__ns1__GetJdsbhRecoveryInfoResponse(struct soap *soap, const char *tag, _ns1__GetJdsbhRecoveryInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetJdsbhRecoveryInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetJdsbhRecoveryInfoResponse, sizeof(_ns1__GetJdsbhRecoveryInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetJdsbhRecoveryInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetJdsbhRecoveryInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetJdsbhRecoveryInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetJdsbhRecoveryInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:GetJdsbhRecoveryInfoResult", &(a->_ns1__GetJdsbhRecoveryInfoResponse::GetJdsbhRecoveryInfoResult), "xsd:string"))
				{	soap_flag_GetJdsbhRecoveryInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetJdsbhRecoveryInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetJdsbhRecoveryInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetJdsbhRecoveryInfoResponse, 0, sizeof(_ns1__GetJdsbhRecoveryInfoResponse), 0, soap_copy__ns1__GetJdsbhRecoveryInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetJdsbhRecoveryInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetJdsbhRecoveryInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetJdsbhRecoveryInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetJdsbhRecoveryInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetJdsbhRecoveryInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetJdsbhRecoveryInfoResponse * SOAP_FMAC4 soap_get__ns1__GetJdsbhRecoveryInfoResponse(struct soap *soap, _ns1__GetJdsbhRecoveryInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetJdsbhRecoveryInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetJdsbhRecoveryInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__GetJdsbhRecoveryInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetJdsbhRecoveryInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetJdsbhRecoveryInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetJdsbhRecoveryInfoResponse);
		if (size)
			*size = sizeof(_ns1__GetJdsbhRecoveryInfoResponse);
		((_ns1__GetJdsbhRecoveryInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetJdsbhRecoveryInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetJdsbhRecoveryInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetJdsbhRecoveryInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetJdsbhRecoveryInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetJdsbhRecoveryInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetJdsbhRecoveryInfoResponse %p -> %p\n", q, p));
	*(_ns1__GetJdsbhRecoveryInfoResponse*)p = *(_ns1__GetJdsbhRecoveryInfoResponse*)q;
}

void _ns1__GetJdsbhRecoveryInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetJdsbhRecoveryInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns1__GetJdsbhRecoveryInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetJdsbhRecoveryInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetJdsbhRecoveryInfo(struct soap *soap, const char *tag, int id, const _ns1__GetJdsbhRecoveryInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetJdsbhRecoveryInfo), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetJdsbhRecoveryInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetJdsbhRecoveryInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetJdsbhRecoveryInfo * SOAP_FMAC4 soap_in__ns1__GetJdsbhRecoveryInfo(struct soap *soap, const char *tag, _ns1__GetJdsbhRecoveryInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetJdsbhRecoveryInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetJdsbhRecoveryInfo, sizeof(_ns1__GetJdsbhRecoveryInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetJdsbhRecoveryInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetJdsbhRecoveryInfo *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetJdsbhRecoveryInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetJdsbhRecoveryInfo, 0, sizeof(_ns1__GetJdsbhRecoveryInfo), 0, soap_copy__ns1__GetJdsbhRecoveryInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetJdsbhRecoveryInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetJdsbhRecoveryInfo);
	if (this->soap_out(soap, tag?tag:"ns1:GetJdsbhRecoveryInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetJdsbhRecoveryInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetJdsbhRecoveryInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetJdsbhRecoveryInfo * SOAP_FMAC4 soap_get__ns1__GetJdsbhRecoveryInfo(struct soap *soap, _ns1__GetJdsbhRecoveryInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetJdsbhRecoveryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetJdsbhRecoveryInfo * SOAP_FMAC2 soap_instantiate__ns1__GetJdsbhRecoveryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetJdsbhRecoveryInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetJdsbhRecoveryInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetJdsbhRecoveryInfo);
		if (size)
			*size = sizeof(_ns1__GetJdsbhRecoveryInfo);
		((_ns1__GetJdsbhRecoveryInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetJdsbhRecoveryInfo, n);
		if (size)
			*size = n * sizeof(_ns1__GetJdsbhRecoveryInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetJdsbhRecoveryInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetJdsbhRecoveryInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetJdsbhRecoveryInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetJdsbhRecoveryInfo %p -> %p\n", q, p));
	*(_ns1__GetJdsbhRecoveryInfo*)p = *(_ns1__GetJdsbhRecoveryInfo*)q;
}

void _ns1__GetJdsbhRecoveryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetJdsbhRecoveryResponse::GetJdsbhRecoveryResult);
	/* transient soap skipped */
}

void _ns1__GetJdsbhRecoveryResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetJdsbhRecoveryResponse::GetJdsbhRecoveryResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetJdsbhRecoveryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetJdsbhRecoveryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetJdsbhRecoveryResponse(struct soap *soap, const char *tag, int id, const _ns1__GetJdsbhRecoveryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetJdsbhRecoveryResponse), type))
		return soap->error;
	if (a->GetJdsbhRecoveryResult)
		soap_element_result(soap, "ns1:GetJdsbhRecoveryResult");
	if (soap_out_string(soap, "ns1:GetJdsbhRecoveryResult", -1, &(a->_ns1__GetJdsbhRecoveryResponse::GetJdsbhRecoveryResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetJdsbhRecoveryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetJdsbhRecoveryResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetJdsbhRecoveryResponse * SOAP_FMAC4 soap_in__ns1__GetJdsbhRecoveryResponse(struct soap *soap, const char *tag, _ns1__GetJdsbhRecoveryResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetJdsbhRecoveryResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetJdsbhRecoveryResponse, sizeof(_ns1__GetJdsbhRecoveryResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetJdsbhRecoveryResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetJdsbhRecoveryResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetJdsbhRecoveryResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetJdsbhRecoveryResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:GetJdsbhRecoveryResult", &(a->_ns1__GetJdsbhRecoveryResponse::GetJdsbhRecoveryResult), "xsd:string"))
				{	soap_flag_GetJdsbhRecoveryResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetJdsbhRecoveryResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetJdsbhRecoveryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetJdsbhRecoveryResponse, 0, sizeof(_ns1__GetJdsbhRecoveryResponse), 0, soap_copy__ns1__GetJdsbhRecoveryResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetJdsbhRecoveryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetJdsbhRecoveryResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetJdsbhRecoveryResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetJdsbhRecoveryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetJdsbhRecoveryResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetJdsbhRecoveryResponse * SOAP_FMAC4 soap_get__ns1__GetJdsbhRecoveryResponse(struct soap *soap, _ns1__GetJdsbhRecoveryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetJdsbhRecoveryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetJdsbhRecoveryResponse * SOAP_FMAC2 soap_instantiate__ns1__GetJdsbhRecoveryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetJdsbhRecoveryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetJdsbhRecoveryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetJdsbhRecoveryResponse);
		if (size)
			*size = sizeof(_ns1__GetJdsbhRecoveryResponse);
		((_ns1__GetJdsbhRecoveryResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetJdsbhRecoveryResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetJdsbhRecoveryResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetJdsbhRecoveryResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetJdsbhRecoveryResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetJdsbhRecoveryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetJdsbhRecoveryResponse %p -> %p\n", q, p));
	*(_ns1__GetJdsbhRecoveryResponse*)p = *(_ns1__GetJdsbhRecoveryResponse*)q;
}

void _ns1__GetJdsbhRecovery::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetJdsbhRecovery::xmlBody);
	/* transient soap skipped */
}

void _ns1__GetJdsbhRecovery::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetJdsbhRecovery::xmlBody);
	/* transient soap skipped */
#endif
}

int _ns1__GetJdsbhRecovery::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetJdsbhRecovery(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetJdsbhRecovery(struct soap *soap, const char *tag, int id, const _ns1__GetJdsbhRecovery *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetJdsbhRecovery), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xmlBody", -1, &(a->_ns1__GetJdsbhRecovery::xmlBody), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetJdsbhRecovery::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetJdsbhRecovery(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetJdsbhRecovery * SOAP_FMAC4 soap_in__ns1__GetJdsbhRecovery(struct soap *soap, const char *tag, _ns1__GetJdsbhRecovery *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetJdsbhRecovery *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetJdsbhRecovery, sizeof(_ns1__GetJdsbhRecovery), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetJdsbhRecovery)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetJdsbhRecovery *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlBody1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlBody1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:xmlBody", &(a->_ns1__GetJdsbhRecovery::xmlBody), "xsd:string"))
				{	soap_flag_xmlBody1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetJdsbhRecovery *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetJdsbhRecovery, 0, sizeof(_ns1__GetJdsbhRecovery), 0, soap_copy__ns1__GetJdsbhRecovery);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetJdsbhRecovery::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetJdsbhRecovery);
	if (this->soap_out(soap, tag?tag:"ns1:GetJdsbhRecovery", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetJdsbhRecovery::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetJdsbhRecovery(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetJdsbhRecovery * SOAP_FMAC4 soap_get__ns1__GetJdsbhRecovery(struct soap *soap, _ns1__GetJdsbhRecovery *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetJdsbhRecovery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetJdsbhRecovery * SOAP_FMAC2 soap_instantiate__ns1__GetJdsbhRecovery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetJdsbhRecovery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetJdsbhRecovery, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetJdsbhRecovery);
		if (size)
			*size = sizeof(_ns1__GetJdsbhRecovery);
		((_ns1__GetJdsbhRecovery*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetJdsbhRecovery, n);
		if (size)
			*size = n * sizeof(_ns1__GetJdsbhRecovery);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetJdsbhRecovery*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetJdsbhRecovery*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetJdsbhRecovery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetJdsbhRecovery %p -> %p\n", q, p));
	*(_ns1__GetJdsbhRecovery*)p = *(_ns1__GetJdsbhRecovery*)q;
}

void _ns1__GetViolationInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetViolationInfoResponse::GetViolationInfoResult);
	/* transient soap skipped */
}

void _ns1__GetViolationInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetViolationInfoResponse::GetViolationInfoResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetViolationInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetViolationInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetViolationInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetViolationInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetViolationInfoResponse), type))
		return soap->error;
	if (a->GetViolationInfoResult)
		soap_element_result(soap, "ns1:GetViolationInfoResult");
	if (soap_out_string(soap, "ns1:GetViolationInfoResult", -1, &(a->_ns1__GetViolationInfoResponse::GetViolationInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetViolationInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetViolationInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetViolationInfoResponse * SOAP_FMAC4 soap_in__ns1__GetViolationInfoResponse(struct soap *soap, const char *tag, _ns1__GetViolationInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetViolationInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetViolationInfoResponse, sizeof(_ns1__GetViolationInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetViolationInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetViolationInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetViolationInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetViolationInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:GetViolationInfoResult", &(a->_ns1__GetViolationInfoResponse::GetViolationInfoResult), "xsd:string"))
				{	soap_flag_GetViolationInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetViolationInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetViolationInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetViolationInfoResponse, 0, sizeof(_ns1__GetViolationInfoResponse), 0, soap_copy__ns1__GetViolationInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetViolationInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetViolationInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetViolationInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetViolationInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetViolationInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetViolationInfoResponse * SOAP_FMAC4 soap_get__ns1__GetViolationInfoResponse(struct soap *soap, _ns1__GetViolationInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetViolationInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetViolationInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__GetViolationInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetViolationInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetViolationInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetViolationInfoResponse);
		if (size)
			*size = sizeof(_ns1__GetViolationInfoResponse);
		((_ns1__GetViolationInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetViolationInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetViolationInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetViolationInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetViolationInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetViolationInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetViolationInfoResponse %p -> %p\n", q, p));
	*(_ns1__GetViolationInfoResponse*)p = *(_ns1__GetViolationInfoResponse*)q;
}

void _ns1__GetViolationInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetViolationInfo::xmlBody);
	/* transient soap skipped */
}

void _ns1__GetViolationInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetViolationInfo::xmlBody);
	/* transient soap skipped */
#endif
}

int _ns1__GetViolationInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetViolationInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetViolationInfo(struct soap *soap, const char *tag, int id, const _ns1__GetViolationInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetViolationInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xmlBody", -1, &(a->_ns1__GetViolationInfo::xmlBody), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetViolationInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetViolationInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetViolationInfo * SOAP_FMAC4 soap_in__ns1__GetViolationInfo(struct soap *soap, const char *tag, _ns1__GetViolationInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetViolationInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetViolationInfo, sizeof(_ns1__GetViolationInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetViolationInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetViolationInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlBody1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlBody1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:xmlBody", &(a->_ns1__GetViolationInfo::xmlBody), "xsd:string"))
				{	soap_flag_xmlBody1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetViolationInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetViolationInfo, 0, sizeof(_ns1__GetViolationInfo), 0, soap_copy__ns1__GetViolationInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetViolationInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetViolationInfo);
	if (this->soap_out(soap, tag?tag:"ns1:GetViolationInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetViolationInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetViolationInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetViolationInfo * SOAP_FMAC4 soap_get__ns1__GetViolationInfo(struct soap *soap, _ns1__GetViolationInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetViolationInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetViolationInfo * SOAP_FMAC2 soap_instantiate__ns1__GetViolationInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetViolationInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetViolationInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetViolationInfo);
		if (size)
			*size = sizeof(_ns1__GetViolationInfo);
		((_ns1__GetViolationInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetViolationInfo, n);
		if (size)
			*size = n * sizeof(_ns1__GetViolationInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetViolationInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetViolationInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetViolationInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetViolationInfo %p -> %p\n", q, p));
	*(_ns1__GetViolationInfo*)p = *(_ns1__GetViolationInfo*)q;
}

void _ns1__InViolationInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__InViolationInfoResponse::InViolationInfoResult);
	/* transient soap skipped */
}

void _ns1__InViolationInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__InViolationInfoResponse::InViolationInfoResult);
	/* transient soap skipped */
#endif
}

int _ns1__InViolationInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InViolationInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InViolationInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__InViolationInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InViolationInfoResponse), type))
		return soap->error;
	if (a->InViolationInfoResult)
		soap_element_result(soap, "ns1:InViolationInfoResult");
	if (soap_out_string(soap, "ns1:InViolationInfoResult", -1, &(a->_ns1__InViolationInfoResponse::InViolationInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__InViolationInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InViolationInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InViolationInfoResponse * SOAP_FMAC4 soap_in__ns1__InViolationInfoResponse(struct soap *soap, const char *tag, _ns1__InViolationInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InViolationInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InViolationInfoResponse, sizeof(_ns1__InViolationInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__InViolationInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__InViolationInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_InViolationInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InViolationInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:InViolationInfoResult", &(a->_ns1__InViolationInfoResponse::InViolationInfoResult), "xsd:string"))
				{	soap_flag_InViolationInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:InViolationInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InViolationInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InViolationInfoResponse, 0, sizeof(_ns1__InViolationInfoResponse), 0, soap_copy__ns1__InViolationInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__InViolationInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__InViolationInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:InViolationInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InViolationInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InViolationInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InViolationInfoResponse * SOAP_FMAC4 soap_get__ns1__InViolationInfoResponse(struct soap *soap, _ns1__InViolationInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InViolationInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__InViolationInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__InViolationInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InViolationInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__InViolationInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__InViolationInfoResponse);
		if (size)
			*size = sizeof(_ns1__InViolationInfoResponse);
		((_ns1__InViolationInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__InViolationInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__InViolationInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__InViolationInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__InViolationInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__InViolationInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__InViolationInfoResponse %p -> %p\n", q, p));
	*(_ns1__InViolationInfoResponse*)p = *(_ns1__InViolationInfoResponse*)q;
}

void _ns1__InViolationInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__InViolationInfo::xmlBody);
	/* transient soap skipped */
}

void _ns1__InViolationInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__InViolationInfo::xmlBody);
	/* transient soap skipped */
#endif
}

int _ns1__InViolationInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InViolationInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InViolationInfo(struct soap *soap, const char *tag, int id, const _ns1__InViolationInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InViolationInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xmlBody", -1, &(a->_ns1__InViolationInfo::xmlBody), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__InViolationInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InViolationInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InViolationInfo * SOAP_FMAC4 soap_in__ns1__InViolationInfo(struct soap *soap, const char *tag, _ns1__InViolationInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InViolationInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InViolationInfo, sizeof(_ns1__InViolationInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__InViolationInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__InViolationInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlBody1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlBody1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:xmlBody", &(a->_ns1__InViolationInfo::xmlBody), "xsd:string"))
				{	soap_flag_xmlBody1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InViolationInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InViolationInfo, 0, sizeof(_ns1__InViolationInfo), 0, soap_copy__ns1__InViolationInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__InViolationInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__InViolationInfo);
	if (this->soap_out(soap, tag?tag:"ns1:InViolationInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InViolationInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InViolationInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InViolationInfo * SOAP_FMAC4 soap_get__ns1__InViolationInfo(struct soap *soap, _ns1__InViolationInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InViolationInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__InViolationInfo * SOAP_FMAC2 soap_instantiate__ns1__InViolationInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InViolationInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__InViolationInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__InViolationInfo);
		if (size)
			*size = sizeof(_ns1__InViolationInfo);
		((_ns1__InViolationInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__InViolationInfo, n);
		if (size)
			*size = n * sizeof(_ns1__InViolationInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__InViolationInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__InViolationInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__InViolationInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__InViolationInfo %p -> %p\n", q, p));
	*(_ns1__InViolationInfo*)p = *(_ns1__InViolationInfo*)q;
}

void _ns1__UpdataDeviceStateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdataDeviceStateResponse::UpdataDeviceStateResult);
	/* transient soap skipped */
}

void _ns1__UpdataDeviceStateResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__UpdataDeviceStateResponse::UpdataDeviceStateResult);
	/* transient soap skipped */
#endif
}

int _ns1__UpdataDeviceStateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdataDeviceStateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdataDeviceStateResponse(struct soap *soap, const char *tag, int id, const _ns1__UpdataDeviceStateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdataDeviceStateResponse), type))
		return soap->error;
	if (a->UpdataDeviceStateResult)
		soap_element_result(soap, "ns1:UpdataDeviceStateResult");
	if (soap_out_string(soap, "ns1:UpdataDeviceStateResult", -1, &(a->_ns1__UpdataDeviceStateResponse::UpdataDeviceStateResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdataDeviceStateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdataDeviceStateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdataDeviceStateResponse * SOAP_FMAC4 soap_in__ns1__UpdataDeviceStateResponse(struct soap *soap, const char *tag, _ns1__UpdataDeviceStateResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdataDeviceStateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdataDeviceStateResponse, sizeof(_ns1__UpdataDeviceStateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdataDeviceStateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdataDeviceStateResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UpdataDeviceStateResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdataDeviceStateResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UpdataDeviceStateResult", &(a->_ns1__UpdataDeviceStateResponse::UpdataDeviceStateResult), "xsd:string"))
				{	soap_flag_UpdataDeviceStateResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:UpdataDeviceStateResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdataDeviceStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdataDeviceStateResponse, 0, sizeof(_ns1__UpdataDeviceStateResponse), 0, soap_copy__ns1__UpdataDeviceStateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdataDeviceStateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UpdataDeviceStateResponse);
	if (this->soap_out(soap, tag?tag:"ns1:UpdataDeviceStateResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdataDeviceStateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdataDeviceStateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdataDeviceStateResponse * SOAP_FMAC4 soap_get__ns1__UpdataDeviceStateResponse(struct soap *soap, _ns1__UpdataDeviceStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdataDeviceStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdataDeviceStateResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdataDeviceStateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdataDeviceStateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdataDeviceStateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdataDeviceStateResponse);
		if (size)
			*size = sizeof(_ns1__UpdataDeviceStateResponse);
		((_ns1__UpdataDeviceStateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__UpdataDeviceStateResponse, n);
		if (size)
			*size = n * sizeof(_ns1__UpdataDeviceStateResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__UpdataDeviceStateResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__UpdataDeviceStateResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdataDeviceStateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdataDeviceStateResponse %p -> %p\n", q, p));
	*(_ns1__UpdataDeviceStateResponse*)p = *(_ns1__UpdataDeviceStateResponse*)q;
}

void _ns1__UpdataDeviceState::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdataDeviceState::xmlBody);
	/* transient soap skipped */
}

void _ns1__UpdataDeviceState::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__UpdataDeviceState::xmlBody);
	/* transient soap skipped */
#endif
}

int _ns1__UpdataDeviceState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdataDeviceState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdataDeviceState(struct soap *soap, const char *tag, int id, const _ns1__UpdataDeviceState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdataDeviceState), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xmlBody", -1, &(a->_ns1__UpdataDeviceState::xmlBody), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdataDeviceState::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdataDeviceState(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdataDeviceState * SOAP_FMAC4 soap_in__ns1__UpdataDeviceState(struct soap *soap, const char *tag, _ns1__UpdataDeviceState *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdataDeviceState *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdataDeviceState, sizeof(_ns1__UpdataDeviceState), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdataDeviceState)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdataDeviceState *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlBody1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlBody1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:xmlBody", &(a->_ns1__UpdataDeviceState::xmlBody), "xsd:string"))
				{	soap_flag_xmlBody1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdataDeviceState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdataDeviceState, 0, sizeof(_ns1__UpdataDeviceState), 0, soap_copy__ns1__UpdataDeviceState);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdataDeviceState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UpdataDeviceState);
	if (this->soap_out(soap, tag?tag:"ns1:UpdataDeviceState", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdataDeviceState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdataDeviceState(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdataDeviceState * SOAP_FMAC4 soap_get__ns1__UpdataDeviceState(struct soap *soap, _ns1__UpdataDeviceState *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdataDeviceState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdataDeviceState * SOAP_FMAC2 soap_instantiate__ns1__UpdataDeviceState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdataDeviceState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdataDeviceState, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdataDeviceState);
		if (size)
			*size = sizeof(_ns1__UpdataDeviceState);
		((_ns1__UpdataDeviceState*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__UpdataDeviceState, n);
		if (size)
			*size = n * sizeof(_ns1__UpdataDeviceState);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__UpdataDeviceState*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__UpdataDeviceState*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdataDeviceState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdataDeviceState %p -> %p\n", q, p));
	*(_ns1__UpdataDeviceState*)p = *(_ns1__UpdataDeviceState*)q;
}

void _ns1__GetAlarmInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetAlarmInfoResponse::GetAlarmInfoResult);
	/* transient soap skipped */
}

void _ns1__GetAlarmInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetAlarmInfoResponse::GetAlarmInfoResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetAlarmInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAlarmInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAlarmInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetAlarmInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAlarmInfoResponse), type))
		return soap->error;
	if (a->GetAlarmInfoResult)
		soap_element_result(soap, "ns1:GetAlarmInfoResult");
	if (soap_out_string(soap, "ns1:GetAlarmInfoResult", -1, &(a->_ns1__GetAlarmInfoResponse::GetAlarmInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAlarmInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAlarmInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAlarmInfoResponse * SOAP_FMAC4 soap_in__ns1__GetAlarmInfoResponse(struct soap *soap, const char *tag, _ns1__GetAlarmInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAlarmInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAlarmInfoResponse, sizeof(_ns1__GetAlarmInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetAlarmInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetAlarmInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetAlarmInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetAlarmInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:GetAlarmInfoResult", &(a->_ns1__GetAlarmInfoResponse::GetAlarmInfoResult), "xsd:string"))
				{	soap_flag_GetAlarmInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetAlarmInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAlarmInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAlarmInfoResponse, 0, sizeof(_ns1__GetAlarmInfoResponse), 0, soap_copy__ns1__GetAlarmInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetAlarmInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetAlarmInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetAlarmInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAlarmInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAlarmInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAlarmInfoResponse * SOAP_FMAC4 soap_get__ns1__GetAlarmInfoResponse(struct soap *soap, _ns1__GetAlarmInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAlarmInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetAlarmInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__GetAlarmInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAlarmInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetAlarmInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAlarmInfoResponse);
		if (size)
			*size = sizeof(_ns1__GetAlarmInfoResponse);
		((_ns1__GetAlarmInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetAlarmInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetAlarmInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetAlarmInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetAlarmInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetAlarmInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetAlarmInfoResponse %p -> %p\n", q, p));
	*(_ns1__GetAlarmInfoResponse*)p = *(_ns1__GetAlarmInfoResponse*)q;
}

void _ns1__GetAlarmInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetAlarmInfo::xmlBody);
	/* transient soap skipped */
}

void _ns1__GetAlarmInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetAlarmInfo::xmlBody);
	/* transient soap skipped */
#endif
}

int _ns1__GetAlarmInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAlarmInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAlarmInfo(struct soap *soap, const char *tag, int id, const _ns1__GetAlarmInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAlarmInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xmlBody", -1, &(a->_ns1__GetAlarmInfo::xmlBody), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAlarmInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAlarmInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAlarmInfo * SOAP_FMAC4 soap_in__ns1__GetAlarmInfo(struct soap *soap, const char *tag, _ns1__GetAlarmInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAlarmInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAlarmInfo, sizeof(_ns1__GetAlarmInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetAlarmInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetAlarmInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlBody1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlBody1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:xmlBody", &(a->_ns1__GetAlarmInfo::xmlBody), "xsd:string"))
				{	soap_flag_xmlBody1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAlarmInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAlarmInfo, 0, sizeof(_ns1__GetAlarmInfo), 0, soap_copy__ns1__GetAlarmInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetAlarmInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetAlarmInfo);
	if (this->soap_out(soap, tag?tag:"ns1:GetAlarmInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAlarmInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAlarmInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAlarmInfo * SOAP_FMAC4 soap_get__ns1__GetAlarmInfo(struct soap *soap, _ns1__GetAlarmInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAlarmInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetAlarmInfo * SOAP_FMAC2 soap_instantiate__ns1__GetAlarmInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAlarmInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetAlarmInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetAlarmInfo);
		if (size)
			*size = sizeof(_ns1__GetAlarmInfo);
		((_ns1__GetAlarmInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetAlarmInfo, n);
		if (size)
			*size = n * sizeof(_ns1__GetAlarmInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetAlarmInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetAlarmInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetAlarmInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetAlarmInfo %p -> %p\n", q, p));
	*(_ns1__GetAlarmInfo*)p = *(_ns1__GetAlarmInfo*)q;
}

void _ns1__UpdateVioPeccancyInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdateVioPeccancyInfoResponse::UpdateVioPeccancyInfoResult);
	/* transient soap skipped */
}

void _ns1__UpdateVioPeccancyInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__UpdateVioPeccancyInfoResponse::UpdateVioPeccancyInfoResult);
	/* transient soap skipped */
#endif
}

int _ns1__UpdateVioPeccancyInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateVioPeccancyInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateVioPeccancyInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__UpdateVioPeccancyInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateVioPeccancyInfoResponse), type))
		return soap->error;
	if (a->UpdateVioPeccancyInfoResult)
		soap_element_result(soap, "ns1:UpdateVioPeccancyInfoResult");
	if (soap_out_string(soap, "ns1:UpdateVioPeccancyInfoResult", -1, &(a->_ns1__UpdateVioPeccancyInfoResponse::UpdateVioPeccancyInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateVioPeccancyInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateVioPeccancyInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateVioPeccancyInfoResponse * SOAP_FMAC4 soap_in__ns1__UpdateVioPeccancyInfoResponse(struct soap *soap, const char *tag, _ns1__UpdateVioPeccancyInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateVioPeccancyInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateVioPeccancyInfoResponse, sizeof(_ns1__UpdateVioPeccancyInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdateVioPeccancyInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdateVioPeccancyInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UpdateVioPeccancyInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdateVioPeccancyInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UpdateVioPeccancyInfoResult", &(a->_ns1__UpdateVioPeccancyInfoResponse::UpdateVioPeccancyInfoResult), "xsd:string"))
				{	soap_flag_UpdateVioPeccancyInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:UpdateVioPeccancyInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdateVioPeccancyInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateVioPeccancyInfoResponse, 0, sizeof(_ns1__UpdateVioPeccancyInfoResponse), 0, soap_copy__ns1__UpdateVioPeccancyInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdateVioPeccancyInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UpdateVioPeccancyInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:UpdateVioPeccancyInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateVioPeccancyInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateVioPeccancyInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateVioPeccancyInfoResponse * SOAP_FMAC4 soap_get__ns1__UpdateVioPeccancyInfoResponse(struct soap *soap, _ns1__UpdateVioPeccancyInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateVioPeccancyInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdateVioPeccancyInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdateVioPeccancyInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateVioPeccancyInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdateVioPeccancyInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateVioPeccancyInfoResponse);
		if (size)
			*size = sizeof(_ns1__UpdateVioPeccancyInfoResponse);
		((_ns1__UpdateVioPeccancyInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__UpdateVioPeccancyInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__UpdateVioPeccancyInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__UpdateVioPeccancyInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__UpdateVioPeccancyInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdateVioPeccancyInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdateVioPeccancyInfoResponse %p -> %p\n", q, p));
	*(_ns1__UpdateVioPeccancyInfoResponse*)p = *(_ns1__UpdateVioPeccancyInfoResponse*)q;
}

void _ns1__UpdateVioPeccancyInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdateVioPeccancyInfo::xmlBody);
	/* transient soap skipped */
}

void _ns1__UpdateVioPeccancyInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__UpdateVioPeccancyInfo::xmlBody);
	/* transient soap skipped */
#endif
}

int _ns1__UpdateVioPeccancyInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdateVioPeccancyInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdateVioPeccancyInfo(struct soap *soap, const char *tag, int id, const _ns1__UpdateVioPeccancyInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdateVioPeccancyInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xmlBody", -1, &(a->_ns1__UpdateVioPeccancyInfo::xmlBody), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdateVioPeccancyInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdateVioPeccancyInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdateVioPeccancyInfo * SOAP_FMAC4 soap_in__ns1__UpdateVioPeccancyInfo(struct soap *soap, const char *tag, _ns1__UpdateVioPeccancyInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdateVioPeccancyInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdateVioPeccancyInfo, sizeof(_ns1__UpdateVioPeccancyInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdateVioPeccancyInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdateVioPeccancyInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlBody1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlBody1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:xmlBody", &(a->_ns1__UpdateVioPeccancyInfo::xmlBody), "xsd:string"))
				{	soap_flag_xmlBody1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdateVioPeccancyInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdateVioPeccancyInfo, 0, sizeof(_ns1__UpdateVioPeccancyInfo), 0, soap_copy__ns1__UpdateVioPeccancyInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdateVioPeccancyInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UpdateVioPeccancyInfo);
	if (this->soap_out(soap, tag?tag:"ns1:UpdateVioPeccancyInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdateVioPeccancyInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdateVioPeccancyInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdateVioPeccancyInfo * SOAP_FMAC4 soap_get__ns1__UpdateVioPeccancyInfo(struct soap *soap, _ns1__UpdateVioPeccancyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdateVioPeccancyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdateVioPeccancyInfo * SOAP_FMAC2 soap_instantiate__ns1__UpdateVioPeccancyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdateVioPeccancyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdateVioPeccancyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdateVioPeccancyInfo);
		if (size)
			*size = sizeof(_ns1__UpdateVioPeccancyInfo);
		((_ns1__UpdateVioPeccancyInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__UpdateVioPeccancyInfo, n);
		if (size)
			*size = n * sizeof(_ns1__UpdateVioPeccancyInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__UpdateVioPeccancyInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__UpdateVioPeccancyInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdateVioPeccancyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdateVioPeccancyInfo %p -> %p\n", q, p));
	*(_ns1__UpdateVioPeccancyInfo*)p = *(_ns1__UpdateVioPeccancyInfo*)q;
}

void _ns1__GetVioPeccancyNoCheckInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetVioPeccancyNoCheckInfoResponse::GetVioPeccancyNoCheckInfoResult);
	/* transient soap skipped */
}

void _ns1__GetVioPeccancyNoCheckInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetVioPeccancyNoCheckInfoResponse::GetVioPeccancyNoCheckInfoResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetVioPeccancyNoCheckInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetVioPeccancyNoCheckInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetVioPeccancyNoCheckInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetVioPeccancyNoCheckInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfoResponse), type))
		return soap->error;
	if (a->GetVioPeccancyNoCheckInfoResult)
		soap_element_result(soap, "ns1:GetVioPeccancyNoCheckInfoResult");
	if (soap_out_string(soap, "ns1:GetVioPeccancyNoCheckInfoResult", -1, &(a->_ns1__GetVioPeccancyNoCheckInfoResponse::GetVioPeccancyNoCheckInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetVioPeccancyNoCheckInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetVioPeccancyNoCheckInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetVioPeccancyNoCheckInfoResponse * SOAP_FMAC4 soap_in__ns1__GetVioPeccancyNoCheckInfoResponse(struct soap *soap, const char *tag, _ns1__GetVioPeccancyNoCheckInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetVioPeccancyNoCheckInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfoResponse, sizeof(_ns1__GetVioPeccancyNoCheckInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetVioPeccancyNoCheckInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetVioPeccancyNoCheckInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetVioPeccancyNoCheckInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:GetVioPeccancyNoCheckInfoResult", &(a->_ns1__GetVioPeccancyNoCheckInfoResponse::GetVioPeccancyNoCheckInfoResult), "xsd:string"))
				{	soap_flag_GetVioPeccancyNoCheckInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetVioPeccancyNoCheckInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetVioPeccancyNoCheckInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfoResponse, 0, sizeof(_ns1__GetVioPeccancyNoCheckInfoResponse), 0, soap_copy__ns1__GetVioPeccancyNoCheckInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetVioPeccancyNoCheckInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetVioPeccancyNoCheckInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetVioPeccancyNoCheckInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetVioPeccancyNoCheckInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetVioPeccancyNoCheckInfoResponse * SOAP_FMAC4 soap_get__ns1__GetVioPeccancyNoCheckInfoResponse(struct soap *soap, _ns1__GetVioPeccancyNoCheckInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetVioPeccancyNoCheckInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetVioPeccancyNoCheckInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__GetVioPeccancyNoCheckInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetVioPeccancyNoCheckInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetVioPeccancyNoCheckInfoResponse);
		if (size)
			*size = sizeof(_ns1__GetVioPeccancyNoCheckInfoResponse);
		((_ns1__GetVioPeccancyNoCheckInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetVioPeccancyNoCheckInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetVioPeccancyNoCheckInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetVioPeccancyNoCheckInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetVioPeccancyNoCheckInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetVioPeccancyNoCheckInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetVioPeccancyNoCheckInfoResponse %p -> %p\n", q, p));
	*(_ns1__GetVioPeccancyNoCheckInfoResponse*)p = *(_ns1__GetVioPeccancyNoCheckInfoResponse*)q;
}

void _ns1__GetVioPeccancyNoCheckInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetVioPeccancyNoCheckInfo::xmlBody);
	/* transient soap skipped */
}

void _ns1__GetVioPeccancyNoCheckInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetVioPeccancyNoCheckInfo::xmlBody);
	/* transient soap skipped */
#endif
}

int _ns1__GetVioPeccancyNoCheckInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetVioPeccancyNoCheckInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetVioPeccancyNoCheckInfo(struct soap *soap, const char *tag, int id, const _ns1__GetVioPeccancyNoCheckInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xmlBody", -1, &(a->_ns1__GetVioPeccancyNoCheckInfo::xmlBody), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetVioPeccancyNoCheckInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetVioPeccancyNoCheckInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetVioPeccancyNoCheckInfo * SOAP_FMAC4 soap_in__ns1__GetVioPeccancyNoCheckInfo(struct soap *soap, const char *tag, _ns1__GetVioPeccancyNoCheckInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetVioPeccancyNoCheckInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfo, sizeof(_ns1__GetVioPeccancyNoCheckInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetVioPeccancyNoCheckInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlBody1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlBody1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:xmlBody", &(a->_ns1__GetVioPeccancyNoCheckInfo::xmlBody), "xsd:string"))
				{	soap_flag_xmlBody1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetVioPeccancyNoCheckInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfo, 0, sizeof(_ns1__GetVioPeccancyNoCheckInfo), 0, soap_copy__ns1__GetVioPeccancyNoCheckInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetVioPeccancyNoCheckInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfo);
	if (this->soap_out(soap, tag?tag:"ns1:GetVioPeccancyNoCheckInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetVioPeccancyNoCheckInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetVioPeccancyNoCheckInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetVioPeccancyNoCheckInfo * SOAP_FMAC4 soap_get__ns1__GetVioPeccancyNoCheckInfo(struct soap *soap, _ns1__GetVioPeccancyNoCheckInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetVioPeccancyNoCheckInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetVioPeccancyNoCheckInfo * SOAP_FMAC2 soap_instantiate__ns1__GetVioPeccancyNoCheckInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetVioPeccancyNoCheckInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetVioPeccancyNoCheckInfo);
		if (size)
			*size = sizeof(_ns1__GetVioPeccancyNoCheckInfo);
		((_ns1__GetVioPeccancyNoCheckInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetVioPeccancyNoCheckInfo, n);
		if (size)
			*size = n * sizeof(_ns1__GetVioPeccancyNoCheckInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetVioPeccancyNoCheckInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetVioPeccancyNoCheckInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetVioPeccancyNoCheckInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetVioPeccancyNoCheckInfo %p -> %p\n", q, p));
	*(_ns1__GetVioPeccancyNoCheckInfo*)p = *(_ns1__GetVioPeccancyNoCheckInfo*)q;
}

void _ns1__UpdatePeccancyInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdatePeccancyInfoResponse::UpdatePeccancyInfoResult);
	/* transient soap skipped */
}

void _ns1__UpdatePeccancyInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__UpdatePeccancyInfoResponse::UpdatePeccancyInfoResult);
	/* transient soap skipped */
#endif
}

int _ns1__UpdatePeccancyInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdatePeccancyInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdatePeccancyInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__UpdatePeccancyInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdatePeccancyInfoResponse), type))
		return soap->error;
	if (a->UpdatePeccancyInfoResult)
		soap_element_result(soap, "ns1:UpdatePeccancyInfoResult");
	if (soap_out_string(soap, "ns1:UpdatePeccancyInfoResult", -1, &(a->_ns1__UpdatePeccancyInfoResponse::UpdatePeccancyInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdatePeccancyInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdatePeccancyInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdatePeccancyInfoResponse * SOAP_FMAC4 soap_in__ns1__UpdatePeccancyInfoResponse(struct soap *soap, const char *tag, _ns1__UpdatePeccancyInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdatePeccancyInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdatePeccancyInfoResponse, sizeof(_ns1__UpdatePeccancyInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdatePeccancyInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdatePeccancyInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UpdatePeccancyInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UpdatePeccancyInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:UpdatePeccancyInfoResult", &(a->_ns1__UpdatePeccancyInfoResponse::UpdatePeccancyInfoResult), "xsd:string"))
				{	soap_flag_UpdatePeccancyInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:UpdatePeccancyInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdatePeccancyInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdatePeccancyInfoResponse, 0, sizeof(_ns1__UpdatePeccancyInfoResponse), 0, soap_copy__ns1__UpdatePeccancyInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdatePeccancyInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UpdatePeccancyInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:UpdatePeccancyInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdatePeccancyInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdatePeccancyInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdatePeccancyInfoResponse * SOAP_FMAC4 soap_get__ns1__UpdatePeccancyInfoResponse(struct soap *soap, _ns1__UpdatePeccancyInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdatePeccancyInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdatePeccancyInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__UpdatePeccancyInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdatePeccancyInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdatePeccancyInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdatePeccancyInfoResponse);
		if (size)
			*size = sizeof(_ns1__UpdatePeccancyInfoResponse);
		((_ns1__UpdatePeccancyInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__UpdatePeccancyInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__UpdatePeccancyInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__UpdatePeccancyInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__UpdatePeccancyInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdatePeccancyInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdatePeccancyInfoResponse %p -> %p\n", q, p));
	*(_ns1__UpdatePeccancyInfoResponse*)p = *(_ns1__UpdatePeccancyInfoResponse*)q;
}

void _ns1__UpdatePeccancyInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__UpdatePeccancyInfo::xmlBody);
	/* transient soap skipped */
}

void _ns1__UpdatePeccancyInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__UpdatePeccancyInfo::xmlBody);
	/* transient soap skipped */
#endif
}

int _ns1__UpdatePeccancyInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__UpdatePeccancyInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__UpdatePeccancyInfo(struct soap *soap, const char *tag, int id, const _ns1__UpdatePeccancyInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__UpdatePeccancyInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xmlBody", -1, &(a->_ns1__UpdatePeccancyInfo::xmlBody), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__UpdatePeccancyInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__UpdatePeccancyInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__UpdatePeccancyInfo * SOAP_FMAC4 soap_in__ns1__UpdatePeccancyInfo(struct soap *soap, const char *tag, _ns1__UpdatePeccancyInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__UpdatePeccancyInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__UpdatePeccancyInfo, sizeof(_ns1__UpdatePeccancyInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__UpdatePeccancyInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__UpdatePeccancyInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlBody1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlBody1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:xmlBody", &(a->_ns1__UpdatePeccancyInfo::xmlBody), "xsd:string"))
				{	soap_flag_xmlBody1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__UpdatePeccancyInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__UpdatePeccancyInfo, 0, sizeof(_ns1__UpdatePeccancyInfo), 0, soap_copy__ns1__UpdatePeccancyInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__UpdatePeccancyInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__UpdatePeccancyInfo);
	if (this->soap_out(soap, tag?tag:"ns1:UpdatePeccancyInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__UpdatePeccancyInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__UpdatePeccancyInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__UpdatePeccancyInfo * SOAP_FMAC4 soap_get__ns1__UpdatePeccancyInfo(struct soap *soap, _ns1__UpdatePeccancyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__UpdatePeccancyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__UpdatePeccancyInfo * SOAP_FMAC2 soap_instantiate__ns1__UpdatePeccancyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__UpdatePeccancyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__UpdatePeccancyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__UpdatePeccancyInfo);
		if (size)
			*size = sizeof(_ns1__UpdatePeccancyInfo);
		((_ns1__UpdatePeccancyInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__UpdatePeccancyInfo, n);
		if (size)
			*size = n * sizeof(_ns1__UpdatePeccancyInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__UpdatePeccancyInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__UpdatePeccancyInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__UpdatePeccancyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__UpdatePeccancyInfo %p -> %p\n", q, p));
	*(_ns1__UpdatePeccancyInfo*)p = *(_ns1__UpdatePeccancyInfo*)q;
}

void _ns1__GetPeccancyNoCheckInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetPeccancyNoCheckInfoResponse::GetPeccancyNoCheckInfoResult);
	/* transient soap skipped */
}

void _ns1__GetPeccancyNoCheckInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetPeccancyNoCheckInfoResponse::GetPeccancyNoCheckInfoResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetPeccancyNoCheckInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPeccancyNoCheckInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPeccancyNoCheckInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPeccancyNoCheckInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPeccancyNoCheckInfoResponse), type))
		return soap->error;
	if (a->GetPeccancyNoCheckInfoResult)
		soap_element_result(soap, "ns1:GetPeccancyNoCheckInfoResult");
	if (soap_out_string(soap, "ns1:GetPeccancyNoCheckInfoResult", -1, &(a->_ns1__GetPeccancyNoCheckInfoResponse::GetPeccancyNoCheckInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPeccancyNoCheckInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPeccancyNoCheckInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPeccancyNoCheckInfoResponse * SOAP_FMAC4 soap_in__ns1__GetPeccancyNoCheckInfoResponse(struct soap *soap, const char *tag, _ns1__GetPeccancyNoCheckInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPeccancyNoCheckInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPeccancyNoCheckInfoResponse, sizeof(_ns1__GetPeccancyNoCheckInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPeccancyNoCheckInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPeccancyNoCheckInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPeccancyNoCheckInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPeccancyNoCheckInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:GetPeccancyNoCheckInfoResult", &(a->_ns1__GetPeccancyNoCheckInfoResponse::GetPeccancyNoCheckInfoResult), "xsd:string"))
				{	soap_flag_GetPeccancyNoCheckInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPeccancyNoCheckInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPeccancyNoCheckInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPeccancyNoCheckInfoResponse, 0, sizeof(_ns1__GetPeccancyNoCheckInfoResponse), 0, soap_copy__ns1__GetPeccancyNoCheckInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPeccancyNoCheckInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPeccancyNoCheckInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetPeccancyNoCheckInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPeccancyNoCheckInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPeccancyNoCheckInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPeccancyNoCheckInfoResponse * SOAP_FMAC4 soap_get__ns1__GetPeccancyNoCheckInfoResponse(struct soap *soap, _ns1__GetPeccancyNoCheckInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPeccancyNoCheckInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPeccancyNoCheckInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPeccancyNoCheckInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPeccancyNoCheckInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPeccancyNoCheckInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPeccancyNoCheckInfoResponse);
		if (size)
			*size = sizeof(_ns1__GetPeccancyNoCheckInfoResponse);
		((_ns1__GetPeccancyNoCheckInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetPeccancyNoCheckInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetPeccancyNoCheckInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetPeccancyNoCheckInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetPeccancyNoCheckInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPeccancyNoCheckInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPeccancyNoCheckInfoResponse %p -> %p\n", q, p));
	*(_ns1__GetPeccancyNoCheckInfoResponse*)p = *(_ns1__GetPeccancyNoCheckInfoResponse*)q;
}

void _ns1__GetPeccancyNoCheckInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetPeccancyNoCheckInfo::xmlBody);
	/* transient soap skipped */
}

void _ns1__GetPeccancyNoCheckInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetPeccancyNoCheckInfo::xmlBody);
	/* transient soap skipped */
#endif
}

int _ns1__GetPeccancyNoCheckInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPeccancyNoCheckInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPeccancyNoCheckInfo(struct soap *soap, const char *tag, int id, const _ns1__GetPeccancyNoCheckInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPeccancyNoCheckInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xmlBody", -1, &(a->_ns1__GetPeccancyNoCheckInfo::xmlBody), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPeccancyNoCheckInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPeccancyNoCheckInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPeccancyNoCheckInfo * SOAP_FMAC4 soap_in__ns1__GetPeccancyNoCheckInfo(struct soap *soap, const char *tag, _ns1__GetPeccancyNoCheckInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPeccancyNoCheckInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPeccancyNoCheckInfo, sizeof(_ns1__GetPeccancyNoCheckInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPeccancyNoCheckInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPeccancyNoCheckInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlBody1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlBody1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:xmlBody", &(a->_ns1__GetPeccancyNoCheckInfo::xmlBody), "xsd:string"))
				{	soap_flag_xmlBody1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPeccancyNoCheckInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPeccancyNoCheckInfo, 0, sizeof(_ns1__GetPeccancyNoCheckInfo), 0, soap_copy__ns1__GetPeccancyNoCheckInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPeccancyNoCheckInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPeccancyNoCheckInfo);
	if (this->soap_out(soap, tag?tag:"ns1:GetPeccancyNoCheckInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPeccancyNoCheckInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPeccancyNoCheckInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPeccancyNoCheckInfo * SOAP_FMAC4 soap_get__ns1__GetPeccancyNoCheckInfo(struct soap *soap, _ns1__GetPeccancyNoCheckInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPeccancyNoCheckInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPeccancyNoCheckInfo * SOAP_FMAC2 soap_instantiate__ns1__GetPeccancyNoCheckInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPeccancyNoCheckInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPeccancyNoCheckInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPeccancyNoCheckInfo);
		if (size)
			*size = sizeof(_ns1__GetPeccancyNoCheckInfo);
		((_ns1__GetPeccancyNoCheckInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetPeccancyNoCheckInfo, n);
		if (size)
			*size = n * sizeof(_ns1__GetPeccancyNoCheckInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetPeccancyNoCheckInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetPeccancyNoCheckInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPeccancyNoCheckInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPeccancyNoCheckInfo %p -> %p\n", q, p));
	*(_ns1__GetPeccancyNoCheckInfo*)p = *(_ns1__GetPeccancyNoCheckInfo*)q;
}

void _ns1__GetPeccancyInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetPeccancyInfoResponse::GetPeccancyInfoResult);
	/* transient soap skipped */
}

void _ns1__GetPeccancyInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetPeccancyInfoResponse::GetPeccancyInfoResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetPeccancyInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPeccancyInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPeccancyInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPeccancyInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPeccancyInfoResponse), type))
		return soap->error;
	if (a->GetPeccancyInfoResult)
		soap_element_result(soap, "ns1:GetPeccancyInfoResult");
	if (soap_out_string(soap, "ns1:GetPeccancyInfoResult", -1, &(a->_ns1__GetPeccancyInfoResponse::GetPeccancyInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPeccancyInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPeccancyInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPeccancyInfoResponse * SOAP_FMAC4 soap_in__ns1__GetPeccancyInfoResponse(struct soap *soap, const char *tag, _ns1__GetPeccancyInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPeccancyInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPeccancyInfoResponse, sizeof(_ns1__GetPeccancyInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPeccancyInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPeccancyInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPeccancyInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPeccancyInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:GetPeccancyInfoResult", &(a->_ns1__GetPeccancyInfoResponse::GetPeccancyInfoResult), "xsd:string"))
				{	soap_flag_GetPeccancyInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPeccancyInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPeccancyInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPeccancyInfoResponse, 0, sizeof(_ns1__GetPeccancyInfoResponse), 0, soap_copy__ns1__GetPeccancyInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPeccancyInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPeccancyInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetPeccancyInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPeccancyInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPeccancyInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPeccancyInfoResponse * SOAP_FMAC4 soap_get__ns1__GetPeccancyInfoResponse(struct soap *soap, _ns1__GetPeccancyInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPeccancyInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPeccancyInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPeccancyInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPeccancyInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPeccancyInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPeccancyInfoResponse);
		if (size)
			*size = sizeof(_ns1__GetPeccancyInfoResponse);
		((_ns1__GetPeccancyInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetPeccancyInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetPeccancyInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetPeccancyInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetPeccancyInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPeccancyInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPeccancyInfoResponse %p -> %p\n", q, p));
	*(_ns1__GetPeccancyInfoResponse*)p = *(_ns1__GetPeccancyInfoResponse*)q;
}

void _ns1__GetPeccancyInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetPeccancyInfo::xmlBody);
	/* transient soap skipped */
}

void _ns1__GetPeccancyInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetPeccancyInfo::xmlBody);
	/* transient soap skipped */
#endif
}

int _ns1__GetPeccancyInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPeccancyInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPeccancyInfo(struct soap *soap, const char *tag, int id, const _ns1__GetPeccancyInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPeccancyInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xmlBody", -1, &(a->_ns1__GetPeccancyInfo::xmlBody), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPeccancyInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPeccancyInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPeccancyInfo * SOAP_FMAC4 soap_in__ns1__GetPeccancyInfo(struct soap *soap, const char *tag, _ns1__GetPeccancyInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPeccancyInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPeccancyInfo, sizeof(_ns1__GetPeccancyInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPeccancyInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPeccancyInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlBody1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlBody1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:xmlBody", &(a->_ns1__GetPeccancyInfo::xmlBody), "xsd:string"))
				{	soap_flag_xmlBody1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPeccancyInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPeccancyInfo, 0, sizeof(_ns1__GetPeccancyInfo), 0, soap_copy__ns1__GetPeccancyInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPeccancyInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPeccancyInfo);
	if (this->soap_out(soap, tag?tag:"ns1:GetPeccancyInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPeccancyInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPeccancyInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPeccancyInfo * SOAP_FMAC4 soap_get__ns1__GetPeccancyInfo(struct soap *soap, _ns1__GetPeccancyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPeccancyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPeccancyInfo * SOAP_FMAC2 soap_instantiate__ns1__GetPeccancyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPeccancyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPeccancyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPeccancyInfo);
		if (size)
			*size = sizeof(_ns1__GetPeccancyInfo);
		((_ns1__GetPeccancyInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetPeccancyInfo, n);
		if (size)
			*size = n * sizeof(_ns1__GetPeccancyInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetPeccancyInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetPeccancyInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPeccancyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPeccancyInfo %p -> %p\n", q, p));
	*(_ns1__GetPeccancyInfo*)p = *(_ns1__GetPeccancyInfo*)q;
}

void _ns1__GetPassCarInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetPassCarInfoResponse::GetPassCarInfoResult);
	/* transient soap skipped */
}

void _ns1__GetPassCarInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetPassCarInfoResponse::GetPassCarInfoResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetPassCarInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPassCarInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPassCarInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetPassCarInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPassCarInfoResponse), type))
		return soap->error;
	if (a->GetPassCarInfoResult)
		soap_element_result(soap, "ns1:GetPassCarInfoResult");
	if (soap_out_string(soap, "ns1:GetPassCarInfoResult", -1, &(a->_ns1__GetPassCarInfoResponse::GetPassCarInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPassCarInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPassCarInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPassCarInfoResponse * SOAP_FMAC4 soap_in__ns1__GetPassCarInfoResponse(struct soap *soap, const char *tag, _ns1__GetPassCarInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPassCarInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPassCarInfoResponse, sizeof(_ns1__GetPassCarInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPassCarInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPassCarInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetPassCarInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPassCarInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:GetPassCarInfoResult", &(a->_ns1__GetPassCarInfoResponse::GetPassCarInfoResult), "xsd:string"))
				{	soap_flag_GetPassCarInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetPassCarInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPassCarInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPassCarInfoResponse, 0, sizeof(_ns1__GetPassCarInfoResponse), 0, soap_copy__ns1__GetPassCarInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPassCarInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPassCarInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetPassCarInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPassCarInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPassCarInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPassCarInfoResponse * SOAP_FMAC4 soap_get__ns1__GetPassCarInfoResponse(struct soap *soap, _ns1__GetPassCarInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPassCarInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPassCarInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__GetPassCarInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPassCarInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPassCarInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPassCarInfoResponse);
		if (size)
			*size = sizeof(_ns1__GetPassCarInfoResponse);
		((_ns1__GetPassCarInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetPassCarInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetPassCarInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetPassCarInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetPassCarInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPassCarInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPassCarInfoResponse %p -> %p\n", q, p));
	*(_ns1__GetPassCarInfoResponse*)p = *(_ns1__GetPassCarInfoResponse*)q;
}

void _ns1__GetPassCarInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetPassCarInfo::xmlBody);
	/* transient soap skipped */
}

void _ns1__GetPassCarInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetPassCarInfo::xmlBody);
	/* transient soap skipped */
#endif
}

int _ns1__GetPassCarInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetPassCarInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetPassCarInfo(struct soap *soap, const char *tag, int id, const _ns1__GetPassCarInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetPassCarInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xmlBody", -1, &(a->_ns1__GetPassCarInfo::xmlBody), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetPassCarInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetPassCarInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetPassCarInfo * SOAP_FMAC4 soap_in__ns1__GetPassCarInfo(struct soap *soap, const char *tag, _ns1__GetPassCarInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetPassCarInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetPassCarInfo, sizeof(_ns1__GetPassCarInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetPassCarInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetPassCarInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlBody1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlBody1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:xmlBody", &(a->_ns1__GetPassCarInfo::xmlBody), "xsd:string"))
				{	soap_flag_xmlBody1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetPassCarInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetPassCarInfo, 0, sizeof(_ns1__GetPassCarInfo), 0, soap_copy__ns1__GetPassCarInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetPassCarInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetPassCarInfo);
	if (this->soap_out(soap, tag?tag:"ns1:GetPassCarInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetPassCarInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetPassCarInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetPassCarInfo * SOAP_FMAC4 soap_get__ns1__GetPassCarInfo(struct soap *soap, _ns1__GetPassCarInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetPassCarInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetPassCarInfo * SOAP_FMAC2 soap_instantiate__ns1__GetPassCarInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetPassCarInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetPassCarInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetPassCarInfo);
		if (size)
			*size = sizeof(_ns1__GetPassCarInfo);
		((_ns1__GetPassCarInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetPassCarInfo, n);
		if (size)
			*size = n * sizeof(_ns1__GetPassCarInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetPassCarInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetPassCarInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetPassCarInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetPassCarInfo %p -> %p\n", q, p));
	*(_ns1__GetPassCarInfo*)p = *(_ns1__GetPassCarInfo*)q;
}

void _ns1__GetLocationInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetLocationInfoResponse::GetLocationInfoResult);
	/* transient soap skipped */
}

void _ns1__GetLocationInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetLocationInfoResponse::GetLocationInfoResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetLocationInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLocationInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLocationInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__GetLocationInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLocationInfoResponse), type))
		return soap->error;
	if (a->GetLocationInfoResult)
		soap_element_result(soap, "ns1:GetLocationInfoResult");
	if (soap_out_string(soap, "ns1:GetLocationInfoResult", -1, &(a->_ns1__GetLocationInfoResponse::GetLocationInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLocationInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLocationInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLocationInfoResponse * SOAP_FMAC4 soap_in__ns1__GetLocationInfoResponse(struct soap *soap, const char *tag, _ns1__GetLocationInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLocationInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLocationInfoResponse, sizeof(_ns1__GetLocationInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetLocationInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetLocationInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetLocationInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetLocationInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:GetLocationInfoResult", &(a->_ns1__GetLocationInfoResponse::GetLocationInfoResult), "xsd:string"))
				{	soap_flag_GetLocationInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetLocationInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetLocationInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLocationInfoResponse, 0, sizeof(_ns1__GetLocationInfoResponse), 0, soap_copy__ns1__GetLocationInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetLocationInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetLocationInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetLocationInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLocationInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLocationInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLocationInfoResponse * SOAP_FMAC4 soap_get__ns1__GetLocationInfoResponse(struct soap *soap, _ns1__GetLocationInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLocationInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetLocationInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__GetLocationInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLocationInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetLocationInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetLocationInfoResponse);
		if (size)
			*size = sizeof(_ns1__GetLocationInfoResponse);
		((_ns1__GetLocationInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetLocationInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetLocationInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetLocationInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetLocationInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetLocationInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetLocationInfoResponse %p -> %p\n", q, p));
	*(_ns1__GetLocationInfoResponse*)p = *(_ns1__GetLocationInfoResponse*)q;
}

void _ns1__GetLocationInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetLocationInfo::ddbh);
	/* transient soap skipped */
}

void _ns1__GetLocationInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetLocationInfo::ddbh);
	/* transient soap skipped */
#endif
}

int _ns1__GetLocationInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetLocationInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetLocationInfo(struct soap *soap, const char *tag, int id, const _ns1__GetLocationInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetLocationInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:ddbh", -1, &(a->_ns1__GetLocationInfo::ddbh), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetLocationInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetLocationInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetLocationInfo * SOAP_FMAC4 soap_in__ns1__GetLocationInfo(struct soap *soap, const char *tag, _ns1__GetLocationInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetLocationInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetLocationInfo, sizeof(_ns1__GetLocationInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetLocationInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetLocationInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ddbh1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ddbh1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:ddbh", &(a->_ns1__GetLocationInfo::ddbh), "xsd:string"))
				{	soap_flag_ddbh1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetLocationInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetLocationInfo, 0, sizeof(_ns1__GetLocationInfo), 0, soap_copy__ns1__GetLocationInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetLocationInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetLocationInfo);
	if (this->soap_out(soap, tag?tag:"ns1:GetLocationInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetLocationInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetLocationInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetLocationInfo * SOAP_FMAC4 soap_get__ns1__GetLocationInfo(struct soap *soap, _ns1__GetLocationInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetLocationInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetLocationInfo * SOAP_FMAC2 soap_instantiate__ns1__GetLocationInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetLocationInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetLocationInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetLocationInfo);
		if (size)
			*size = sizeof(_ns1__GetLocationInfo);
		((_ns1__GetLocationInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetLocationInfo, n);
		if (size)
			*size = n * sizeof(_ns1__GetLocationInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetLocationInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetLocationInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetLocationInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetLocationInfo %p -> %p\n", q, p));
	*(_ns1__GetLocationInfo*)p = *(_ns1__GetLocationInfo*)q;
}

void _ns1__RevokeSuspicionInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__RevokeSuspicionInfoResponse::RevokeSuspicionInfoResult);
	/* transient soap skipped */
}

void _ns1__RevokeSuspicionInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__RevokeSuspicionInfoResponse::RevokeSuspicionInfoResult);
	/* transient soap skipped */
#endif
}

int _ns1__RevokeSuspicionInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RevokeSuspicionInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RevokeSuspicionInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__RevokeSuspicionInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RevokeSuspicionInfoResponse), type))
		return soap->error;
	if (a->RevokeSuspicionInfoResult)
		soap_element_result(soap, "ns1:RevokeSuspicionInfoResult");
	if (soap_out_string(soap, "ns1:RevokeSuspicionInfoResult", -1, &(a->_ns1__RevokeSuspicionInfoResponse::RevokeSuspicionInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__RevokeSuspicionInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RevokeSuspicionInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RevokeSuspicionInfoResponse * SOAP_FMAC4 soap_in__ns1__RevokeSuspicionInfoResponse(struct soap *soap, const char *tag, _ns1__RevokeSuspicionInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RevokeSuspicionInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RevokeSuspicionInfoResponse, sizeof(_ns1__RevokeSuspicionInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__RevokeSuspicionInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__RevokeSuspicionInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RevokeSuspicionInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RevokeSuspicionInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:RevokeSuspicionInfoResult", &(a->_ns1__RevokeSuspicionInfoResponse::RevokeSuspicionInfoResult), "xsd:string"))
				{	soap_flag_RevokeSuspicionInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:RevokeSuspicionInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__RevokeSuspicionInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RevokeSuspicionInfoResponse, 0, sizeof(_ns1__RevokeSuspicionInfoResponse), 0, soap_copy__ns1__RevokeSuspicionInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__RevokeSuspicionInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__RevokeSuspicionInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:RevokeSuspicionInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RevokeSuspicionInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RevokeSuspicionInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RevokeSuspicionInfoResponse * SOAP_FMAC4 soap_get__ns1__RevokeSuspicionInfoResponse(struct soap *soap, _ns1__RevokeSuspicionInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RevokeSuspicionInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__RevokeSuspicionInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__RevokeSuspicionInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RevokeSuspicionInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__RevokeSuspicionInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__RevokeSuspicionInfoResponse);
		if (size)
			*size = sizeof(_ns1__RevokeSuspicionInfoResponse);
		((_ns1__RevokeSuspicionInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__RevokeSuspicionInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__RevokeSuspicionInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__RevokeSuspicionInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__RevokeSuspicionInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__RevokeSuspicionInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__RevokeSuspicionInfoResponse %p -> %p\n", q, p));
	*(_ns1__RevokeSuspicionInfoResponse*)p = *(_ns1__RevokeSuspicionInfoResponse*)q;
}

void _ns1__RevokeSuspicionInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__RevokeSuspicionInfo::xmlBody);
	/* transient soap skipped */
}

void _ns1__RevokeSuspicionInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__RevokeSuspicionInfo::xmlBody);
	/* transient soap skipped */
#endif
}

int _ns1__RevokeSuspicionInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RevokeSuspicionInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RevokeSuspicionInfo(struct soap *soap, const char *tag, int id, const _ns1__RevokeSuspicionInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RevokeSuspicionInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xmlBody", -1, &(a->_ns1__RevokeSuspicionInfo::xmlBody), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__RevokeSuspicionInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RevokeSuspicionInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RevokeSuspicionInfo * SOAP_FMAC4 soap_in__ns1__RevokeSuspicionInfo(struct soap *soap, const char *tag, _ns1__RevokeSuspicionInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RevokeSuspicionInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RevokeSuspicionInfo, sizeof(_ns1__RevokeSuspicionInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__RevokeSuspicionInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__RevokeSuspicionInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlBody1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlBody1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:xmlBody", &(a->_ns1__RevokeSuspicionInfo::xmlBody), "xsd:string"))
				{	soap_flag_xmlBody1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__RevokeSuspicionInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RevokeSuspicionInfo, 0, sizeof(_ns1__RevokeSuspicionInfo), 0, soap_copy__ns1__RevokeSuspicionInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__RevokeSuspicionInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__RevokeSuspicionInfo);
	if (this->soap_out(soap, tag?tag:"ns1:RevokeSuspicionInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RevokeSuspicionInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RevokeSuspicionInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RevokeSuspicionInfo * SOAP_FMAC4 soap_get__ns1__RevokeSuspicionInfo(struct soap *soap, _ns1__RevokeSuspicionInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RevokeSuspicionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__RevokeSuspicionInfo * SOAP_FMAC2 soap_instantiate__ns1__RevokeSuspicionInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RevokeSuspicionInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__RevokeSuspicionInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__RevokeSuspicionInfo);
		if (size)
			*size = sizeof(_ns1__RevokeSuspicionInfo);
		((_ns1__RevokeSuspicionInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__RevokeSuspicionInfo, n);
		if (size)
			*size = n * sizeof(_ns1__RevokeSuspicionInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__RevokeSuspicionInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__RevokeSuspicionInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__RevokeSuspicionInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__RevokeSuspicionInfo %p -> %p\n", q, p));
	*(_ns1__RevokeSuspicionInfo*)p = *(_ns1__RevokeSuspicionInfo*)q;
}

void _ns1__InSuspicionInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__InSuspicionInfoResponse::InSuspicionInfoResult);
	/* transient soap skipped */
}

void _ns1__InSuspicionInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__InSuspicionInfoResponse::InSuspicionInfoResult);
	/* transient soap skipped */
#endif
}

int _ns1__InSuspicionInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InSuspicionInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InSuspicionInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__InSuspicionInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InSuspicionInfoResponse), type))
		return soap->error;
	if (a->InSuspicionInfoResult)
		soap_element_result(soap, "ns1:InSuspicionInfoResult");
	if (soap_out_string(soap, "ns1:InSuspicionInfoResult", -1, &(a->_ns1__InSuspicionInfoResponse::InSuspicionInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__InSuspicionInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InSuspicionInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InSuspicionInfoResponse * SOAP_FMAC4 soap_in__ns1__InSuspicionInfoResponse(struct soap *soap, const char *tag, _ns1__InSuspicionInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InSuspicionInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InSuspicionInfoResponse, sizeof(_ns1__InSuspicionInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__InSuspicionInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__InSuspicionInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_InSuspicionInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InSuspicionInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:InSuspicionInfoResult", &(a->_ns1__InSuspicionInfoResponse::InSuspicionInfoResult), "xsd:string"))
				{	soap_flag_InSuspicionInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:InSuspicionInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InSuspicionInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InSuspicionInfoResponse, 0, sizeof(_ns1__InSuspicionInfoResponse), 0, soap_copy__ns1__InSuspicionInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__InSuspicionInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__InSuspicionInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:InSuspicionInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InSuspicionInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InSuspicionInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InSuspicionInfoResponse * SOAP_FMAC4 soap_get__ns1__InSuspicionInfoResponse(struct soap *soap, _ns1__InSuspicionInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InSuspicionInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__InSuspicionInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__InSuspicionInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InSuspicionInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__InSuspicionInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__InSuspicionInfoResponse);
		if (size)
			*size = sizeof(_ns1__InSuspicionInfoResponse);
		((_ns1__InSuspicionInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__InSuspicionInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__InSuspicionInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__InSuspicionInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__InSuspicionInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__InSuspicionInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__InSuspicionInfoResponse %p -> %p\n", q, p));
	*(_ns1__InSuspicionInfoResponse*)p = *(_ns1__InSuspicionInfoResponse*)q;
}

void _ns1__InSuspicionInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__InSuspicionInfo::xmlBody);
	/* transient soap skipped */
}

void _ns1__InSuspicionInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__InSuspicionInfo::xmlBody);
	/* transient soap skipped */
#endif
}

int _ns1__InSuspicionInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InSuspicionInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InSuspicionInfo(struct soap *soap, const char *tag, int id, const _ns1__InSuspicionInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InSuspicionInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xmlBody", -1, &(a->_ns1__InSuspicionInfo::xmlBody), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__InSuspicionInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InSuspicionInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InSuspicionInfo * SOAP_FMAC4 soap_in__ns1__InSuspicionInfo(struct soap *soap, const char *tag, _ns1__InSuspicionInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InSuspicionInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InSuspicionInfo, sizeof(_ns1__InSuspicionInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__InSuspicionInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__InSuspicionInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlBody1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlBody1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:xmlBody", &(a->_ns1__InSuspicionInfo::xmlBody), "xsd:string"))
				{	soap_flag_xmlBody1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InSuspicionInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InSuspicionInfo, 0, sizeof(_ns1__InSuspicionInfo), 0, soap_copy__ns1__InSuspicionInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__InSuspicionInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__InSuspicionInfo);
	if (this->soap_out(soap, tag?tag:"ns1:InSuspicionInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InSuspicionInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InSuspicionInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InSuspicionInfo * SOAP_FMAC4 soap_get__ns1__InSuspicionInfo(struct soap *soap, _ns1__InSuspicionInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InSuspicionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__InSuspicionInfo * SOAP_FMAC2 soap_instantiate__ns1__InSuspicionInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InSuspicionInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__InSuspicionInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__InSuspicionInfo);
		if (size)
			*size = sizeof(_ns1__InSuspicionInfo);
		((_ns1__InSuspicionInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__InSuspicionInfo, n);
		if (size)
			*size = n * sizeof(_ns1__InSuspicionInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__InSuspicionInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__InSuspicionInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__InSuspicionInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__InSuspicionInfo %p -> %p\n", q, p));
	*(_ns1__InSuspicionInfo*)p = *(_ns1__InSuspicionInfo*)q;
}

void _ns1__IntExtralistInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__IntExtralistInfoResponse::IntExtralistInfoResult);
	/* transient soap skipped */
}

void _ns1__IntExtralistInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__IntExtralistInfoResponse::IntExtralistInfoResult);
	/* transient soap skipped */
#endif
}

int _ns1__IntExtralistInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__IntExtralistInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__IntExtralistInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__IntExtralistInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__IntExtralistInfoResponse), type))
		return soap->error;
	if (a->IntExtralistInfoResult)
		soap_element_result(soap, "ns1:IntExtralistInfoResult");
	if (soap_out_string(soap, "ns1:IntExtralistInfoResult", -1, &(a->_ns1__IntExtralistInfoResponse::IntExtralistInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__IntExtralistInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__IntExtralistInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__IntExtralistInfoResponse * SOAP_FMAC4 soap_in__ns1__IntExtralistInfoResponse(struct soap *soap, const char *tag, _ns1__IntExtralistInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__IntExtralistInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__IntExtralistInfoResponse, sizeof(_ns1__IntExtralistInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__IntExtralistInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__IntExtralistInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_IntExtralistInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IntExtralistInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:IntExtralistInfoResult", &(a->_ns1__IntExtralistInfoResponse::IntExtralistInfoResult), "xsd:string"))
				{	soap_flag_IntExtralistInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:IntExtralistInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__IntExtralistInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__IntExtralistInfoResponse, 0, sizeof(_ns1__IntExtralistInfoResponse), 0, soap_copy__ns1__IntExtralistInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__IntExtralistInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__IntExtralistInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:IntExtralistInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__IntExtralistInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__IntExtralistInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__IntExtralistInfoResponse * SOAP_FMAC4 soap_get__ns1__IntExtralistInfoResponse(struct soap *soap, _ns1__IntExtralistInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__IntExtralistInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__IntExtralistInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__IntExtralistInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__IntExtralistInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__IntExtralistInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__IntExtralistInfoResponse);
		if (size)
			*size = sizeof(_ns1__IntExtralistInfoResponse);
		((_ns1__IntExtralistInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__IntExtralistInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__IntExtralistInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__IntExtralistInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__IntExtralistInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__IntExtralistInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__IntExtralistInfoResponse %p -> %p\n", q, p));
	*(_ns1__IntExtralistInfoResponse*)p = *(_ns1__IntExtralistInfoResponse*)q;
}

void _ns1__IntExtralistInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__IntExtralistInfo::xmlBody);
	/* transient soap skipped */
}

void _ns1__IntExtralistInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__IntExtralistInfo::xmlBody);
	/* transient soap skipped */
#endif
}

int _ns1__IntExtralistInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__IntExtralistInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__IntExtralistInfo(struct soap *soap, const char *tag, int id, const _ns1__IntExtralistInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__IntExtralistInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xmlBody", -1, &(a->_ns1__IntExtralistInfo::xmlBody), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__IntExtralistInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__IntExtralistInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__IntExtralistInfo * SOAP_FMAC4 soap_in__ns1__IntExtralistInfo(struct soap *soap, const char *tag, _ns1__IntExtralistInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__IntExtralistInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__IntExtralistInfo, sizeof(_ns1__IntExtralistInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__IntExtralistInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__IntExtralistInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlBody1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlBody1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:xmlBody", &(a->_ns1__IntExtralistInfo::xmlBody), "xsd:string"))
				{	soap_flag_xmlBody1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__IntExtralistInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__IntExtralistInfo, 0, sizeof(_ns1__IntExtralistInfo), 0, soap_copy__ns1__IntExtralistInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__IntExtralistInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__IntExtralistInfo);
	if (this->soap_out(soap, tag?tag:"ns1:IntExtralistInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__IntExtralistInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__IntExtralistInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__IntExtralistInfo * SOAP_FMAC4 soap_get__ns1__IntExtralistInfo(struct soap *soap, _ns1__IntExtralistInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__IntExtralistInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__IntExtralistInfo * SOAP_FMAC2 soap_instantiate__ns1__IntExtralistInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__IntExtralistInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__IntExtralistInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__IntExtralistInfo);
		if (size)
			*size = sizeof(_ns1__IntExtralistInfo);
		((_ns1__IntExtralistInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__IntExtralistInfo, n);
		if (size)
			*size = n * sizeof(_ns1__IntExtralistInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__IntExtralistInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__IntExtralistInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__IntExtralistInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__IntExtralistInfo %p -> %p\n", q, p));
	*(_ns1__IntExtralistInfo*)p = *(_ns1__IntExtralistInfo*)q;
}

void _ns1__InChecklessInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__InChecklessInfoResponse::InChecklessInfoResult);
	/* transient soap skipped */
}

void _ns1__InChecklessInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__InChecklessInfoResponse::InChecklessInfoResult);
	/* transient soap skipped */
#endif
}

int _ns1__InChecklessInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InChecklessInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InChecklessInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__InChecklessInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InChecklessInfoResponse), type))
		return soap->error;
	if (a->InChecklessInfoResult)
		soap_element_result(soap, "ns1:InChecklessInfoResult");
	if (soap_out_string(soap, "ns1:InChecklessInfoResult", -1, &(a->_ns1__InChecklessInfoResponse::InChecklessInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__InChecklessInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InChecklessInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InChecklessInfoResponse * SOAP_FMAC4 soap_in__ns1__InChecklessInfoResponse(struct soap *soap, const char *tag, _ns1__InChecklessInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InChecklessInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InChecklessInfoResponse, sizeof(_ns1__InChecklessInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__InChecklessInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__InChecklessInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_InChecklessInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InChecklessInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:InChecklessInfoResult", &(a->_ns1__InChecklessInfoResponse::InChecklessInfoResult), "xsd:string"))
				{	soap_flag_InChecklessInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:InChecklessInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InChecklessInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InChecklessInfoResponse, 0, sizeof(_ns1__InChecklessInfoResponse), 0, soap_copy__ns1__InChecklessInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__InChecklessInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__InChecklessInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:InChecklessInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InChecklessInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InChecklessInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InChecklessInfoResponse * SOAP_FMAC4 soap_get__ns1__InChecklessInfoResponse(struct soap *soap, _ns1__InChecklessInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InChecklessInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__InChecklessInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__InChecklessInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InChecklessInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__InChecklessInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__InChecklessInfoResponse);
		if (size)
			*size = sizeof(_ns1__InChecklessInfoResponse);
		((_ns1__InChecklessInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__InChecklessInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__InChecklessInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__InChecklessInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__InChecklessInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__InChecklessInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__InChecklessInfoResponse %p -> %p\n", q, p));
	*(_ns1__InChecklessInfoResponse*)p = *(_ns1__InChecklessInfoResponse*)q;
}

void _ns1__InChecklessInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__InChecklessInfo::xmlBody);
	/* transient soap skipped */
}

void _ns1__InChecklessInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__InChecklessInfo::xmlBody);
	/* transient soap skipped */
#endif
}

int _ns1__InChecklessInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InChecklessInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InChecklessInfo(struct soap *soap, const char *tag, int id, const _ns1__InChecklessInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InChecklessInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xmlBody", -1, &(a->_ns1__InChecklessInfo::xmlBody), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__InChecklessInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InChecklessInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InChecklessInfo * SOAP_FMAC4 soap_in__ns1__InChecklessInfo(struct soap *soap, const char *tag, _ns1__InChecklessInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InChecklessInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InChecklessInfo, sizeof(_ns1__InChecklessInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__InChecklessInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__InChecklessInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlBody1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlBody1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:xmlBody", &(a->_ns1__InChecklessInfo::xmlBody), "xsd:string"))
				{	soap_flag_xmlBody1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InChecklessInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InChecklessInfo, 0, sizeof(_ns1__InChecklessInfo), 0, soap_copy__ns1__InChecklessInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__InChecklessInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__InChecklessInfo);
	if (this->soap_out(soap, tag?tag:"ns1:InChecklessInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InChecklessInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InChecklessInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InChecklessInfo * SOAP_FMAC4 soap_get__ns1__InChecklessInfo(struct soap *soap, _ns1__InChecklessInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InChecklessInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__InChecklessInfo * SOAP_FMAC2 soap_instantiate__ns1__InChecklessInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InChecklessInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__InChecklessInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__InChecklessInfo);
		if (size)
			*size = sizeof(_ns1__InChecklessInfo);
		((_ns1__InChecklessInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__InChecklessInfo, n);
		if (size)
			*size = n * sizeof(_ns1__InChecklessInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__InChecklessInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__InChecklessInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__InChecklessInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__InChecklessInfo %p -> %p\n", q, p));
	*(_ns1__InChecklessInfo*)p = *(_ns1__InChecklessInfo*)q;
}

void _ns1__InBlacklistInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__InBlacklistInfoResponse::InBlacklistInfoResult);
	/* transient soap skipped */
}

void _ns1__InBlacklistInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__InBlacklistInfoResponse::InBlacklistInfoResult);
	/* transient soap skipped */
#endif
}

int _ns1__InBlacklistInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InBlacklistInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InBlacklistInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__InBlacklistInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InBlacklistInfoResponse), type))
		return soap->error;
	if (a->InBlacklistInfoResult)
		soap_element_result(soap, "ns1:InBlacklistInfoResult");
	if (soap_out_string(soap, "ns1:InBlacklistInfoResult", -1, &(a->_ns1__InBlacklistInfoResponse::InBlacklistInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__InBlacklistInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InBlacklistInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InBlacklistInfoResponse * SOAP_FMAC4 soap_in__ns1__InBlacklistInfoResponse(struct soap *soap, const char *tag, _ns1__InBlacklistInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InBlacklistInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InBlacklistInfoResponse, sizeof(_ns1__InBlacklistInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__InBlacklistInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__InBlacklistInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_InBlacklistInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InBlacklistInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:InBlacklistInfoResult", &(a->_ns1__InBlacklistInfoResponse::InBlacklistInfoResult), "xsd:string"))
				{	soap_flag_InBlacklistInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:InBlacklistInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InBlacklistInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InBlacklistInfoResponse, 0, sizeof(_ns1__InBlacklistInfoResponse), 0, soap_copy__ns1__InBlacklistInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__InBlacklistInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__InBlacklistInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:InBlacklistInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InBlacklistInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InBlacklistInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InBlacklistInfoResponse * SOAP_FMAC4 soap_get__ns1__InBlacklistInfoResponse(struct soap *soap, _ns1__InBlacklistInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InBlacklistInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__InBlacklistInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__InBlacklistInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InBlacklistInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__InBlacklistInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__InBlacklistInfoResponse);
		if (size)
			*size = sizeof(_ns1__InBlacklistInfoResponse);
		((_ns1__InBlacklistInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__InBlacklistInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__InBlacklistInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__InBlacklistInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__InBlacklistInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__InBlacklistInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__InBlacklistInfoResponse %p -> %p\n", q, p));
	*(_ns1__InBlacklistInfoResponse*)p = *(_ns1__InBlacklistInfoResponse*)q;
}

void _ns1__InBlacklistInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__InBlacklistInfo::xmlBody);
	/* transient soap skipped */
}

void _ns1__InBlacklistInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__InBlacklistInfo::xmlBody);
	/* transient soap skipped */
#endif
}

int _ns1__InBlacklistInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InBlacklistInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InBlacklistInfo(struct soap *soap, const char *tag, int id, const _ns1__InBlacklistInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InBlacklistInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xmlBody", -1, &(a->_ns1__InBlacklistInfo::xmlBody), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__InBlacklistInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InBlacklistInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InBlacklistInfo * SOAP_FMAC4 soap_in__ns1__InBlacklistInfo(struct soap *soap, const char *tag, _ns1__InBlacklistInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InBlacklistInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InBlacklistInfo, sizeof(_ns1__InBlacklistInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__InBlacklistInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__InBlacklistInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlBody1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlBody1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:xmlBody", &(a->_ns1__InBlacklistInfo::xmlBody), "xsd:string"))
				{	soap_flag_xmlBody1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InBlacklistInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InBlacklistInfo, 0, sizeof(_ns1__InBlacklistInfo), 0, soap_copy__ns1__InBlacklistInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__InBlacklistInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__InBlacklistInfo);
	if (this->soap_out(soap, tag?tag:"ns1:InBlacklistInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InBlacklistInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InBlacklistInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InBlacklistInfo * SOAP_FMAC4 soap_get__ns1__InBlacklistInfo(struct soap *soap, _ns1__InBlacklistInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InBlacklistInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__InBlacklistInfo * SOAP_FMAC2 soap_instantiate__ns1__InBlacklistInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InBlacklistInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__InBlacklistInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__InBlacklistInfo);
		if (size)
			*size = sizeof(_ns1__InBlacklistInfo);
		((_ns1__InBlacklistInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__InBlacklistInfo, n);
		if (size)
			*size = n * sizeof(_ns1__InBlacklistInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__InBlacklistInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__InBlacklistInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__InBlacklistInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__InBlacklistInfo %p -> %p\n", q, p));
	*(_ns1__InBlacklistInfo*)p = *(_ns1__InBlacklistInfo*)q;
}

void _ns1__InCheckedPeccancyInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__InCheckedPeccancyInfoResponse::InCheckedPeccancyInfoResult);
	/* transient soap skipped */
}

void _ns1__InCheckedPeccancyInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__InCheckedPeccancyInfoResponse::InCheckedPeccancyInfoResult);
	/* transient soap skipped */
#endif
}

int _ns1__InCheckedPeccancyInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InCheckedPeccancyInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InCheckedPeccancyInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__InCheckedPeccancyInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InCheckedPeccancyInfoResponse), type))
		return soap->error;
	if (a->InCheckedPeccancyInfoResult)
		soap_element_result(soap, "ns1:InCheckedPeccancyInfoResult");
	if (soap_out_string(soap, "ns1:InCheckedPeccancyInfoResult", -1, &(a->_ns1__InCheckedPeccancyInfoResponse::InCheckedPeccancyInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__InCheckedPeccancyInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InCheckedPeccancyInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InCheckedPeccancyInfoResponse * SOAP_FMAC4 soap_in__ns1__InCheckedPeccancyInfoResponse(struct soap *soap, const char *tag, _ns1__InCheckedPeccancyInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InCheckedPeccancyInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InCheckedPeccancyInfoResponse, sizeof(_ns1__InCheckedPeccancyInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__InCheckedPeccancyInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__InCheckedPeccancyInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_InCheckedPeccancyInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InCheckedPeccancyInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:InCheckedPeccancyInfoResult", &(a->_ns1__InCheckedPeccancyInfoResponse::InCheckedPeccancyInfoResult), "xsd:string"))
				{	soap_flag_InCheckedPeccancyInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:InCheckedPeccancyInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InCheckedPeccancyInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InCheckedPeccancyInfoResponse, 0, sizeof(_ns1__InCheckedPeccancyInfoResponse), 0, soap_copy__ns1__InCheckedPeccancyInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__InCheckedPeccancyInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__InCheckedPeccancyInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:InCheckedPeccancyInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InCheckedPeccancyInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InCheckedPeccancyInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InCheckedPeccancyInfoResponse * SOAP_FMAC4 soap_get__ns1__InCheckedPeccancyInfoResponse(struct soap *soap, _ns1__InCheckedPeccancyInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InCheckedPeccancyInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__InCheckedPeccancyInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__InCheckedPeccancyInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InCheckedPeccancyInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__InCheckedPeccancyInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__InCheckedPeccancyInfoResponse);
		if (size)
			*size = sizeof(_ns1__InCheckedPeccancyInfoResponse);
		((_ns1__InCheckedPeccancyInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__InCheckedPeccancyInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__InCheckedPeccancyInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__InCheckedPeccancyInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__InCheckedPeccancyInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__InCheckedPeccancyInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__InCheckedPeccancyInfoResponse %p -> %p\n", q, p));
	*(_ns1__InCheckedPeccancyInfoResponse*)p = *(_ns1__InCheckedPeccancyInfoResponse*)q;
}

void _ns1__InCheckedPeccancyInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__InCheckedPeccancyInfo::xmlBody);
	/* transient soap skipped */
}

void _ns1__InCheckedPeccancyInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__InCheckedPeccancyInfo::xmlBody);
	/* transient soap skipped */
#endif
}

int _ns1__InCheckedPeccancyInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InCheckedPeccancyInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InCheckedPeccancyInfo(struct soap *soap, const char *tag, int id, const _ns1__InCheckedPeccancyInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InCheckedPeccancyInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xmlBody", -1, &(a->_ns1__InCheckedPeccancyInfo::xmlBody), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__InCheckedPeccancyInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InCheckedPeccancyInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InCheckedPeccancyInfo * SOAP_FMAC4 soap_in__ns1__InCheckedPeccancyInfo(struct soap *soap, const char *tag, _ns1__InCheckedPeccancyInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InCheckedPeccancyInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InCheckedPeccancyInfo, sizeof(_ns1__InCheckedPeccancyInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__InCheckedPeccancyInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__InCheckedPeccancyInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlBody1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlBody1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:xmlBody", &(a->_ns1__InCheckedPeccancyInfo::xmlBody), "xsd:string"))
				{	soap_flag_xmlBody1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InCheckedPeccancyInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InCheckedPeccancyInfo, 0, sizeof(_ns1__InCheckedPeccancyInfo), 0, soap_copy__ns1__InCheckedPeccancyInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__InCheckedPeccancyInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__InCheckedPeccancyInfo);
	if (this->soap_out(soap, tag?tag:"ns1:InCheckedPeccancyInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InCheckedPeccancyInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InCheckedPeccancyInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InCheckedPeccancyInfo * SOAP_FMAC4 soap_get__ns1__InCheckedPeccancyInfo(struct soap *soap, _ns1__InCheckedPeccancyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InCheckedPeccancyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__InCheckedPeccancyInfo * SOAP_FMAC2 soap_instantiate__ns1__InCheckedPeccancyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InCheckedPeccancyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__InCheckedPeccancyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__InCheckedPeccancyInfo);
		if (size)
			*size = sizeof(_ns1__InCheckedPeccancyInfo);
		((_ns1__InCheckedPeccancyInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__InCheckedPeccancyInfo, n);
		if (size)
			*size = n * sizeof(_ns1__InCheckedPeccancyInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__InCheckedPeccancyInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__InCheckedPeccancyInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__InCheckedPeccancyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__InCheckedPeccancyInfo %p -> %p\n", q, p));
	*(_ns1__InCheckedPeccancyInfo*)p = *(_ns1__InCheckedPeccancyInfo*)q;
}

void _ns1__InPeccancyInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__InPeccancyInfoResponse::InPeccancyInfoResult);
	/* transient soap skipped */
}

void _ns1__InPeccancyInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__InPeccancyInfoResponse::InPeccancyInfoResult);
	/* transient soap skipped */
#endif
}

int _ns1__InPeccancyInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InPeccancyInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InPeccancyInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__InPeccancyInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InPeccancyInfoResponse), type))
		return soap->error;
	if (a->InPeccancyInfoResult)
		soap_element_result(soap, "ns1:InPeccancyInfoResult");
	if (soap_out_string(soap, "ns1:InPeccancyInfoResult", -1, &(a->_ns1__InPeccancyInfoResponse::InPeccancyInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__InPeccancyInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InPeccancyInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InPeccancyInfoResponse * SOAP_FMAC4 soap_in__ns1__InPeccancyInfoResponse(struct soap *soap, const char *tag, _ns1__InPeccancyInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InPeccancyInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InPeccancyInfoResponse, sizeof(_ns1__InPeccancyInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__InPeccancyInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__InPeccancyInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_InPeccancyInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InPeccancyInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:InPeccancyInfoResult", &(a->_ns1__InPeccancyInfoResponse::InPeccancyInfoResult), "xsd:string"))
				{	soap_flag_InPeccancyInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:InPeccancyInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InPeccancyInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InPeccancyInfoResponse, 0, sizeof(_ns1__InPeccancyInfoResponse), 0, soap_copy__ns1__InPeccancyInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__InPeccancyInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__InPeccancyInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:InPeccancyInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InPeccancyInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InPeccancyInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InPeccancyInfoResponse * SOAP_FMAC4 soap_get__ns1__InPeccancyInfoResponse(struct soap *soap, _ns1__InPeccancyInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InPeccancyInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__InPeccancyInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__InPeccancyInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InPeccancyInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__InPeccancyInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__InPeccancyInfoResponse);
		if (size)
			*size = sizeof(_ns1__InPeccancyInfoResponse);
		((_ns1__InPeccancyInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__InPeccancyInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__InPeccancyInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__InPeccancyInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__InPeccancyInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__InPeccancyInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__InPeccancyInfoResponse %p -> %p\n", q, p));
	*(_ns1__InPeccancyInfoResponse*)p = *(_ns1__InPeccancyInfoResponse*)q;
}

void _ns1__InPeccancyInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__InPeccancyInfo::xmlBody);
	/* transient soap skipped */
}

void _ns1__InPeccancyInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__InPeccancyInfo::xmlBody);
	/* transient soap skipped */
#endif
}

int _ns1__InPeccancyInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InPeccancyInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InPeccancyInfo(struct soap *soap, const char *tag, int id, const _ns1__InPeccancyInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InPeccancyInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xmlBody", -1, &(a->_ns1__InPeccancyInfo::xmlBody), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__InPeccancyInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InPeccancyInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InPeccancyInfo * SOAP_FMAC4 soap_in__ns1__InPeccancyInfo(struct soap *soap, const char *tag, _ns1__InPeccancyInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InPeccancyInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InPeccancyInfo, sizeof(_ns1__InPeccancyInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__InPeccancyInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__InPeccancyInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlBody1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlBody1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:xmlBody", &(a->_ns1__InPeccancyInfo::xmlBody), "xsd:string"))
				{	soap_flag_xmlBody1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InPeccancyInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InPeccancyInfo, 0, sizeof(_ns1__InPeccancyInfo), 0, soap_copy__ns1__InPeccancyInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__InPeccancyInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__InPeccancyInfo);
	if (this->soap_out(soap, tag?tag:"ns1:InPeccancyInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InPeccancyInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InPeccancyInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InPeccancyInfo * SOAP_FMAC4 soap_get__ns1__InPeccancyInfo(struct soap *soap, _ns1__InPeccancyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InPeccancyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__InPeccancyInfo * SOAP_FMAC2 soap_instantiate__ns1__InPeccancyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InPeccancyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__InPeccancyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__InPeccancyInfo);
		if (size)
			*size = sizeof(_ns1__InPeccancyInfo);
		((_ns1__InPeccancyInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__InPeccancyInfo, n);
		if (size)
			*size = n * sizeof(_ns1__InPeccancyInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__InPeccancyInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__InPeccancyInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__InPeccancyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__InPeccancyInfo %p -> %p\n", q, p));
	*(_ns1__InPeccancyInfo*)p = *(_ns1__InPeccancyInfo*)q;
}

void _ns1__InPassCarInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__InPassCarInfoResponse::InPassCarInfoResult);
	/* transient soap skipped */
}

void _ns1__InPassCarInfoResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__InPassCarInfoResponse::InPassCarInfoResult);
	/* transient soap skipped */
#endif
}

int _ns1__InPassCarInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InPassCarInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InPassCarInfoResponse(struct soap *soap, const char *tag, int id, const _ns1__InPassCarInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InPassCarInfoResponse), type))
		return soap->error;
	if (a->InPassCarInfoResult)
		soap_element_result(soap, "ns1:InPassCarInfoResult");
	if (soap_out_string(soap, "ns1:InPassCarInfoResult", -1, &(a->_ns1__InPassCarInfoResponse::InPassCarInfoResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__InPassCarInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InPassCarInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InPassCarInfoResponse * SOAP_FMAC4 soap_in__ns1__InPassCarInfoResponse(struct soap *soap, const char *tag, _ns1__InPassCarInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InPassCarInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InPassCarInfoResponse, sizeof(_ns1__InPassCarInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__InPassCarInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__InPassCarInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_InPassCarInfoResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InPassCarInfoResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:InPassCarInfoResult", &(a->_ns1__InPassCarInfoResponse::InPassCarInfoResult), "xsd:string"))
				{	soap_flag_InPassCarInfoResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:InPassCarInfoResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InPassCarInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InPassCarInfoResponse, 0, sizeof(_ns1__InPassCarInfoResponse), 0, soap_copy__ns1__InPassCarInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__InPassCarInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__InPassCarInfoResponse);
	if (this->soap_out(soap, tag?tag:"ns1:InPassCarInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InPassCarInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InPassCarInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InPassCarInfoResponse * SOAP_FMAC4 soap_get__ns1__InPassCarInfoResponse(struct soap *soap, _ns1__InPassCarInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InPassCarInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__InPassCarInfoResponse * SOAP_FMAC2 soap_instantiate__ns1__InPassCarInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InPassCarInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__InPassCarInfoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__InPassCarInfoResponse);
		if (size)
			*size = sizeof(_ns1__InPassCarInfoResponse);
		((_ns1__InPassCarInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__InPassCarInfoResponse, n);
		if (size)
			*size = n * sizeof(_ns1__InPassCarInfoResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__InPassCarInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__InPassCarInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__InPassCarInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__InPassCarInfoResponse %p -> %p\n", q, p));
	*(_ns1__InPassCarInfoResponse*)p = *(_ns1__InPassCarInfoResponse*)q;
}

void _ns1__InPassCarInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__InPassCarInfo::xmlBody);
	/* transient soap skipped */
}

void _ns1__InPassCarInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__InPassCarInfo::xmlBody);
	/* transient soap skipped */
#endif
}

int _ns1__InPassCarInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__InPassCarInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__InPassCarInfo(struct soap *soap, const char *tag, int id, const _ns1__InPassCarInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__InPassCarInfo), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xmlBody", -1, &(a->_ns1__InPassCarInfo::xmlBody), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__InPassCarInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__InPassCarInfo(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__InPassCarInfo * SOAP_FMAC4 soap_in__ns1__InPassCarInfo(struct soap *soap, const char *tag, _ns1__InPassCarInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__InPassCarInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__InPassCarInfo, sizeof(_ns1__InPassCarInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__InPassCarInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__InPassCarInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlBody1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlBody1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:xmlBody", &(a->_ns1__InPassCarInfo::xmlBody), "xsd:string"))
				{	soap_flag_xmlBody1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__InPassCarInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__InPassCarInfo, 0, sizeof(_ns1__InPassCarInfo), 0, soap_copy__ns1__InPassCarInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__InPassCarInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__InPassCarInfo);
	if (this->soap_out(soap, tag?tag:"ns1:InPassCarInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__InPassCarInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__InPassCarInfo(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__InPassCarInfo * SOAP_FMAC4 soap_get__ns1__InPassCarInfo(struct soap *soap, _ns1__InPassCarInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__InPassCarInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__InPassCarInfo * SOAP_FMAC2 soap_instantiate__ns1__InPassCarInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__InPassCarInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__InPassCarInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__InPassCarInfo);
		if (size)
			*size = sizeof(_ns1__InPassCarInfo);
		((_ns1__InPassCarInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__InPassCarInfo, n);
		if (size)
			*size = n * sizeof(_ns1__InPassCarInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__InPassCarInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__InPassCarInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__InPassCarInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__InPassCarInfo %p -> %p\n", q, p));
	*(_ns1__InPassCarInfo*)p = *(_ns1__InPassCarInfo*)q;
}

void _ns1__CarPlateRecogResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__CarPlateRecogResponse::CarPlateRecogResult);
	/* transient soap skipped */
}

void _ns1__CarPlateRecogResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__CarPlateRecogResponse::CarPlateRecogResult);
	/* transient soap skipped */
#endif
}

int _ns1__CarPlateRecogResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CarPlateRecogResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CarPlateRecogResponse(struct soap *soap, const char *tag, int id, const _ns1__CarPlateRecogResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CarPlateRecogResponse), type))
		return soap->error;
	if (a->CarPlateRecogResult)
		soap_element_result(soap, "ns1:CarPlateRecogResult");
	if (soap_out_string(soap, "ns1:CarPlateRecogResult", -1, &(a->_ns1__CarPlateRecogResponse::CarPlateRecogResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__CarPlateRecogResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CarPlateRecogResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CarPlateRecogResponse * SOAP_FMAC4 soap_in__ns1__CarPlateRecogResponse(struct soap *soap, const char *tag, _ns1__CarPlateRecogResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CarPlateRecogResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CarPlateRecogResponse, sizeof(_ns1__CarPlateRecogResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__CarPlateRecogResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__CarPlateRecogResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CarPlateRecogResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CarPlateRecogResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:CarPlateRecogResult", &(a->_ns1__CarPlateRecogResponse::CarPlateRecogResult), "xsd:string"))
				{	soap_flag_CarPlateRecogResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:CarPlateRecogResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CarPlateRecogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CarPlateRecogResponse, 0, sizeof(_ns1__CarPlateRecogResponse), 0, soap_copy__ns1__CarPlateRecogResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__CarPlateRecogResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__CarPlateRecogResponse);
	if (this->soap_out(soap, tag?tag:"ns1:CarPlateRecogResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CarPlateRecogResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CarPlateRecogResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CarPlateRecogResponse * SOAP_FMAC4 soap_get__ns1__CarPlateRecogResponse(struct soap *soap, _ns1__CarPlateRecogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CarPlateRecogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__CarPlateRecogResponse * SOAP_FMAC2 soap_instantiate__ns1__CarPlateRecogResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CarPlateRecogResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__CarPlateRecogResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__CarPlateRecogResponse);
		if (size)
			*size = sizeof(_ns1__CarPlateRecogResponse);
		((_ns1__CarPlateRecogResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__CarPlateRecogResponse, n);
		if (size)
			*size = n * sizeof(_ns1__CarPlateRecogResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__CarPlateRecogResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__CarPlateRecogResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__CarPlateRecogResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__CarPlateRecogResponse %p -> %p\n", q, p));
	*(_ns1__CarPlateRecogResponse*)p = *(_ns1__CarPlateRecogResponse*)q;
}

void _ns1__CarPlateRecog::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__CarPlateRecog::xmlBody);
	/* transient soap skipped */
}

void _ns1__CarPlateRecog::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__CarPlateRecog::xmlBody);
	/* transient soap skipped */
#endif
}

int _ns1__CarPlateRecog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CarPlateRecog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CarPlateRecog(struct soap *soap, const char *tag, int id, const _ns1__CarPlateRecog *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CarPlateRecog), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:xmlBody", -1, &(a->_ns1__CarPlateRecog::xmlBody), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__CarPlateRecog::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CarPlateRecog(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CarPlateRecog * SOAP_FMAC4 soap_in__ns1__CarPlateRecog(struct soap *soap, const char *tag, _ns1__CarPlateRecog *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CarPlateRecog *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CarPlateRecog, sizeof(_ns1__CarPlateRecog), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__CarPlateRecog)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__CarPlateRecog *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_xmlBody1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xmlBody1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:xmlBody", &(a->_ns1__CarPlateRecog::xmlBody), "xsd:string"))
				{	soap_flag_xmlBody1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CarPlateRecog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CarPlateRecog, 0, sizeof(_ns1__CarPlateRecog), 0, soap_copy__ns1__CarPlateRecog);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__CarPlateRecog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__CarPlateRecog);
	if (this->soap_out(soap, tag?tag:"ns1:CarPlateRecog", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CarPlateRecog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CarPlateRecog(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CarPlateRecog * SOAP_FMAC4 soap_get__ns1__CarPlateRecog(struct soap *soap, _ns1__CarPlateRecog *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CarPlateRecog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__CarPlateRecog * SOAP_FMAC2 soap_instantiate__ns1__CarPlateRecog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CarPlateRecog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__CarPlateRecog, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__CarPlateRecog);
		if (size)
			*size = sizeof(_ns1__CarPlateRecog);
		((_ns1__CarPlateRecog*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__CarPlateRecog, n);
		if (size)
			*size = n * sizeof(_ns1__CarPlateRecog);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__CarPlateRecog*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__CarPlateRecog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__CarPlateRecog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__CarPlateRecog %p -> %p\n", q, p));
	*(_ns1__CarPlateRecog*)p = *(_ns1__CarPlateRecog*)q;
}

void _ns1__GetXMlFormatResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetXMlFormatResponse::GetXMlFormatResult);
	/* transient soap skipped */
}

void _ns1__GetXMlFormatResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetXMlFormatResponse::GetXMlFormatResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetXMlFormatResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetXMlFormatResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetXMlFormatResponse(struct soap *soap, const char *tag, int id, const _ns1__GetXMlFormatResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetXMlFormatResponse), type))
		return soap->error;
	if (a->GetXMlFormatResult)
		soap_element_result(soap, "ns1:GetXMlFormatResult");
	if (soap_out_string(soap, "ns1:GetXMlFormatResult", -1, &(a->_ns1__GetXMlFormatResponse::GetXMlFormatResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetXMlFormatResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetXMlFormatResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetXMlFormatResponse * SOAP_FMAC4 soap_in__ns1__GetXMlFormatResponse(struct soap *soap, const char *tag, _ns1__GetXMlFormatResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetXMlFormatResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetXMlFormatResponse, sizeof(_ns1__GetXMlFormatResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetXMlFormatResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetXMlFormatResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetXMlFormatResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetXMlFormatResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:GetXMlFormatResult", &(a->_ns1__GetXMlFormatResponse::GetXMlFormatResult), "xsd:string"))
				{	soap_flag_GetXMlFormatResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetXMlFormatResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetXMlFormatResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetXMlFormatResponse, 0, sizeof(_ns1__GetXMlFormatResponse), 0, soap_copy__ns1__GetXMlFormatResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetXMlFormatResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetXMlFormatResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetXMlFormatResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetXMlFormatResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetXMlFormatResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetXMlFormatResponse * SOAP_FMAC4 soap_get__ns1__GetXMlFormatResponse(struct soap *soap, _ns1__GetXMlFormatResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetXMlFormatResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetXMlFormatResponse * SOAP_FMAC2 soap_instantiate__ns1__GetXMlFormatResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetXMlFormatResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetXMlFormatResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetXMlFormatResponse);
		if (size)
			*size = sizeof(_ns1__GetXMlFormatResponse);
		((_ns1__GetXMlFormatResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetXMlFormatResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetXMlFormatResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetXMlFormatResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetXMlFormatResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetXMlFormatResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetXMlFormatResponse %p -> %p\n", q, p));
	*(_ns1__GetXMlFormatResponse*)p = *(_ns1__GetXMlFormatResponse*)q;
}

void _ns1__GetXMlFormat::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetXMlFormat::systemType);
	soap_default_string(soap, &this->_ns1__GetXMlFormat::iVersion);
	/* transient soap skipped */
}

void _ns1__GetXMlFormat::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetXMlFormat::systemType);
	soap_serialize_string(soap, &this->_ns1__GetXMlFormat::iVersion);
	/* transient soap skipped */
#endif
}

int _ns1__GetXMlFormat::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetXMlFormat(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetXMlFormat(struct soap *soap, const char *tag, int id, const _ns1__GetXMlFormat *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetXMlFormat), type))
		return soap->error;
	if (soap_out_string(soap, "ns1:systemType", -1, &(a->_ns1__GetXMlFormat::systemType), ""))
		return soap->error;
	if (soap_out_string(soap, "ns1:iVersion", -1, &(a->_ns1__GetXMlFormat::iVersion), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetXMlFormat::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetXMlFormat(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetXMlFormat * SOAP_FMAC4 soap_in__ns1__GetXMlFormat(struct soap *soap, const char *tag, _ns1__GetXMlFormat *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetXMlFormat *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetXMlFormat, sizeof(_ns1__GetXMlFormat), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetXMlFormat)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetXMlFormat *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_systemType1 = 1;
	size_t soap_flag_iVersion1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_systemType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:systemType", &(a->_ns1__GetXMlFormat::systemType), "xsd:string"))
				{	soap_flag_systemType1--;
					continue;
				}
			if (soap_flag_iVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:iVersion", &(a->_ns1__GetXMlFormat::iVersion), "xsd:string"))
				{	soap_flag_iVersion1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetXMlFormat *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetXMlFormat, 0, sizeof(_ns1__GetXMlFormat), 0, soap_copy__ns1__GetXMlFormat);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetXMlFormat::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetXMlFormat);
	if (this->soap_out(soap, tag?tag:"ns1:GetXMlFormat", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetXMlFormat::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetXMlFormat(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetXMlFormat * SOAP_FMAC4 soap_get__ns1__GetXMlFormat(struct soap *soap, _ns1__GetXMlFormat *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetXMlFormat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetXMlFormat * SOAP_FMAC2 soap_instantiate__ns1__GetXMlFormat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetXMlFormat(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetXMlFormat, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetXMlFormat);
		if (size)
			*size = sizeof(_ns1__GetXMlFormat);
		((_ns1__GetXMlFormat*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetXMlFormat, n);
		if (size)
			*size = n * sizeof(_ns1__GetXMlFormat);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetXMlFormat*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetXMlFormat*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetXMlFormat(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetXMlFormat %p -> %p\n", q, p));
	*(_ns1__GetXMlFormat*)p = *(_ns1__GetXMlFormat*)q;
}

void _ns1__GetCurrentVersionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__GetCurrentVersionResponse::GetCurrentVersionResult);
	/* transient soap skipped */
}

void _ns1__GetCurrentVersionResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__GetCurrentVersionResponse::GetCurrentVersionResult);
	/* transient soap skipped */
#endif
}

int _ns1__GetCurrentVersionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetCurrentVersionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetCurrentVersionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetCurrentVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetCurrentVersionResponse), type))
		return soap->error;
	if (a->GetCurrentVersionResult)
		soap_element_result(soap, "ns1:GetCurrentVersionResult");
	if (soap_out_string(soap, "ns1:GetCurrentVersionResult", -1, &(a->_ns1__GetCurrentVersionResponse::GetCurrentVersionResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetCurrentVersionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetCurrentVersionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetCurrentVersionResponse * SOAP_FMAC4 soap_in__ns1__GetCurrentVersionResponse(struct soap *soap, const char *tag, _ns1__GetCurrentVersionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetCurrentVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetCurrentVersionResponse, sizeof(_ns1__GetCurrentVersionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetCurrentVersionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetCurrentVersionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_GetCurrentVersionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetCurrentVersionResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:GetCurrentVersionResult", &(a->_ns1__GetCurrentVersionResponse::GetCurrentVersionResult), "xsd:string"))
				{	soap_flag_GetCurrentVersionResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:GetCurrentVersionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetCurrentVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetCurrentVersionResponse, 0, sizeof(_ns1__GetCurrentVersionResponse), 0, soap_copy__ns1__GetCurrentVersionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetCurrentVersionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetCurrentVersionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:GetCurrentVersionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetCurrentVersionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetCurrentVersionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetCurrentVersionResponse * SOAP_FMAC4 soap_get__ns1__GetCurrentVersionResponse(struct soap *soap, _ns1__GetCurrentVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetCurrentVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetCurrentVersionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetCurrentVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetCurrentVersionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetCurrentVersionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetCurrentVersionResponse);
		if (size)
			*size = sizeof(_ns1__GetCurrentVersionResponse);
		((_ns1__GetCurrentVersionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetCurrentVersionResponse, n);
		if (size)
			*size = n * sizeof(_ns1__GetCurrentVersionResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetCurrentVersionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetCurrentVersionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetCurrentVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetCurrentVersionResponse %p -> %p\n", q, p));
	*(_ns1__GetCurrentVersionResponse*)p = *(_ns1__GetCurrentVersionResponse*)q;
}

void _ns1__GetCurrentVersion::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetCurrentVersion::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns1__GetCurrentVersion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetCurrentVersion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetCurrentVersion(struct soap *soap, const char *tag, int id, const _ns1__GetCurrentVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetCurrentVersion), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetCurrentVersion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetCurrentVersion(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetCurrentVersion * SOAP_FMAC4 soap_in__ns1__GetCurrentVersion(struct soap *soap, const char *tag, _ns1__GetCurrentVersion *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetCurrentVersion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetCurrentVersion, sizeof(_ns1__GetCurrentVersion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__GetCurrentVersion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__GetCurrentVersion *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetCurrentVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetCurrentVersion, 0, sizeof(_ns1__GetCurrentVersion), 0, soap_copy__ns1__GetCurrentVersion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__GetCurrentVersion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__GetCurrentVersion);
	if (this->soap_out(soap, tag?tag:"ns1:GetCurrentVersion", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetCurrentVersion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetCurrentVersion(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetCurrentVersion * SOAP_FMAC4 soap_get__ns1__GetCurrentVersion(struct soap *soap, _ns1__GetCurrentVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetCurrentVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__GetCurrentVersion * SOAP_FMAC2 soap_instantiate__ns1__GetCurrentVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetCurrentVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__GetCurrentVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__GetCurrentVersion);
		if (size)
			*size = sizeof(_ns1__GetCurrentVersion);
		((_ns1__GetCurrentVersion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__GetCurrentVersion, n);
		if (size)
			*size = n * sizeof(_ns1__GetCurrentVersion);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__GetCurrentVersion*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__GetCurrentVersion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__GetCurrentVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__GetCurrentVersion %p -> %p\n", q, p));
	*(_ns1__GetCurrentVersion*)p = *(_ns1__GetCurrentVersion*)q;
}

void _ns1__WebserviceTestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->_ns1__WebserviceTestResponse::WebserviceTestResult);
	/* transient soap skipped */
}

void _ns1__WebserviceTestResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->_ns1__WebserviceTestResponse::WebserviceTestResult);
	/* transient soap skipped */
#endif
}

int _ns1__WebserviceTestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__WebserviceTestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__WebserviceTestResponse(struct soap *soap, const char *tag, int id, const _ns1__WebserviceTestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__WebserviceTestResponse), type))
		return soap->error;
	if (a->WebserviceTestResult)
		soap_element_result(soap, "ns1:WebserviceTestResult");
	if (soap_out_string(soap, "ns1:WebserviceTestResult", -1, &(a->_ns1__WebserviceTestResponse::WebserviceTestResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__WebserviceTestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__WebserviceTestResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__WebserviceTestResponse * SOAP_FMAC4 soap_in__ns1__WebserviceTestResponse(struct soap *soap, const char *tag, _ns1__WebserviceTestResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__WebserviceTestResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__WebserviceTestResponse, sizeof(_ns1__WebserviceTestResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__WebserviceTestResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__WebserviceTestResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_WebserviceTestResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WebserviceTestResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns1:WebserviceTestResult", &(a->_ns1__WebserviceTestResponse::WebserviceTestResult), "xsd:string"))
				{	soap_flag_WebserviceTestResult1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "ns1:WebserviceTestResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__WebserviceTestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__WebserviceTestResponse, 0, sizeof(_ns1__WebserviceTestResponse), 0, soap_copy__ns1__WebserviceTestResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__WebserviceTestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__WebserviceTestResponse);
	if (this->soap_out(soap, tag?tag:"ns1:WebserviceTestResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__WebserviceTestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__WebserviceTestResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__WebserviceTestResponse * SOAP_FMAC4 soap_get__ns1__WebserviceTestResponse(struct soap *soap, _ns1__WebserviceTestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__WebserviceTestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__WebserviceTestResponse * SOAP_FMAC2 soap_instantiate__ns1__WebserviceTestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__WebserviceTestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__WebserviceTestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__WebserviceTestResponse);
		if (size)
			*size = sizeof(_ns1__WebserviceTestResponse);
		((_ns1__WebserviceTestResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__WebserviceTestResponse, n);
		if (size)
			*size = n * sizeof(_ns1__WebserviceTestResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__WebserviceTestResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__WebserviceTestResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__WebserviceTestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__WebserviceTestResponse %p -> %p\n", q, p));
	*(_ns1__WebserviceTestResponse*)p = *(_ns1__WebserviceTestResponse*)q;
}

void _ns1__WebserviceTest::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__WebserviceTest::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _ns1__WebserviceTest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__WebserviceTest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__WebserviceTest(struct soap *soap, const char *tag, int id, const _ns1__WebserviceTest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__WebserviceTest), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__WebserviceTest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__WebserviceTest(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__WebserviceTest * SOAP_FMAC4 soap_in__ns1__WebserviceTest(struct soap *soap, const char *tag, _ns1__WebserviceTest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__WebserviceTest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__WebserviceTest, sizeof(_ns1__WebserviceTest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__WebserviceTest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__WebserviceTest *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__WebserviceTest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__WebserviceTest, 0, sizeof(_ns1__WebserviceTest), 0, soap_copy__ns1__WebserviceTest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _ns1__WebserviceTest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__WebserviceTest);
	if (this->soap_out(soap, tag?tag:"ns1:WebserviceTest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__WebserviceTest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__WebserviceTest(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__WebserviceTest * SOAP_FMAC4 soap_get__ns1__WebserviceTest(struct soap *soap, _ns1__WebserviceTest *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__WebserviceTest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _ns1__WebserviceTest * SOAP_FMAC2 soap_instantiate__ns1__WebserviceTest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__WebserviceTest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__WebserviceTest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_ns1__WebserviceTest);
		if (size)
			*size = sizeof(_ns1__WebserviceTest);
		((_ns1__WebserviceTest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_ns1__WebserviceTest, n);
		if (size)
			*size = n * sizeof(_ns1__WebserviceTest);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_ns1__WebserviceTest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_ns1__WebserviceTest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__WebserviceTest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__WebserviceTest %p -> %p\n", q, p));
	*(_ns1__WebserviceTest*)p = *(_ns1__WebserviceTest*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CheckUserInfo_(struct soap *soap, struct __ns1__CheckUserInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CheckUserInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CheckUserInfo_(struct soap *soap, const struct __ns1__CheckUserInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__CheckUserInfo(soap, &a->ns1__CheckUserInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CheckUserInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__CheckUserInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__CheckUserInfo(soap, "ns1:CheckUserInfo", -1, &a->ns1__CheckUserInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckUserInfo_ * SOAP_FMAC4 soap_in___ns1__CheckUserInfo_(struct soap *soap, const char *tag, struct __ns1__CheckUserInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__CheckUserInfo = 1;
	short soap_flag;
	a = (struct __ns1__CheckUserInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CheckUserInfo_, sizeof(struct __ns1__CheckUserInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CheckUserInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CheckUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CheckUserInfo(soap, "ns1:CheckUserInfo", &a->ns1__CheckUserInfo, ""))
				{	soap_flag_ns1__CheckUserInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CheckUserInfo_(struct soap *soap, const struct __ns1__CheckUserInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__CheckUserInfo_(soap, tag?tag:"-ns1:CheckUserInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckUserInfo_ * SOAP_FMAC4 soap_get___ns1__CheckUserInfo_(struct soap *soap, struct __ns1__CheckUserInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CheckUserInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__CheckUserInfo_ * SOAP_FMAC2 soap_instantiate___ns1__CheckUserInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CheckUserInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__CheckUserInfo_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__CheckUserInfo_);
		if (size)
			*size = sizeof(struct __ns1__CheckUserInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__CheckUserInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__CheckUserInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__CheckUserInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__CheckUserInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__CheckUserInfo_ %p -> %p\n", q, p));
	*(struct __ns1__CheckUserInfo_*)p = *(struct __ns1__CheckUserInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addTransRecInfo_(struct soap *soap, struct __ns1__addTransRecInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addTransRecInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addTransRecInfo_(struct soap *soap, const struct __ns1__addTransRecInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__addTransRecInfo(soap, &a->ns1__addTransRecInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addTransRecInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__addTransRecInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__addTransRecInfo(soap, "ns1:addTransRecInfo", -1, &a->ns1__addTransRecInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addTransRecInfo_ * SOAP_FMAC4 soap_in___ns1__addTransRecInfo_(struct soap *soap, const char *tag, struct __ns1__addTransRecInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__addTransRecInfo = 1;
	short soap_flag;
	a = (struct __ns1__addTransRecInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addTransRecInfo_, sizeof(struct __ns1__addTransRecInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addTransRecInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addTransRecInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__addTransRecInfo(soap, "ns1:addTransRecInfo", &a->ns1__addTransRecInfo, ""))
				{	soap_flag_ns1__addTransRecInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addTransRecInfo_(struct soap *soap, const struct __ns1__addTransRecInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addTransRecInfo_(soap, tag?tag:"-ns1:addTransRecInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addTransRecInfo_ * SOAP_FMAC4 soap_get___ns1__addTransRecInfo_(struct soap *soap, struct __ns1__addTransRecInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addTransRecInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__addTransRecInfo_ * SOAP_FMAC2 soap_instantiate___ns1__addTransRecInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addTransRecInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__addTransRecInfo_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addTransRecInfo_);
		if (size)
			*size = sizeof(struct __ns1__addTransRecInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__addTransRecInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__addTransRecInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__addTransRecInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__addTransRecInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__addTransRecInfo_ %p -> %p\n", q, p));
	*(struct __ns1__addTransRecInfo_*)p = *(struct __ns1__addTransRecInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetJdsbhRecoveryInfo_(struct soap *soap, struct __ns1__GetJdsbhRecoveryInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetJdsbhRecoveryInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetJdsbhRecoveryInfo_(struct soap *soap, const struct __ns1__GetJdsbhRecoveryInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetJdsbhRecoveryInfo(soap, &a->ns1__GetJdsbhRecoveryInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetJdsbhRecoveryInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__GetJdsbhRecoveryInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetJdsbhRecoveryInfo(soap, "ns1:GetJdsbhRecoveryInfo", -1, &a->ns1__GetJdsbhRecoveryInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetJdsbhRecoveryInfo_ * SOAP_FMAC4 soap_in___ns1__GetJdsbhRecoveryInfo_(struct soap *soap, const char *tag, struct __ns1__GetJdsbhRecoveryInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__GetJdsbhRecoveryInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetJdsbhRecoveryInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetJdsbhRecoveryInfo_, sizeof(struct __ns1__GetJdsbhRecoveryInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetJdsbhRecoveryInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetJdsbhRecoveryInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetJdsbhRecoveryInfo(soap, "ns1:GetJdsbhRecoveryInfo", &a->ns1__GetJdsbhRecoveryInfo, ""))
				{	soap_flag_ns1__GetJdsbhRecoveryInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetJdsbhRecoveryInfo_(struct soap *soap, const struct __ns1__GetJdsbhRecoveryInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetJdsbhRecoveryInfo_(soap, tag?tag:"-ns1:GetJdsbhRecoveryInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetJdsbhRecoveryInfo_ * SOAP_FMAC4 soap_get___ns1__GetJdsbhRecoveryInfo_(struct soap *soap, struct __ns1__GetJdsbhRecoveryInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetJdsbhRecoveryInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetJdsbhRecoveryInfo_ * SOAP_FMAC2 soap_instantiate___ns1__GetJdsbhRecoveryInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetJdsbhRecoveryInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetJdsbhRecoveryInfo_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetJdsbhRecoveryInfo_);
		if (size)
			*size = sizeof(struct __ns1__GetJdsbhRecoveryInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetJdsbhRecoveryInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetJdsbhRecoveryInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetJdsbhRecoveryInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetJdsbhRecoveryInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetJdsbhRecoveryInfo_ %p -> %p\n", q, p));
	*(struct __ns1__GetJdsbhRecoveryInfo_*)p = *(struct __ns1__GetJdsbhRecoveryInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetJdsbhRecovery_(struct soap *soap, struct __ns1__GetJdsbhRecovery_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetJdsbhRecovery = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetJdsbhRecovery_(struct soap *soap, const struct __ns1__GetJdsbhRecovery_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetJdsbhRecovery(soap, &a->ns1__GetJdsbhRecovery);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetJdsbhRecovery_(struct soap *soap, const char *tag, int id, const struct __ns1__GetJdsbhRecovery_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetJdsbhRecovery(soap, "ns1:GetJdsbhRecovery", -1, &a->ns1__GetJdsbhRecovery, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetJdsbhRecovery_ * SOAP_FMAC4 soap_in___ns1__GetJdsbhRecovery_(struct soap *soap, const char *tag, struct __ns1__GetJdsbhRecovery_ *a, const char *type)
{
	size_t soap_flag_ns1__GetJdsbhRecovery = 1;
	short soap_flag;
	a = (struct __ns1__GetJdsbhRecovery_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetJdsbhRecovery_, sizeof(struct __ns1__GetJdsbhRecovery_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetJdsbhRecovery_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetJdsbhRecovery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetJdsbhRecovery(soap, "ns1:GetJdsbhRecovery", &a->ns1__GetJdsbhRecovery, ""))
				{	soap_flag_ns1__GetJdsbhRecovery--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetJdsbhRecovery_(struct soap *soap, const struct __ns1__GetJdsbhRecovery_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetJdsbhRecovery_(soap, tag?tag:"-ns1:GetJdsbhRecovery", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetJdsbhRecovery_ * SOAP_FMAC4 soap_get___ns1__GetJdsbhRecovery_(struct soap *soap, struct __ns1__GetJdsbhRecovery_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetJdsbhRecovery_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetJdsbhRecovery_ * SOAP_FMAC2 soap_instantiate___ns1__GetJdsbhRecovery_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetJdsbhRecovery_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetJdsbhRecovery_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetJdsbhRecovery_);
		if (size)
			*size = sizeof(struct __ns1__GetJdsbhRecovery_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetJdsbhRecovery_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetJdsbhRecovery_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetJdsbhRecovery_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetJdsbhRecovery_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetJdsbhRecovery_ %p -> %p\n", q, p));
	*(struct __ns1__GetJdsbhRecovery_*)p = *(struct __ns1__GetJdsbhRecovery_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetViolationInfo_(struct soap *soap, struct __ns1__GetViolationInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetViolationInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetViolationInfo_(struct soap *soap, const struct __ns1__GetViolationInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetViolationInfo(soap, &a->ns1__GetViolationInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetViolationInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__GetViolationInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetViolationInfo(soap, "ns1:GetViolationInfo", -1, &a->ns1__GetViolationInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetViolationInfo_ * SOAP_FMAC4 soap_in___ns1__GetViolationInfo_(struct soap *soap, const char *tag, struct __ns1__GetViolationInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__GetViolationInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetViolationInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetViolationInfo_, sizeof(struct __ns1__GetViolationInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetViolationInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetViolationInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetViolationInfo(soap, "ns1:GetViolationInfo", &a->ns1__GetViolationInfo, ""))
				{	soap_flag_ns1__GetViolationInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetViolationInfo_(struct soap *soap, const struct __ns1__GetViolationInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetViolationInfo_(soap, tag?tag:"-ns1:GetViolationInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetViolationInfo_ * SOAP_FMAC4 soap_get___ns1__GetViolationInfo_(struct soap *soap, struct __ns1__GetViolationInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetViolationInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetViolationInfo_ * SOAP_FMAC2 soap_instantiate___ns1__GetViolationInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetViolationInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetViolationInfo_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetViolationInfo_);
		if (size)
			*size = sizeof(struct __ns1__GetViolationInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetViolationInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetViolationInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetViolationInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetViolationInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetViolationInfo_ %p -> %p\n", q, p));
	*(struct __ns1__GetViolationInfo_*)p = *(struct __ns1__GetViolationInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InViolationInfo_(struct soap *soap, struct __ns1__InViolationInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InViolationInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InViolationInfo_(struct soap *soap, const struct __ns1__InViolationInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__InViolationInfo(soap, &a->ns1__InViolationInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InViolationInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__InViolationInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__InViolationInfo(soap, "ns1:InViolationInfo", -1, &a->ns1__InViolationInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InViolationInfo_ * SOAP_FMAC4 soap_in___ns1__InViolationInfo_(struct soap *soap, const char *tag, struct __ns1__InViolationInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__InViolationInfo = 1;
	short soap_flag;
	a = (struct __ns1__InViolationInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InViolationInfo_, sizeof(struct __ns1__InViolationInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InViolationInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InViolationInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__InViolationInfo(soap, "ns1:InViolationInfo", &a->ns1__InViolationInfo, ""))
				{	soap_flag_ns1__InViolationInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InViolationInfo_(struct soap *soap, const struct __ns1__InViolationInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__InViolationInfo_(soap, tag?tag:"-ns1:InViolationInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InViolationInfo_ * SOAP_FMAC4 soap_get___ns1__InViolationInfo_(struct soap *soap, struct __ns1__InViolationInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InViolationInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__InViolationInfo_ * SOAP_FMAC2 soap_instantiate___ns1__InViolationInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InViolationInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__InViolationInfo_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__InViolationInfo_);
		if (size)
			*size = sizeof(struct __ns1__InViolationInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__InViolationInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__InViolationInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__InViolationInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__InViolationInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__InViolationInfo_ %p -> %p\n", q, p));
	*(struct __ns1__InViolationInfo_*)p = *(struct __ns1__InViolationInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdataDeviceState_(struct soap *soap, struct __ns1__UpdataDeviceState_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdataDeviceState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdataDeviceState_(struct soap *soap, const struct __ns1__UpdataDeviceState_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UpdataDeviceState(soap, &a->ns1__UpdataDeviceState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdataDeviceState_(struct soap *soap, const char *tag, int id, const struct __ns1__UpdataDeviceState_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__UpdataDeviceState(soap, "ns1:UpdataDeviceState", -1, &a->ns1__UpdataDeviceState, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdataDeviceState_ * SOAP_FMAC4 soap_in___ns1__UpdataDeviceState_(struct soap *soap, const char *tag, struct __ns1__UpdataDeviceState_ *a, const char *type)
{
	size_t soap_flag_ns1__UpdataDeviceState = 1;
	short soap_flag;
	a = (struct __ns1__UpdataDeviceState_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpdataDeviceState_, sizeof(struct __ns1__UpdataDeviceState_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdataDeviceState_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdataDeviceState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdataDeviceState(soap, "ns1:UpdataDeviceState", &a->ns1__UpdataDeviceState, ""))
				{	soap_flag_ns1__UpdataDeviceState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdataDeviceState_(struct soap *soap, const struct __ns1__UpdataDeviceState_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__UpdataDeviceState_(soap, tag?tag:"-ns1:UpdataDeviceState", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdataDeviceState_ * SOAP_FMAC4 soap_get___ns1__UpdataDeviceState_(struct soap *soap, struct __ns1__UpdataDeviceState_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdataDeviceState_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__UpdataDeviceState_ * SOAP_FMAC2 soap_instantiate___ns1__UpdataDeviceState_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdataDeviceState_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UpdataDeviceState_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__UpdataDeviceState_);
		if (size)
			*size = sizeof(struct __ns1__UpdataDeviceState_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__UpdataDeviceState_, n);
		if (size)
			*size = n * sizeof(struct __ns1__UpdataDeviceState_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__UpdataDeviceState_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UpdataDeviceState_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UpdataDeviceState_ %p -> %p\n", q, p));
	*(struct __ns1__UpdataDeviceState_*)p = *(struct __ns1__UpdataDeviceState_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAlarmInfo_(struct soap *soap, struct __ns1__GetAlarmInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAlarmInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAlarmInfo_(struct soap *soap, const struct __ns1__GetAlarmInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetAlarmInfo(soap, &a->ns1__GetAlarmInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAlarmInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__GetAlarmInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetAlarmInfo(soap, "ns1:GetAlarmInfo", -1, &a->ns1__GetAlarmInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAlarmInfo_ * SOAP_FMAC4 soap_in___ns1__GetAlarmInfo_(struct soap *soap, const char *tag, struct __ns1__GetAlarmInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__GetAlarmInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetAlarmInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAlarmInfo_, sizeof(struct __ns1__GetAlarmInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAlarmInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAlarmInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAlarmInfo(soap, "ns1:GetAlarmInfo", &a->ns1__GetAlarmInfo, ""))
				{	soap_flag_ns1__GetAlarmInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAlarmInfo_(struct soap *soap, const struct __ns1__GetAlarmInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetAlarmInfo_(soap, tag?tag:"-ns1:GetAlarmInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAlarmInfo_ * SOAP_FMAC4 soap_get___ns1__GetAlarmInfo_(struct soap *soap, struct __ns1__GetAlarmInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAlarmInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetAlarmInfo_ * SOAP_FMAC2 soap_instantiate___ns1__GetAlarmInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAlarmInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetAlarmInfo_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetAlarmInfo_);
		if (size)
			*size = sizeof(struct __ns1__GetAlarmInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetAlarmInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetAlarmInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetAlarmInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetAlarmInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetAlarmInfo_ %p -> %p\n", q, p));
	*(struct __ns1__GetAlarmInfo_*)p = *(struct __ns1__GetAlarmInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdateVioPeccancyInfo_(struct soap *soap, struct __ns1__UpdateVioPeccancyInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateVioPeccancyInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdateVioPeccancyInfo_(struct soap *soap, const struct __ns1__UpdateVioPeccancyInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UpdateVioPeccancyInfo(soap, &a->ns1__UpdateVioPeccancyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdateVioPeccancyInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__UpdateVioPeccancyInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__UpdateVioPeccancyInfo(soap, "ns1:UpdateVioPeccancyInfo", -1, &a->ns1__UpdateVioPeccancyInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateVioPeccancyInfo_ * SOAP_FMAC4 soap_in___ns1__UpdateVioPeccancyInfo_(struct soap *soap, const char *tag, struct __ns1__UpdateVioPeccancyInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__UpdateVioPeccancyInfo = 1;
	short soap_flag;
	a = (struct __ns1__UpdateVioPeccancyInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpdateVioPeccancyInfo_, sizeof(struct __ns1__UpdateVioPeccancyInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdateVioPeccancyInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateVioPeccancyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdateVioPeccancyInfo(soap, "ns1:UpdateVioPeccancyInfo", &a->ns1__UpdateVioPeccancyInfo, ""))
				{	soap_flag_ns1__UpdateVioPeccancyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdateVioPeccancyInfo_(struct soap *soap, const struct __ns1__UpdateVioPeccancyInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__UpdateVioPeccancyInfo_(soap, tag?tag:"-ns1:UpdateVioPeccancyInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateVioPeccancyInfo_ * SOAP_FMAC4 soap_get___ns1__UpdateVioPeccancyInfo_(struct soap *soap, struct __ns1__UpdateVioPeccancyInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdateVioPeccancyInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__UpdateVioPeccancyInfo_ * SOAP_FMAC2 soap_instantiate___ns1__UpdateVioPeccancyInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdateVioPeccancyInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UpdateVioPeccancyInfo_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__UpdateVioPeccancyInfo_);
		if (size)
			*size = sizeof(struct __ns1__UpdateVioPeccancyInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__UpdateVioPeccancyInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__UpdateVioPeccancyInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__UpdateVioPeccancyInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UpdateVioPeccancyInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UpdateVioPeccancyInfo_ %p -> %p\n", q, p));
	*(struct __ns1__UpdateVioPeccancyInfo_*)p = *(struct __ns1__UpdateVioPeccancyInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetVioPeccancyNoCheckInfo_(struct soap *soap, struct __ns1__GetVioPeccancyNoCheckInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetVioPeccancyNoCheckInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetVioPeccancyNoCheckInfo_(struct soap *soap, const struct __ns1__GetVioPeccancyNoCheckInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetVioPeccancyNoCheckInfo(soap, &a->ns1__GetVioPeccancyNoCheckInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetVioPeccancyNoCheckInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__GetVioPeccancyNoCheckInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetVioPeccancyNoCheckInfo(soap, "ns1:GetVioPeccancyNoCheckInfo", -1, &a->ns1__GetVioPeccancyNoCheckInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetVioPeccancyNoCheckInfo_ * SOAP_FMAC4 soap_in___ns1__GetVioPeccancyNoCheckInfo_(struct soap *soap, const char *tag, struct __ns1__GetVioPeccancyNoCheckInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__GetVioPeccancyNoCheckInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetVioPeccancyNoCheckInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetVioPeccancyNoCheckInfo_, sizeof(struct __ns1__GetVioPeccancyNoCheckInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetVioPeccancyNoCheckInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetVioPeccancyNoCheckInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetVioPeccancyNoCheckInfo(soap, "ns1:GetVioPeccancyNoCheckInfo", &a->ns1__GetVioPeccancyNoCheckInfo, ""))
				{	soap_flag_ns1__GetVioPeccancyNoCheckInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetVioPeccancyNoCheckInfo_(struct soap *soap, const struct __ns1__GetVioPeccancyNoCheckInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetVioPeccancyNoCheckInfo_(soap, tag?tag:"-ns1:GetVioPeccancyNoCheckInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetVioPeccancyNoCheckInfo_ * SOAP_FMAC4 soap_get___ns1__GetVioPeccancyNoCheckInfo_(struct soap *soap, struct __ns1__GetVioPeccancyNoCheckInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetVioPeccancyNoCheckInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetVioPeccancyNoCheckInfo_ * SOAP_FMAC2 soap_instantiate___ns1__GetVioPeccancyNoCheckInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetVioPeccancyNoCheckInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetVioPeccancyNoCheckInfo_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetVioPeccancyNoCheckInfo_);
		if (size)
			*size = sizeof(struct __ns1__GetVioPeccancyNoCheckInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetVioPeccancyNoCheckInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetVioPeccancyNoCheckInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetVioPeccancyNoCheckInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetVioPeccancyNoCheckInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetVioPeccancyNoCheckInfo_ %p -> %p\n", q, p));
	*(struct __ns1__GetVioPeccancyNoCheckInfo_*)p = *(struct __ns1__GetVioPeccancyNoCheckInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdatePeccancyInfo_(struct soap *soap, struct __ns1__UpdatePeccancyInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdatePeccancyInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdatePeccancyInfo_(struct soap *soap, const struct __ns1__UpdatePeccancyInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UpdatePeccancyInfo(soap, &a->ns1__UpdatePeccancyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdatePeccancyInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__UpdatePeccancyInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__UpdatePeccancyInfo(soap, "ns1:UpdatePeccancyInfo", -1, &a->ns1__UpdatePeccancyInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdatePeccancyInfo_ * SOAP_FMAC4 soap_in___ns1__UpdatePeccancyInfo_(struct soap *soap, const char *tag, struct __ns1__UpdatePeccancyInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__UpdatePeccancyInfo = 1;
	short soap_flag;
	a = (struct __ns1__UpdatePeccancyInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpdatePeccancyInfo_, sizeof(struct __ns1__UpdatePeccancyInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdatePeccancyInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdatePeccancyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdatePeccancyInfo(soap, "ns1:UpdatePeccancyInfo", &a->ns1__UpdatePeccancyInfo, ""))
				{	soap_flag_ns1__UpdatePeccancyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdatePeccancyInfo_(struct soap *soap, const struct __ns1__UpdatePeccancyInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__UpdatePeccancyInfo_(soap, tag?tag:"-ns1:UpdatePeccancyInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdatePeccancyInfo_ * SOAP_FMAC4 soap_get___ns1__UpdatePeccancyInfo_(struct soap *soap, struct __ns1__UpdatePeccancyInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdatePeccancyInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__UpdatePeccancyInfo_ * SOAP_FMAC2 soap_instantiate___ns1__UpdatePeccancyInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdatePeccancyInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UpdatePeccancyInfo_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__UpdatePeccancyInfo_);
		if (size)
			*size = sizeof(struct __ns1__UpdatePeccancyInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__UpdatePeccancyInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__UpdatePeccancyInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__UpdatePeccancyInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UpdatePeccancyInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UpdatePeccancyInfo_ %p -> %p\n", q, p));
	*(struct __ns1__UpdatePeccancyInfo_*)p = *(struct __ns1__UpdatePeccancyInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetPeccancyNoCheckInfo_(struct soap *soap, struct __ns1__GetPeccancyNoCheckInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPeccancyNoCheckInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetPeccancyNoCheckInfo_(struct soap *soap, const struct __ns1__GetPeccancyNoCheckInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPeccancyNoCheckInfo(soap, &a->ns1__GetPeccancyNoCheckInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetPeccancyNoCheckInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__GetPeccancyNoCheckInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetPeccancyNoCheckInfo(soap, "ns1:GetPeccancyNoCheckInfo", -1, &a->ns1__GetPeccancyNoCheckInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPeccancyNoCheckInfo_ * SOAP_FMAC4 soap_in___ns1__GetPeccancyNoCheckInfo_(struct soap *soap, const char *tag, struct __ns1__GetPeccancyNoCheckInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__GetPeccancyNoCheckInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetPeccancyNoCheckInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetPeccancyNoCheckInfo_, sizeof(struct __ns1__GetPeccancyNoCheckInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetPeccancyNoCheckInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPeccancyNoCheckInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPeccancyNoCheckInfo(soap, "ns1:GetPeccancyNoCheckInfo", &a->ns1__GetPeccancyNoCheckInfo, ""))
				{	soap_flag_ns1__GetPeccancyNoCheckInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetPeccancyNoCheckInfo_(struct soap *soap, const struct __ns1__GetPeccancyNoCheckInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetPeccancyNoCheckInfo_(soap, tag?tag:"-ns1:GetPeccancyNoCheckInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPeccancyNoCheckInfo_ * SOAP_FMAC4 soap_get___ns1__GetPeccancyNoCheckInfo_(struct soap *soap, struct __ns1__GetPeccancyNoCheckInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetPeccancyNoCheckInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetPeccancyNoCheckInfo_ * SOAP_FMAC2 soap_instantiate___ns1__GetPeccancyNoCheckInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetPeccancyNoCheckInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetPeccancyNoCheckInfo_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetPeccancyNoCheckInfo_);
		if (size)
			*size = sizeof(struct __ns1__GetPeccancyNoCheckInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetPeccancyNoCheckInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetPeccancyNoCheckInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetPeccancyNoCheckInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetPeccancyNoCheckInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetPeccancyNoCheckInfo_ %p -> %p\n", q, p));
	*(struct __ns1__GetPeccancyNoCheckInfo_*)p = *(struct __ns1__GetPeccancyNoCheckInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetPeccancyInfo_(struct soap *soap, struct __ns1__GetPeccancyInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPeccancyInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetPeccancyInfo_(struct soap *soap, const struct __ns1__GetPeccancyInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPeccancyInfo(soap, &a->ns1__GetPeccancyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetPeccancyInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__GetPeccancyInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetPeccancyInfo(soap, "ns1:GetPeccancyInfo", -1, &a->ns1__GetPeccancyInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPeccancyInfo_ * SOAP_FMAC4 soap_in___ns1__GetPeccancyInfo_(struct soap *soap, const char *tag, struct __ns1__GetPeccancyInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__GetPeccancyInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetPeccancyInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetPeccancyInfo_, sizeof(struct __ns1__GetPeccancyInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetPeccancyInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPeccancyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPeccancyInfo(soap, "ns1:GetPeccancyInfo", &a->ns1__GetPeccancyInfo, ""))
				{	soap_flag_ns1__GetPeccancyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetPeccancyInfo_(struct soap *soap, const struct __ns1__GetPeccancyInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetPeccancyInfo_(soap, tag?tag:"-ns1:GetPeccancyInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPeccancyInfo_ * SOAP_FMAC4 soap_get___ns1__GetPeccancyInfo_(struct soap *soap, struct __ns1__GetPeccancyInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetPeccancyInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetPeccancyInfo_ * SOAP_FMAC2 soap_instantiate___ns1__GetPeccancyInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetPeccancyInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetPeccancyInfo_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetPeccancyInfo_);
		if (size)
			*size = sizeof(struct __ns1__GetPeccancyInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetPeccancyInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetPeccancyInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetPeccancyInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetPeccancyInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetPeccancyInfo_ %p -> %p\n", q, p));
	*(struct __ns1__GetPeccancyInfo_*)p = *(struct __ns1__GetPeccancyInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetPassCarInfo_(struct soap *soap, struct __ns1__GetPassCarInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPassCarInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetPassCarInfo_(struct soap *soap, const struct __ns1__GetPassCarInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPassCarInfo(soap, &a->ns1__GetPassCarInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetPassCarInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__GetPassCarInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetPassCarInfo(soap, "ns1:GetPassCarInfo", -1, &a->ns1__GetPassCarInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPassCarInfo_ * SOAP_FMAC4 soap_in___ns1__GetPassCarInfo_(struct soap *soap, const char *tag, struct __ns1__GetPassCarInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__GetPassCarInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetPassCarInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetPassCarInfo_, sizeof(struct __ns1__GetPassCarInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetPassCarInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPassCarInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPassCarInfo(soap, "ns1:GetPassCarInfo", &a->ns1__GetPassCarInfo, ""))
				{	soap_flag_ns1__GetPassCarInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetPassCarInfo_(struct soap *soap, const struct __ns1__GetPassCarInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetPassCarInfo_(soap, tag?tag:"-ns1:GetPassCarInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPassCarInfo_ * SOAP_FMAC4 soap_get___ns1__GetPassCarInfo_(struct soap *soap, struct __ns1__GetPassCarInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetPassCarInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetPassCarInfo_ * SOAP_FMAC2 soap_instantiate___ns1__GetPassCarInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetPassCarInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetPassCarInfo_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetPassCarInfo_);
		if (size)
			*size = sizeof(struct __ns1__GetPassCarInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetPassCarInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetPassCarInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetPassCarInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetPassCarInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetPassCarInfo_ %p -> %p\n", q, p));
	*(struct __ns1__GetPassCarInfo_*)p = *(struct __ns1__GetPassCarInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetLocationInfo_(struct soap *soap, struct __ns1__GetLocationInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLocationInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetLocationInfo_(struct soap *soap, const struct __ns1__GetLocationInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetLocationInfo(soap, &a->ns1__GetLocationInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetLocationInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__GetLocationInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetLocationInfo(soap, "ns1:GetLocationInfo", -1, &a->ns1__GetLocationInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLocationInfo_ * SOAP_FMAC4 soap_in___ns1__GetLocationInfo_(struct soap *soap, const char *tag, struct __ns1__GetLocationInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__GetLocationInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetLocationInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetLocationInfo_, sizeof(struct __ns1__GetLocationInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetLocationInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLocationInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetLocationInfo(soap, "ns1:GetLocationInfo", &a->ns1__GetLocationInfo, ""))
				{	soap_flag_ns1__GetLocationInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetLocationInfo_(struct soap *soap, const struct __ns1__GetLocationInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetLocationInfo_(soap, tag?tag:"-ns1:GetLocationInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLocationInfo_ * SOAP_FMAC4 soap_get___ns1__GetLocationInfo_(struct soap *soap, struct __ns1__GetLocationInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetLocationInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetLocationInfo_ * SOAP_FMAC2 soap_instantiate___ns1__GetLocationInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetLocationInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetLocationInfo_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetLocationInfo_);
		if (size)
			*size = sizeof(struct __ns1__GetLocationInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetLocationInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetLocationInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetLocationInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetLocationInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetLocationInfo_ %p -> %p\n", q, p));
	*(struct __ns1__GetLocationInfo_*)p = *(struct __ns1__GetLocationInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__RevokeSuspicionInfo_(struct soap *soap, struct __ns1__RevokeSuspicionInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RevokeSuspicionInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__RevokeSuspicionInfo_(struct soap *soap, const struct __ns1__RevokeSuspicionInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__RevokeSuspicionInfo(soap, &a->ns1__RevokeSuspicionInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__RevokeSuspicionInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__RevokeSuspicionInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__RevokeSuspicionInfo(soap, "ns1:RevokeSuspicionInfo", -1, &a->ns1__RevokeSuspicionInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RevokeSuspicionInfo_ * SOAP_FMAC4 soap_in___ns1__RevokeSuspicionInfo_(struct soap *soap, const char *tag, struct __ns1__RevokeSuspicionInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__RevokeSuspicionInfo = 1;
	short soap_flag;
	a = (struct __ns1__RevokeSuspicionInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__RevokeSuspicionInfo_, sizeof(struct __ns1__RevokeSuspicionInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__RevokeSuspicionInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RevokeSuspicionInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RevokeSuspicionInfo(soap, "ns1:RevokeSuspicionInfo", &a->ns1__RevokeSuspicionInfo, ""))
				{	soap_flag_ns1__RevokeSuspicionInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__RevokeSuspicionInfo_(struct soap *soap, const struct __ns1__RevokeSuspicionInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__RevokeSuspicionInfo_(soap, tag?tag:"-ns1:RevokeSuspicionInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RevokeSuspicionInfo_ * SOAP_FMAC4 soap_get___ns1__RevokeSuspicionInfo_(struct soap *soap, struct __ns1__RevokeSuspicionInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__RevokeSuspicionInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__RevokeSuspicionInfo_ * SOAP_FMAC2 soap_instantiate___ns1__RevokeSuspicionInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__RevokeSuspicionInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__RevokeSuspicionInfo_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__RevokeSuspicionInfo_);
		if (size)
			*size = sizeof(struct __ns1__RevokeSuspicionInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__RevokeSuspicionInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__RevokeSuspicionInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__RevokeSuspicionInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__RevokeSuspicionInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__RevokeSuspicionInfo_ %p -> %p\n", q, p));
	*(struct __ns1__RevokeSuspicionInfo_*)p = *(struct __ns1__RevokeSuspicionInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InSuspicionInfo_(struct soap *soap, struct __ns1__InSuspicionInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InSuspicionInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InSuspicionInfo_(struct soap *soap, const struct __ns1__InSuspicionInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__InSuspicionInfo(soap, &a->ns1__InSuspicionInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InSuspicionInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__InSuspicionInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__InSuspicionInfo(soap, "ns1:InSuspicionInfo", -1, &a->ns1__InSuspicionInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InSuspicionInfo_ * SOAP_FMAC4 soap_in___ns1__InSuspicionInfo_(struct soap *soap, const char *tag, struct __ns1__InSuspicionInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__InSuspicionInfo = 1;
	short soap_flag;
	a = (struct __ns1__InSuspicionInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InSuspicionInfo_, sizeof(struct __ns1__InSuspicionInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InSuspicionInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InSuspicionInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__InSuspicionInfo(soap, "ns1:InSuspicionInfo", &a->ns1__InSuspicionInfo, ""))
				{	soap_flag_ns1__InSuspicionInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InSuspicionInfo_(struct soap *soap, const struct __ns1__InSuspicionInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__InSuspicionInfo_(soap, tag?tag:"-ns1:InSuspicionInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InSuspicionInfo_ * SOAP_FMAC4 soap_get___ns1__InSuspicionInfo_(struct soap *soap, struct __ns1__InSuspicionInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InSuspicionInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__InSuspicionInfo_ * SOAP_FMAC2 soap_instantiate___ns1__InSuspicionInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InSuspicionInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__InSuspicionInfo_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__InSuspicionInfo_);
		if (size)
			*size = sizeof(struct __ns1__InSuspicionInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__InSuspicionInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__InSuspicionInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__InSuspicionInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__InSuspicionInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__InSuspicionInfo_ %p -> %p\n", q, p));
	*(struct __ns1__InSuspicionInfo_*)p = *(struct __ns1__InSuspicionInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__IntExtralistInfo_(struct soap *soap, struct __ns1__IntExtralistInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__IntExtralistInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__IntExtralistInfo_(struct soap *soap, const struct __ns1__IntExtralistInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__IntExtralistInfo(soap, &a->ns1__IntExtralistInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__IntExtralistInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__IntExtralistInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__IntExtralistInfo(soap, "ns1:IntExtralistInfo", -1, &a->ns1__IntExtralistInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__IntExtralistInfo_ * SOAP_FMAC4 soap_in___ns1__IntExtralistInfo_(struct soap *soap, const char *tag, struct __ns1__IntExtralistInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__IntExtralistInfo = 1;
	short soap_flag;
	a = (struct __ns1__IntExtralistInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__IntExtralistInfo_, sizeof(struct __ns1__IntExtralistInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__IntExtralistInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__IntExtralistInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__IntExtralistInfo(soap, "ns1:IntExtralistInfo", &a->ns1__IntExtralistInfo, ""))
				{	soap_flag_ns1__IntExtralistInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__IntExtralistInfo_(struct soap *soap, const struct __ns1__IntExtralistInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__IntExtralistInfo_(soap, tag?tag:"-ns1:IntExtralistInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__IntExtralistInfo_ * SOAP_FMAC4 soap_get___ns1__IntExtralistInfo_(struct soap *soap, struct __ns1__IntExtralistInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__IntExtralistInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__IntExtralistInfo_ * SOAP_FMAC2 soap_instantiate___ns1__IntExtralistInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__IntExtralistInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__IntExtralistInfo_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__IntExtralistInfo_);
		if (size)
			*size = sizeof(struct __ns1__IntExtralistInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__IntExtralistInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__IntExtralistInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__IntExtralistInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__IntExtralistInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__IntExtralistInfo_ %p -> %p\n", q, p));
	*(struct __ns1__IntExtralistInfo_*)p = *(struct __ns1__IntExtralistInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InChecklessInfo_(struct soap *soap, struct __ns1__InChecklessInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InChecklessInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InChecklessInfo_(struct soap *soap, const struct __ns1__InChecklessInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__InChecklessInfo(soap, &a->ns1__InChecklessInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InChecklessInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__InChecklessInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__InChecklessInfo(soap, "ns1:InChecklessInfo", -1, &a->ns1__InChecklessInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InChecklessInfo_ * SOAP_FMAC4 soap_in___ns1__InChecklessInfo_(struct soap *soap, const char *tag, struct __ns1__InChecklessInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__InChecklessInfo = 1;
	short soap_flag;
	a = (struct __ns1__InChecklessInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InChecklessInfo_, sizeof(struct __ns1__InChecklessInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InChecklessInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InChecklessInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__InChecklessInfo(soap, "ns1:InChecklessInfo", &a->ns1__InChecklessInfo, ""))
				{	soap_flag_ns1__InChecklessInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InChecklessInfo_(struct soap *soap, const struct __ns1__InChecklessInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__InChecklessInfo_(soap, tag?tag:"-ns1:InChecklessInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InChecklessInfo_ * SOAP_FMAC4 soap_get___ns1__InChecklessInfo_(struct soap *soap, struct __ns1__InChecklessInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InChecklessInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__InChecklessInfo_ * SOAP_FMAC2 soap_instantiate___ns1__InChecklessInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InChecklessInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__InChecklessInfo_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__InChecklessInfo_);
		if (size)
			*size = sizeof(struct __ns1__InChecklessInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__InChecklessInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__InChecklessInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__InChecklessInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__InChecklessInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__InChecklessInfo_ %p -> %p\n", q, p));
	*(struct __ns1__InChecklessInfo_*)p = *(struct __ns1__InChecklessInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InBlacklistInfo_(struct soap *soap, struct __ns1__InBlacklistInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InBlacklistInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InBlacklistInfo_(struct soap *soap, const struct __ns1__InBlacklistInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__InBlacklistInfo(soap, &a->ns1__InBlacklistInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InBlacklistInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__InBlacklistInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__InBlacklistInfo(soap, "ns1:InBlacklistInfo", -1, &a->ns1__InBlacklistInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InBlacklistInfo_ * SOAP_FMAC4 soap_in___ns1__InBlacklistInfo_(struct soap *soap, const char *tag, struct __ns1__InBlacklistInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__InBlacklistInfo = 1;
	short soap_flag;
	a = (struct __ns1__InBlacklistInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InBlacklistInfo_, sizeof(struct __ns1__InBlacklistInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InBlacklistInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InBlacklistInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__InBlacklistInfo(soap, "ns1:InBlacklistInfo", &a->ns1__InBlacklistInfo, ""))
				{	soap_flag_ns1__InBlacklistInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InBlacklistInfo_(struct soap *soap, const struct __ns1__InBlacklistInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__InBlacklistInfo_(soap, tag?tag:"-ns1:InBlacklistInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InBlacklistInfo_ * SOAP_FMAC4 soap_get___ns1__InBlacklistInfo_(struct soap *soap, struct __ns1__InBlacklistInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InBlacklistInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__InBlacklistInfo_ * SOAP_FMAC2 soap_instantiate___ns1__InBlacklistInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InBlacklistInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__InBlacklistInfo_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__InBlacklistInfo_);
		if (size)
			*size = sizeof(struct __ns1__InBlacklistInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__InBlacklistInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__InBlacklistInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__InBlacklistInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__InBlacklistInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__InBlacklistInfo_ %p -> %p\n", q, p));
	*(struct __ns1__InBlacklistInfo_*)p = *(struct __ns1__InBlacklistInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InCheckedPeccancyInfo_(struct soap *soap, struct __ns1__InCheckedPeccancyInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InCheckedPeccancyInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InCheckedPeccancyInfo_(struct soap *soap, const struct __ns1__InCheckedPeccancyInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__InCheckedPeccancyInfo(soap, &a->ns1__InCheckedPeccancyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InCheckedPeccancyInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__InCheckedPeccancyInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__InCheckedPeccancyInfo(soap, "ns1:InCheckedPeccancyInfo", -1, &a->ns1__InCheckedPeccancyInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InCheckedPeccancyInfo_ * SOAP_FMAC4 soap_in___ns1__InCheckedPeccancyInfo_(struct soap *soap, const char *tag, struct __ns1__InCheckedPeccancyInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__InCheckedPeccancyInfo = 1;
	short soap_flag;
	a = (struct __ns1__InCheckedPeccancyInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InCheckedPeccancyInfo_, sizeof(struct __ns1__InCheckedPeccancyInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InCheckedPeccancyInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InCheckedPeccancyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__InCheckedPeccancyInfo(soap, "ns1:InCheckedPeccancyInfo", &a->ns1__InCheckedPeccancyInfo, ""))
				{	soap_flag_ns1__InCheckedPeccancyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InCheckedPeccancyInfo_(struct soap *soap, const struct __ns1__InCheckedPeccancyInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__InCheckedPeccancyInfo_(soap, tag?tag:"-ns1:InCheckedPeccancyInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InCheckedPeccancyInfo_ * SOAP_FMAC4 soap_get___ns1__InCheckedPeccancyInfo_(struct soap *soap, struct __ns1__InCheckedPeccancyInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InCheckedPeccancyInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__InCheckedPeccancyInfo_ * SOAP_FMAC2 soap_instantiate___ns1__InCheckedPeccancyInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InCheckedPeccancyInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__InCheckedPeccancyInfo_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__InCheckedPeccancyInfo_);
		if (size)
			*size = sizeof(struct __ns1__InCheckedPeccancyInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__InCheckedPeccancyInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__InCheckedPeccancyInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__InCheckedPeccancyInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__InCheckedPeccancyInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__InCheckedPeccancyInfo_ %p -> %p\n", q, p));
	*(struct __ns1__InCheckedPeccancyInfo_*)p = *(struct __ns1__InCheckedPeccancyInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InPeccancyInfo_(struct soap *soap, struct __ns1__InPeccancyInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InPeccancyInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InPeccancyInfo_(struct soap *soap, const struct __ns1__InPeccancyInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__InPeccancyInfo(soap, &a->ns1__InPeccancyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InPeccancyInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__InPeccancyInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__InPeccancyInfo(soap, "ns1:InPeccancyInfo", -1, &a->ns1__InPeccancyInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InPeccancyInfo_ * SOAP_FMAC4 soap_in___ns1__InPeccancyInfo_(struct soap *soap, const char *tag, struct __ns1__InPeccancyInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__InPeccancyInfo = 1;
	short soap_flag;
	a = (struct __ns1__InPeccancyInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InPeccancyInfo_, sizeof(struct __ns1__InPeccancyInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InPeccancyInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InPeccancyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__InPeccancyInfo(soap, "ns1:InPeccancyInfo", &a->ns1__InPeccancyInfo, ""))
				{	soap_flag_ns1__InPeccancyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InPeccancyInfo_(struct soap *soap, const struct __ns1__InPeccancyInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__InPeccancyInfo_(soap, tag?tag:"-ns1:InPeccancyInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InPeccancyInfo_ * SOAP_FMAC4 soap_get___ns1__InPeccancyInfo_(struct soap *soap, struct __ns1__InPeccancyInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InPeccancyInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__InPeccancyInfo_ * SOAP_FMAC2 soap_instantiate___ns1__InPeccancyInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InPeccancyInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__InPeccancyInfo_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__InPeccancyInfo_);
		if (size)
			*size = sizeof(struct __ns1__InPeccancyInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__InPeccancyInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__InPeccancyInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__InPeccancyInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__InPeccancyInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__InPeccancyInfo_ %p -> %p\n", q, p));
	*(struct __ns1__InPeccancyInfo_*)p = *(struct __ns1__InPeccancyInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InPassCarInfo_(struct soap *soap, struct __ns1__InPassCarInfo_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InPassCarInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InPassCarInfo_(struct soap *soap, const struct __ns1__InPassCarInfo_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__InPassCarInfo(soap, &a->ns1__InPassCarInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InPassCarInfo_(struct soap *soap, const char *tag, int id, const struct __ns1__InPassCarInfo_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__InPassCarInfo(soap, "ns1:InPassCarInfo", -1, &a->ns1__InPassCarInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InPassCarInfo_ * SOAP_FMAC4 soap_in___ns1__InPassCarInfo_(struct soap *soap, const char *tag, struct __ns1__InPassCarInfo_ *a, const char *type)
{
	size_t soap_flag_ns1__InPassCarInfo = 1;
	short soap_flag;
	a = (struct __ns1__InPassCarInfo_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InPassCarInfo_, sizeof(struct __ns1__InPassCarInfo_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InPassCarInfo_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InPassCarInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__InPassCarInfo(soap, "ns1:InPassCarInfo", &a->ns1__InPassCarInfo, ""))
				{	soap_flag_ns1__InPassCarInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InPassCarInfo_(struct soap *soap, const struct __ns1__InPassCarInfo_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__InPassCarInfo_(soap, tag?tag:"-ns1:InPassCarInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InPassCarInfo_ * SOAP_FMAC4 soap_get___ns1__InPassCarInfo_(struct soap *soap, struct __ns1__InPassCarInfo_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InPassCarInfo_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__InPassCarInfo_ * SOAP_FMAC2 soap_instantiate___ns1__InPassCarInfo_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InPassCarInfo_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__InPassCarInfo_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__InPassCarInfo_);
		if (size)
			*size = sizeof(struct __ns1__InPassCarInfo_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__InPassCarInfo_, n);
		if (size)
			*size = n * sizeof(struct __ns1__InPassCarInfo_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__InPassCarInfo_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__InPassCarInfo_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__InPassCarInfo_ %p -> %p\n", q, p));
	*(struct __ns1__InPassCarInfo_*)p = *(struct __ns1__InPassCarInfo_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CarPlateRecog_(struct soap *soap, struct __ns1__CarPlateRecog_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CarPlateRecog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CarPlateRecog_(struct soap *soap, const struct __ns1__CarPlateRecog_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__CarPlateRecog(soap, &a->ns1__CarPlateRecog);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CarPlateRecog_(struct soap *soap, const char *tag, int id, const struct __ns1__CarPlateRecog_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__CarPlateRecog(soap, "ns1:CarPlateRecog", -1, &a->ns1__CarPlateRecog, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CarPlateRecog_ * SOAP_FMAC4 soap_in___ns1__CarPlateRecog_(struct soap *soap, const char *tag, struct __ns1__CarPlateRecog_ *a, const char *type)
{
	size_t soap_flag_ns1__CarPlateRecog = 1;
	short soap_flag;
	a = (struct __ns1__CarPlateRecog_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CarPlateRecog_, sizeof(struct __ns1__CarPlateRecog_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CarPlateRecog_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CarPlateRecog && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CarPlateRecog(soap, "ns1:CarPlateRecog", &a->ns1__CarPlateRecog, ""))
				{	soap_flag_ns1__CarPlateRecog--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CarPlateRecog_(struct soap *soap, const struct __ns1__CarPlateRecog_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__CarPlateRecog_(soap, tag?tag:"-ns1:CarPlateRecog", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CarPlateRecog_ * SOAP_FMAC4 soap_get___ns1__CarPlateRecog_(struct soap *soap, struct __ns1__CarPlateRecog_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CarPlateRecog_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__CarPlateRecog_ * SOAP_FMAC2 soap_instantiate___ns1__CarPlateRecog_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CarPlateRecog_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__CarPlateRecog_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__CarPlateRecog_);
		if (size)
			*size = sizeof(struct __ns1__CarPlateRecog_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__CarPlateRecog_, n);
		if (size)
			*size = n * sizeof(struct __ns1__CarPlateRecog_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__CarPlateRecog_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__CarPlateRecog_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__CarPlateRecog_ %p -> %p\n", q, p));
	*(struct __ns1__CarPlateRecog_*)p = *(struct __ns1__CarPlateRecog_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetXMlFormat_(struct soap *soap, struct __ns1__GetXMlFormat_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetXMlFormat = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetXMlFormat_(struct soap *soap, const struct __ns1__GetXMlFormat_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetXMlFormat(soap, &a->ns1__GetXMlFormat);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetXMlFormat_(struct soap *soap, const char *tag, int id, const struct __ns1__GetXMlFormat_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetXMlFormat(soap, "ns1:GetXMlFormat", -1, &a->ns1__GetXMlFormat, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetXMlFormat_ * SOAP_FMAC4 soap_in___ns1__GetXMlFormat_(struct soap *soap, const char *tag, struct __ns1__GetXMlFormat_ *a, const char *type)
{
	size_t soap_flag_ns1__GetXMlFormat = 1;
	short soap_flag;
	a = (struct __ns1__GetXMlFormat_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetXMlFormat_, sizeof(struct __ns1__GetXMlFormat_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetXMlFormat_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetXMlFormat && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetXMlFormat(soap, "ns1:GetXMlFormat", &a->ns1__GetXMlFormat, ""))
				{	soap_flag_ns1__GetXMlFormat--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetXMlFormat_(struct soap *soap, const struct __ns1__GetXMlFormat_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetXMlFormat_(soap, tag?tag:"-ns1:GetXMlFormat", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetXMlFormat_ * SOAP_FMAC4 soap_get___ns1__GetXMlFormat_(struct soap *soap, struct __ns1__GetXMlFormat_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetXMlFormat_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetXMlFormat_ * SOAP_FMAC2 soap_instantiate___ns1__GetXMlFormat_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetXMlFormat_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetXMlFormat_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetXMlFormat_);
		if (size)
			*size = sizeof(struct __ns1__GetXMlFormat_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetXMlFormat_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetXMlFormat_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetXMlFormat_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetXMlFormat_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetXMlFormat_ %p -> %p\n", q, p));
	*(struct __ns1__GetXMlFormat_*)p = *(struct __ns1__GetXMlFormat_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetCurrentVersion_(struct soap *soap, struct __ns1__GetCurrentVersion_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetCurrentVersion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetCurrentVersion_(struct soap *soap, const struct __ns1__GetCurrentVersion_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetCurrentVersion(soap, &a->ns1__GetCurrentVersion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetCurrentVersion_(struct soap *soap, const char *tag, int id, const struct __ns1__GetCurrentVersion_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetCurrentVersion(soap, "ns1:GetCurrentVersion", -1, &a->ns1__GetCurrentVersion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetCurrentVersion_ * SOAP_FMAC4 soap_in___ns1__GetCurrentVersion_(struct soap *soap, const char *tag, struct __ns1__GetCurrentVersion_ *a, const char *type)
{
	size_t soap_flag_ns1__GetCurrentVersion = 1;
	short soap_flag;
	a = (struct __ns1__GetCurrentVersion_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetCurrentVersion_, sizeof(struct __ns1__GetCurrentVersion_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetCurrentVersion_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetCurrentVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetCurrentVersion(soap, "ns1:GetCurrentVersion", &a->ns1__GetCurrentVersion, ""))
				{	soap_flag_ns1__GetCurrentVersion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetCurrentVersion_(struct soap *soap, const struct __ns1__GetCurrentVersion_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetCurrentVersion_(soap, tag?tag:"-ns1:GetCurrentVersion", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetCurrentVersion_ * SOAP_FMAC4 soap_get___ns1__GetCurrentVersion_(struct soap *soap, struct __ns1__GetCurrentVersion_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetCurrentVersion_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetCurrentVersion_ * SOAP_FMAC2 soap_instantiate___ns1__GetCurrentVersion_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetCurrentVersion_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetCurrentVersion_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetCurrentVersion_);
		if (size)
			*size = sizeof(struct __ns1__GetCurrentVersion_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetCurrentVersion_, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetCurrentVersion_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetCurrentVersion_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetCurrentVersion_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetCurrentVersion_ %p -> %p\n", q, p));
	*(struct __ns1__GetCurrentVersion_*)p = *(struct __ns1__GetCurrentVersion_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__WebserviceTest_(struct soap *soap, struct __ns1__WebserviceTest_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__WebserviceTest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__WebserviceTest_(struct soap *soap, const struct __ns1__WebserviceTest_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__WebserviceTest(soap, &a->ns1__WebserviceTest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__WebserviceTest_(struct soap *soap, const char *tag, int id, const struct __ns1__WebserviceTest_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__WebserviceTest(soap, "ns1:WebserviceTest", -1, &a->ns1__WebserviceTest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__WebserviceTest_ * SOAP_FMAC4 soap_in___ns1__WebserviceTest_(struct soap *soap, const char *tag, struct __ns1__WebserviceTest_ *a, const char *type)
{
	size_t soap_flag_ns1__WebserviceTest = 1;
	short soap_flag;
	a = (struct __ns1__WebserviceTest_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__WebserviceTest_, sizeof(struct __ns1__WebserviceTest_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__WebserviceTest_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__WebserviceTest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__WebserviceTest(soap, "ns1:WebserviceTest", &a->ns1__WebserviceTest, ""))
				{	soap_flag_ns1__WebserviceTest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__WebserviceTest_(struct soap *soap, const struct __ns1__WebserviceTest_ *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__WebserviceTest_(soap, tag?tag:"-ns1:WebserviceTest", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__WebserviceTest_ * SOAP_FMAC4 soap_get___ns1__WebserviceTest_(struct soap *soap, struct __ns1__WebserviceTest_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__WebserviceTest_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__WebserviceTest_ * SOAP_FMAC2 soap_instantiate___ns1__WebserviceTest_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__WebserviceTest_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__WebserviceTest_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__WebserviceTest_);
		if (size)
			*size = sizeof(struct __ns1__WebserviceTest_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__WebserviceTest_, n);
		if (size)
			*size = n * sizeof(struct __ns1__WebserviceTest_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__WebserviceTest_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__WebserviceTest_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__WebserviceTest_ %p -> %p\n", q, p));
	*(struct __ns1__WebserviceTest_*)p = *(struct __ns1__WebserviceTest_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CheckUserInfo(struct soap *soap, struct __ns1__CheckUserInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CheckUserInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CheckUserInfo(struct soap *soap, const struct __ns1__CheckUserInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__CheckUserInfo(soap, &a->ns1__CheckUserInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CheckUserInfo(struct soap *soap, const char *tag, int id, const struct __ns1__CheckUserInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__CheckUserInfo(soap, "ns1:CheckUserInfo", -1, &a->ns1__CheckUserInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckUserInfo * SOAP_FMAC4 soap_in___ns1__CheckUserInfo(struct soap *soap, const char *tag, struct __ns1__CheckUserInfo *a, const char *type)
{
	size_t soap_flag_ns1__CheckUserInfo = 1;
	short soap_flag;
	a = (struct __ns1__CheckUserInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CheckUserInfo, sizeof(struct __ns1__CheckUserInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CheckUserInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CheckUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CheckUserInfo(soap, "ns1:CheckUserInfo", &a->ns1__CheckUserInfo, ""))
				{	soap_flag_ns1__CheckUserInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CheckUserInfo(struct soap *soap, const struct __ns1__CheckUserInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__CheckUserInfo(soap, tag?tag:"-ns1:CheckUserInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CheckUserInfo * SOAP_FMAC4 soap_get___ns1__CheckUserInfo(struct soap *soap, struct __ns1__CheckUserInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CheckUserInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__CheckUserInfo * SOAP_FMAC2 soap_instantiate___ns1__CheckUserInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CheckUserInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__CheckUserInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__CheckUserInfo);
		if (size)
			*size = sizeof(struct __ns1__CheckUserInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__CheckUserInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__CheckUserInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__CheckUserInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__CheckUserInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__CheckUserInfo %p -> %p\n", q, p));
	*(struct __ns1__CheckUserInfo*)p = *(struct __ns1__CheckUserInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addTransRecInfo(struct soap *soap, struct __ns1__addTransRecInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addTransRecInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addTransRecInfo(struct soap *soap, const struct __ns1__addTransRecInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__addTransRecInfo(soap, &a->ns1__addTransRecInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addTransRecInfo(struct soap *soap, const char *tag, int id, const struct __ns1__addTransRecInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__addTransRecInfo(soap, "ns1:addTransRecInfo", -1, &a->ns1__addTransRecInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addTransRecInfo * SOAP_FMAC4 soap_in___ns1__addTransRecInfo(struct soap *soap, const char *tag, struct __ns1__addTransRecInfo *a, const char *type)
{
	size_t soap_flag_ns1__addTransRecInfo = 1;
	short soap_flag;
	a = (struct __ns1__addTransRecInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addTransRecInfo, sizeof(struct __ns1__addTransRecInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addTransRecInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addTransRecInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__addTransRecInfo(soap, "ns1:addTransRecInfo", &a->ns1__addTransRecInfo, ""))
				{	soap_flag_ns1__addTransRecInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addTransRecInfo(struct soap *soap, const struct __ns1__addTransRecInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addTransRecInfo(soap, tag?tag:"-ns1:addTransRecInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addTransRecInfo * SOAP_FMAC4 soap_get___ns1__addTransRecInfo(struct soap *soap, struct __ns1__addTransRecInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addTransRecInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__addTransRecInfo * SOAP_FMAC2 soap_instantiate___ns1__addTransRecInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addTransRecInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__addTransRecInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__addTransRecInfo);
		if (size)
			*size = sizeof(struct __ns1__addTransRecInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__addTransRecInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__addTransRecInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__addTransRecInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__addTransRecInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__addTransRecInfo %p -> %p\n", q, p));
	*(struct __ns1__addTransRecInfo*)p = *(struct __ns1__addTransRecInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetJdsbhRecoveryInfo(struct soap *soap, struct __ns1__GetJdsbhRecoveryInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetJdsbhRecoveryInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetJdsbhRecoveryInfo(struct soap *soap, const struct __ns1__GetJdsbhRecoveryInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetJdsbhRecoveryInfo(soap, &a->ns1__GetJdsbhRecoveryInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetJdsbhRecoveryInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetJdsbhRecoveryInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetJdsbhRecoveryInfo(soap, "ns1:GetJdsbhRecoveryInfo", -1, &a->ns1__GetJdsbhRecoveryInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetJdsbhRecoveryInfo * SOAP_FMAC4 soap_in___ns1__GetJdsbhRecoveryInfo(struct soap *soap, const char *tag, struct __ns1__GetJdsbhRecoveryInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetJdsbhRecoveryInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetJdsbhRecoveryInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetJdsbhRecoveryInfo, sizeof(struct __ns1__GetJdsbhRecoveryInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetJdsbhRecoveryInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetJdsbhRecoveryInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetJdsbhRecoveryInfo(soap, "ns1:GetJdsbhRecoveryInfo", &a->ns1__GetJdsbhRecoveryInfo, ""))
				{	soap_flag_ns1__GetJdsbhRecoveryInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetJdsbhRecoveryInfo(struct soap *soap, const struct __ns1__GetJdsbhRecoveryInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetJdsbhRecoveryInfo(soap, tag?tag:"-ns1:GetJdsbhRecoveryInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetJdsbhRecoveryInfo * SOAP_FMAC4 soap_get___ns1__GetJdsbhRecoveryInfo(struct soap *soap, struct __ns1__GetJdsbhRecoveryInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetJdsbhRecoveryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetJdsbhRecoveryInfo * SOAP_FMAC2 soap_instantiate___ns1__GetJdsbhRecoveryInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetJdsbhRecoveryInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetJdsbhRecoveryInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetJdsbhRecoveryInfo);
		if (size)
			*size = sizeof(struct __ns1__GetJdsbhRecoveryInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetJdsbhRecoveryInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetJdsbhRecoveryInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetJdsbhRecoveryInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetJdsbhRecoveryInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetJdsbhRecoveryInfo %p -> %p\n", q, p));
	*(struct __ns1__GetJdsbhRecoveryInfo*)p = *(struct __ns1__GetJdsbhRecoveryInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetJdsbhRecovery(struct soap *soap, struct __ns1__GetJdsbhRecovery *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetJdsbhRecovery = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetJdsbhRecovery(struct soap *soap, const struct __ns1__GetJdsbhRecovery *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetJdsbhRecovery(soap, &a->ns1__GetJdsbhRecovery);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetJdsbhRecovery(struct soap *soap, const char *tag, int id, const struct __ns1__GetJdsbhRecovery *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetJdsbhRecovery(soap, "ns1:GetJdsbhRecovery", -1, &a->ns1__GetJdsbhRecovery, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetJdsbhRecovery * SOAP_FMAC4 soap_in___ns1__GetJdsbhRecovery(struct soap *soap, const char *tag, struct __ns1__GetJdsbhRecovery *a, const char *type)
{
	size_t soap_flag_ns1__GetJdsbhRecovery = 1;
	short soap_flag;
	a = (struct __ns1__GetJdsbhRecovery *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetJdsbhRecovery, sizeof(struct __ns1__GetJdsbhRecovery), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetJdsbhRecovery(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetJdsbhRecovery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetJdsbhRecovery(soap, "ns1:GetJdsbhRecovery", &a->ns1__GetJdsbhRecovery, ""))
				{	soap_flag_ns1__GetJdsbhRecovery--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetJdsbhRecovery(struct soap *soap, const struct __ns1__GetJdsbhRecovery *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetJdsbhRecovery(soap, tag?tag:"-ns1:GetJdsbhRecovery", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetJdsbhRecovery * SOAP_FMAC4 soap_get___ns1__GetJdsbhRecovery(struct soap *soap, struct __ns1__GetJdsbhRecovery *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetJdsbhRecovery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetJdsbhRecovery * SOAP_FMAC2 soap_instantiate___ns1__GetJdsbhRecovery(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetJdsbhRecovery(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetJdsbhRecovery, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetJdsbhRecovery);
		if (size)
			*size = sizeof(struct __ns1__GetJdsbhRecovery);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetJdsbhRecovery, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetJdsbhRecovery);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetJdsbhRecovery*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetJdsbhRecovery(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetJdsbhRecovery %p -> %p\n", q, p));
	*(struct __ns1__GetJdsbhRecovery*)p = *(struct __ns1__GetJdsbhRecovery*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetViolationInfo(struct soap *soap, struct __ns1__GetViolationInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetViolationInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetViolationInfo(struct soap *soap, const struct __ns1__GetViolationInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetViolationInfo(soap, &a->ns1__GetViolationInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetViolationInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetViolationInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetViolationInfo(soap, "ns1:GetViolationInfo", -1, &a->ns1__GetViolationInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetViolationInfo * SOAP_FMAC4 soap_in___ns1__GetViolationInfo(struct soap *soap, const char *tag, struct __ns1__GetViolationInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetViolationInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetViolationInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetViolationInfo, sizeof(struct __ns1__GetViolationInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetViolationInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetViolationInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetViolationInfo(soap, "ns1:GetViolationInfo", &a->ns1__GetViolationInfo, ""))
				{	soap_flag_ns1__GetViolationInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetViolationInfo(struct soap *soap, const struct __ns1__GetViolationInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetViolationInfo(soap, tag?tag:"-ns1:GetViolationInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetViolationInfo * SOAP_FMAC4 soap_get___ns1__GetViolationInfo(struct soap *soap, struct __ns1__GetViolationInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetViolationInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetViolationInfo * SOAP_FMAC2 soap_instantiate___ns1__GetViolationInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetViolationInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetViolationInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetViolationInfo);
		if (size)
			*size = sizeof(struct __ns1__GetViolationInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetViolationInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetViolationInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetViolationInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetViolationInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetViolationInfo %p -> %p\n", q, p));
	*(struct __ns1__GetViolationInfo*)p = *(struct __ns1__GetViolationInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InViolationInfo(struct soap *soap, struct __ns1__InViolationInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InViolationInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InViolationInfo(struct soap *soap, const struct __ns1__InViolationInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__InViolationInfo(soap, &a->ns1__InViolationInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InViolationInfo(struct soap *soap, const char *tag, int id, const struct __ns1__InViolationInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__InViolationInfo(soap, "ns1:InViolationInfo", -1, &a->ns1__InViolationInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InViolationInfo * SOAP_FMAC4 soap_in___ns1__InViolationInfo(struct soap *soap, const char *tag, struct __ns1__InViolationInfo *a, const char *type)
{
	size_t soap_flag_ns1__InViolationInfo = 1;
	short soap_flag;
	a = (struct __ns1__InViolationInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InViolationInfo, sizeof(struct __ns1__InViolationInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InViolationInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InViolationInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__InViolationInfo(soap, "ns1:InViolationInfo", &a->ns1__InViolationInfo, ""))
				{	soap_flag_ns1__InViolationInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InViolationInfo(struct soap *soap, const struct __ns1__InViolationInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__InViolationInfo(soap, tag?tag:"-ns1:InViolationInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InViolationInfo * SOAP_FMAC4 soap_get___ns1__InViolationInfo(struct soap *soap, struct __ns1__InViolationInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InViolationInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__InViolationInfo * SOAP_FMAC2 soap_instantiate___ns1__InViolationInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InViolationInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__InViolationInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__InViolationInfo);
		if (size)
			*size = sizeof(struct __ns1__InViolationInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__InViolationInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__InViolationInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__InViolationInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__InViolationInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__InViolationInfo %p -> %p\n", q, p));
	*(struct __ns1__InViolationInfo*)p = *(struct __ns1__InViolationInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdataDeviceState(struct soap *soap, struct __ns1__UpdataDeviceState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdataDeviceState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdataDeviceState(struct soap *soap, const struct __ns1__UpdataDeviceState *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UpdataDeviceState(soap, &a->ns1__UpdataDeviceState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdataDeviceState(struct soap *soap, const char *tag, int id, const struct __ns1__UpdataDeviceState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__UpdataDeviceState(soap, "ns1:UpdataDeviceState", -1, &a->ns1__UpdataDeviceState, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdataDeviceState * SOAP_FMAC4 soap_in___ns1__UpdataDeviceState(struct soap *soap, const char *tag, struct __ns1__UpdataDeviceState *a, const char *type)
{
	size_t soap_flag_ns1__UpdataDeviceState = 1;
	short soap_flag;
	a = (struct __ns1__UpdataDeviceState *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpdataDeviceState, sizeof(struct __ns1__UpdataDeviceState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdataDeviceState(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdataDeviceState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdataDeviceState(soap, "ns1:UpdataDeviceState", &a->ns1__UpdataDeviceState, ""))
				{	soap_flag_ns1__UpdataDeviceState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdataDeviceState(struct soap *soap, const struct __ns1__UpdataDeviceState *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__UpdataDeviceState(soap, tag?tag:"-ns1:UpdataDeviceState", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdataDeviceState * SOAP_FMAC4 soap_get___ns1__UpdataDeviceState(struct soap *soap, struct __ns1__UpdataDeviceState *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdataDeviceState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__UpdataDeviceState * SOAP_FMAC2 soap_instantiate___ns1__UpdataDeviceState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdataDeviceState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UpdataDeviceState, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__UpdataDeviceState);
		if (size)
			*size = sizeof(struct __ns1__UpdataDeviceState);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__UpdataDeviceState, n);
		if (size)
			*size = n * sizeof(struct __ns1__UpdataDeviceState);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__UpdataDeviceState*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UpdataDeviceState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UpdataDeviceState %p -> %p\n", q, p));
	*(struct __ns1__UpdataDeviceState*)p = *(struct __ns1__UpdataDeviceState*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAlarmInfo(struct soap *soap, struct __ns1__GetAlarmInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAlarmInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAlarmInfo(struct soap *soap, const struct __ns1__GetAlarmInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetAlarmInfo(soap, &a->ns1__GetAlarmInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAlarmInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetAlarmInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetAlarmInfo(soap, "ns1:GetAlarmInfo", -1, &a->ns1__GetAlarmInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAlarmInfo * SOAP_FMAC4 soap_in___ns1__GetAlarmInfo(struct soap *soap, const char *tag, struct __ns1__GetAlarmInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetAlarmInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetAlarmInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAlarmInfo, sizeof(struct __ns1__GetAlarmInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAlarmInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAlarmInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAlarmInfo(soap, "ns1:GetAlarmInfo", &a->ns1__GetAlarmInfo, ""))
				{	soap_flag_ns1__GetAlarmInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAlarmInfo(struct soap *soap, const struct __ns1__GetAlarmInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetAlarmInfo(soap, tag?tag:"-ns1:GetAlarmInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAlarmInfo * SOAP_FMAC4 soap_get___ns1__GetAlarmInfo(struct soap *soap, struct __ns1__GetAlarmInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAlarmInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetAlarmInfo * SOAP_FMAC2 soap_instantiate___ns1__GetAlarmInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAlarmInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetAlarmInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetAlarmInfo);
		if (size)
			*size = sizeof(struct __ns1__GetAlarmInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetAlarmInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetAlarmInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetAlarmInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetAlarmInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetAlarmInfo %p -> %p\n", q, p));
	*(struct __ns1__GetAlarmInfo*)p = *(struct __ns1__GetAlarmInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdateVioPeccancyInfo(struct soap *soap, struct __ns1__UpdateVioPeccancyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdateVioPeccancyInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdateVioPeccancyInfo(struct soap *soap, const struct __ns1__UpdateVioPeccancyInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UpdateVioPeccancyInfo(soap, &a->ns1__UpdateVioPeccancyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdateVioPeccancyInfo(struct soap *soap, const char *tag, int id, const struct __ns1__UpdateVioPeccancyInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__UpdateVioPeccancyInfo(soap, "ns1:UpdateVioPeccancyInfo", -1, &a->ns1__UpdateVioPeccancyInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateVioPeccancyInfo * SOAP_FMAC4 soap_in___ns1__UpdateVioPeccancyInfo(struct soap *soap, const char *tag, struct __ns1__UpdateVioPeccancyInfo *a, const char *type)
{
	size_t soap_flag_ns1__UpdateVioPeccancyInfo = 1;
	short soap_flag;
	a = (struct __ns1__UpdateVioPeccancyInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpdateVioPeccancyInfo, sizeof(struct __ns1__UpdateVioPeccancyInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdateVioPeccancyInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdateVioPeccancyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdateVioPeccancyInfo(soap, "ns1:UpdateVioPeccancyInfo", &a->ns1__UpdateVioPeccancyInfo, ""))
				{	soap_flag_ns1__UpdateVioPeccancyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdateVioPeccancyInfo(struct soap *soap, const struct __ns1__UpdateVioPeccancyInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__UpdateVioPeccancyInfo(soap, tag?tag:"-ns1:UpdateVioPeccancyInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdateVioPeccancyInfo * SOAP_FMAC4 soap_get___ns1__UpdateVioPeccancyInfo(struct soap *soap, struct __ns1__UpdateVioPeccancyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdateVioPeccancyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__UpdateVioPeccancyInfo * SOAP_FMAC2 soap_instantiate___ns1__UpdateVioPeccancyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdateVioPeccancyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UpdateVioPeccancyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__UpdateVioPeccancyInfo);
		if (size)
			*size = sizeof(struct __ns1__UpdateVioPeccancyInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__UpdateVioPeccancyInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__UpdateVioPeccancyInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__UpdateVioPeccancyInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UpdateVioPeccancyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UpdateVioPeccancyInfo %p -> %p\n", q, p));
	*(struct __ns1__UpdateVioPeccancyInfo*)p = *(struct __ns1__UpdateVioPeccancyInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetVioPeccancyNoCheckInfo(struct soap *soap, struct __ns1__GetVioPeccancyNoCheckInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetVioPeccancyNoCheckInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetVioPeccancyNoCheckInfo(struct soap *soap, const struct __ns1__GetVioPeccancyNoCheckInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetVioPeccancyNoCheckInfo(soap, &a->ns1__GetVioPeccancyNoCheckInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetVioPeccancyNoCheckInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetVioPeccancyNoCheckInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetVioPeccancyNoCheckInfo(soap, "ns1:GetVioPeccancyNoCheckInfo", -1, &a->ns1__GetVioPeccancyNoCheckInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetVioPeccancyNoCheckInfo * SOAP_FMAC4 soap_in___ns1__GetVioPeccancyNoCheckInfo(struct soap *soap, const char *tag, struct __ns1__GetVioPeccancyNoCheckInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetVioPeccancyNoCheckInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetVioPeccancyNoCheckInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetVioPeccancyNoCheckInfo, sizeof(struct __ns1__GetVioPeccancyNoCheckInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetVioPeccancyNoCheckInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetVioPeccancyNoCheckInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetVioPeccancyNoCheckInfo(soap, "ns1:GetVioPeccancyNoCheckInfo", &a->ns1__GetVioPeccancyNoCheckInfo, ""))
				{	soap_flag_ns1__GetVioPeccancyNoCheckInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetVioPeccancyNoCheckInfo(struct soap *soap, const struct __ns1__GetVioPeccancyNoCheckInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetVioPeccancyNoCheckInfo(soap, tag?tag:"-ns1:GetVioPeccancyNoCheckInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetVioPeccancyNoCheckInfo * SOAP_FMAC4 soap_get___ns1__GetVioPeccancyNoCheckInfo(struct soap *soap, struct __ns1__GetVioPeccancyNoCheckInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetVioPeccancyNoCheckInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetVioPeccancyNoCheckInfo * SOAP_FMAC2 soap_instantiate___ns1__GetVioPeccancyNoCheckInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetVioPeccancyNoCheckInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetVioPeccancyNoCheckInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetVioPeccancyNoCheckInfo);
		if (size)
			*size = sizeof(struct __ns1__GetVioPeccancyNoCheckInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetVioPeccancyNoCheckInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetVioPeccancyNoCheckInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetVioPeccancyNoCheckInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetVioPeccancyNoCheckInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetVioPeccancyNoCheckInfo %p -> %p\n", q, p));
	*(struct __ns1__GetVioPeccancyNoCheckInfo*)p = *(struct __ns1__GetVioPeccancyNoCheckInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__UpdatePeccancyInfo(struct soap *soap, struct __ns1__UpdatePeccancyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__UpdatePeccancyInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__UpdatePeccancyInfo(struct soap *soap, const struct __ns1__UpdatePeccancyInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__UpdatePeccancyInfo(soap, &a->ns1__UpdatePeccancyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__UpdatePeccancyInfo(struct soap *soap, const char *tag, int id, const struct __ns1__UpdatePeccancyInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__UpdatePeccancyInfo(soap, "ns1:UpdatePeccancyInfo", -1, &a->ns1__UpdatePeccancyInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdatePeccancyInfo * SOAP_FMAC4 soap_in___ns1__UpdatePeccancyInfo(struct soap *soap, const char *tag, struct __ns1__UpdatePeccancyInfo *a, const char *type)
{
	size_t soap_flag_ns1__UpdatePeccancyInfo = 1;
	short soap_flag;
	a = (struct __ns1__UpdatePeccancyInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__UpdatePeccancyInfo, sizeof(struct __ns1__UpdatePeccancyInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__UpdatePeccancyInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__UpdatePeccancyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__UpdatePeccancyInfo(soap, "ns1:UpdatePeccancyInfo", &a->ns1__UpdatePeccancyInfo, ""))
				{	soap_flag_ns1__UpdatePeccancyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__UpdatePeccancyInfo(struct soap *soap, const struct __ns1__UpdatePeccancyInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__UpdatePeccancyInfo(soap, tag?tag:"-ns1:UpdatePeccancyInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__UpdatePeccancyInfo * SOAP_FMAC4 soap_get___ns1__UpdatePeccancyInfo(struct soap *soap, struct __ns1__UpdatePeccancyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__UpdatePeccancyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__UpdatePeccancyInfo * SOAP_FMAC2 soap_instantiate___ns1__UpdatePeccancyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__UpdatePeccancyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__UpdatePeccancyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__UpdatePeccancyInfo);
		if (size)
			*size = sizeof(struct __ns1__UpdatePeccancyInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__UpdatePeccancyInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__UpdatePeccancyInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__UpdatePeccancyInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__UpdatePeccancyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__UpdatePeccancyInfo %p -> %p\n", q, p));
	*(struct __ns1__UpdatePeccancyInfo*)p = *(struct __ns1__UpdatePeccancyInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetPeccancyNoCheckInfo(struct soap *soap, struct __ns1__GetPeccancyNoCheckInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPeccancyNoCheckInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetPeccancyNoCheckInfo(struct soap *soap, const struct __ns1__GetPeccancyNoCheckInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPeccancyNoCheckInfo(soap, &a->ns1__GetPeccancyNoCheckInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetPeccancyNoCheckInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetPeccancyNoCheckInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetPeccancyNoCheckInfo(soap, "ns1:GetPeccancyNoCheckInfo", -1, &a->ns1__GetPeccancyNoCheckInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPeccancyNoCheckInfo * SOAP_FMAC4 soap_in___ns1__GetPeccancyNoCheckInfo(struct soap *soap, const char *tag, struct __ns1__GetPeccancyNoCheckInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetPeccancyNoCheckInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetPeccancyNoCheckInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetPeccancyNoCheckInfo, sizeof(struct __ns1__GetPeccancyNoCheckInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetPeccancyNoCheckInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPeccancyNoCheckInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPeccancyNoCheckInfo(soap, "ns1:GetPeccancyNoCheckInfo", &a->ns1__GetPeccancyNoCheckInfo, ""))
				{	soap_flag_ns1__GetPeccancyNoCheckInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetPeccancyNoCheckInfo(struct soap *soap, const struct __ns1__GetPeccancyNoCheckInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetPeccancyNoCheckInfo(soap, tag?tag:"-ns1:GetPeccancyNoCheckInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPeccancyNoCheckInfo * SOAP_FMAC4 soap_get___ns1__GetPeccancyNoCheckInfo(struct soap *soap, struct __ns1__GetPeccancyNoCheckInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetPeccancyNoCheckInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetPeccancyNoCheckInfo * SOAP_FMAC2 soap_instantiate___ns1__GetPeccancyNoCheckInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetPeccancyNoCheckInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetPeccancyNoCheckInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetPeccancyNoCheckInfo);
		if (size)
			*size = sizeof(struct __ns1__GetPeccancyNoCheckInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetPeccancyNoCheckInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetPeccancyNoCheckInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetPeccancyNoCheckInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetPeccancyNoCheckInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetPeccancyNoCheckInfo %p -> %p\n", q, p));
	*(struct __ns1__GetPeccancyNoCheckInfo*)p = *(struct __ns1__GetPeccancyNoCheckInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetPeccancyInfo(struct soap *soap, struct __ns1__GetPeccancyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPeccancyInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetPeccancyInfo(struct soap *soap, const struct __ns1__GetPeccancyInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPeccancyInfo(soap, &a->ns1__GetPeccancyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetPeccancyInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetPeccancyInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetPeccancyInfo(soap, "ns1:GetPeccancyInfo", -1, &a->ns1__GetPeccancyInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPeccancyInfo * SOAP_FMAC4 soap_in___ns1__GetPeccancyInfo(struct soap *soap, const char *tag, struct __ns1__GetPeccancyInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetPeccancyInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetPeccancyInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetPeccancyInfo, sizeof(struct __ns1__GetPeccancyInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetPeccancyInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPeccancyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPeccancyInfo(soap, "ns1:GetPeccancyInfo", &a->ns1__GetPeccancyInfo, ""))
				{	soap_flag_ns1__GetPeccancyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetPeccancyInfo(struct soap *soap, const struct __ns1__GetPeccancyInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetPeccancyInfo(soap, tag?tag:"-ns1:GetPeccancyInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPeccancyInfo * SOAP_FMAC4 soap_get___ns1__GetPeccancyInfo(struct soap *soap, struct __ns1__GetPeccancyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetPeccancyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetPeccancyInfo * SOAP_FMAC2 soap_instantiate___ns1__GetPeccancyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetPeccancyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetPeccancyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetPeccancyInfo);
		if (size)
			*size = sizeof(struct __ns1__GetPeccancyInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetPeccancyInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetPeccancyInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetPeccancyInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetPeccancyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetPeccancyInfo %p -> %p\n", q, p));
	*(struct __ns1__GetPeccancyInfo*)p = *(struct __ns1__GetPeccancyInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetPassCarInfo(struct soap *soap, struct __ns1__GetPassCarInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetPassCarInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetPassCarInfo(struct soap *soap, const struct __ns1__GetPassCarInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetPassCarInfo(soap, &a->ns1__GetPassCarInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetPassCarInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetPassCarInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetPassCarInfo(soap, "ns1:GetPassCarInfo", -1, &a->ns1__GetPassCarInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPassCarInfo * SOAP_FMAC4 soap_in___ns1__GetPassCarInfo(struct soap *soap, const char *tag, struct __ns1__GetPassCarInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetPassCarInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetPassCarInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetPassCarInfo, sizeof(struct __ns1__GetPassCarInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetPassCarInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetPassCarInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetPassCarInfo(soap, "ns1:GetPassCarInfo", &a->ns1__GetPassCarInfo, ""))
				{	soap_flag_ns1__GetPassCarInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetPassCarInfo(struct soap *soap, const struct __ns1__GetPassCarInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetPassCarInfo(soap, tag?tag:"-ns1:GetPassCarInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetPassCarInfo * SOAP_FMAC4 soap_get___ns1__GetPassCarInfo(struct soap *soap, struct __ns1__GetPassCarInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetPassCarInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetPassCarInfo * SOAP_FMAC2 soap_instantiate___ns1__GetPassCarInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetPassCarInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetPassCarInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetPassCarInfo);
		if (size)
			*size = sizeof(struct __ns1__GetPassCarInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetPassCarInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetPassCarInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetPassCarInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetPassCarInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetPassCarInfo %p -> %p\n", q, p));
	*(struct __ns1__GetPassCarInfo*)p = *(struct __ns1__GetPassCarInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetLocationInfo(struct soap *soap, struct __ns1__GetLocationInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetLocationInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetLocationInfo(struct soap *soap, const struct __ns1__GetLocationInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetLocationInfo(soap, &a->ns1__GetLocationInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetLocationInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetLocationInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetLocationInfo(soap, "ns1:GetLocationInfo", -1, &a->ns1__GetLocationInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLocationInfo * SOAP_FMAC4 soap_in___ns1__GetLocationInfo(struct soap *soap, const char *tag, struct __ns1__GetLocationInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetLocationInfo = 1;
	short soap_flag;
	a = (struct __ns1__GetLocationInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetLocationInfo, sizeof(struct __ns1__GetLocationInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetLocationInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetLocationInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetLocationInfo(soap, "ns1:GetLocationInfo", &a->ns1__GetLocationInfo, ""))
				{	soap_flag_ns1__GetLocationInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetLocationInfo(struct soap *soap, const struct __ns1__GetLocationInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetLocationInfo(soap, tag?tag:"-ns1:GetLocationInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetLocationInfo * SOAP_FMAC4 soap_get___ns1__GetLocationInfo(struct soap *soap, struct __ns1__GetLocationInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetLocationInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetLocationInfo * SOAP_FMAC2 soap_instantiate___ns1__GetLocationInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetLocationInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetLocationInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetLocationInfo);
		if (size)
			*size = sizeof(struct __ns1__GetLocationInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetLocationInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetLocationInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetLocationInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetLocationInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetLocationInfo %p -> %p\n", q, p));
	*(struct __ns1__GetLocationInfo*)p = *(struct __ns1__GetLocationInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__RevokeSuspicionInfo(struct soap *soap, struct __ns1__RevokeSuspicionInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RevokeSuspicionInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__RevokeSuspicionInfo(struct soap *soap, const struct __ns1__RevokeSuspicionInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__RevokeSuspicionInfo(soap, &a->ns1__RevokeSuspicionInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__RevokeSuspicionInfo(struct soap *soap, const char *tag, int id, const struct __ns1__RevokeSuspicionInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__RevokeSuspicionInfo(soap, "ns1:RevokeSuspicionInfo", -1, &a->ns1__RevokeSuspicionInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RevokeSuspicionInfo * SOAP_FMAC4 soap_in___ns1__RevokeSuspicionInfo(struct soap *soap, const char *tag, struct __ns1__RevokeSuspicionInfo *a, const char *type)
{
	size_t soap_flag_ns1__RevokeSuspicionInfo = 1;
	short soap_flag;
	a = (struct __ns1__RevokeSuspicionInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__RevokeSuspicionInfo, sizeof(struct __ns1__RevokeSuspicionInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__RevokeSuspicionInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RevokeSuspicionInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RevokeSuspicionInfo(soap, "ns1:RevokeSuspicionInfo", &a->ns1__RevokeSuspicionInfo, ""))
				{	soap_flag_ns1__RevokeSuspicionInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__RevokeSuspicionInfo(struct soap *soap, const struct __ns1__RevokeSuspicionInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__RevokeSuspicionInfo(soap, tag?tag:"-ns1:RevokeSuspicionInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RevokeSuspicionInfo * SOAP_FMAC4 soap_get___ns1__RevokeSuspicionInfo(struct soap *soap, struct __ns1__RevokeSuspicionInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__RevokeSuspicionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__RevokeSuspicionInfo * SOAP_FMAC2 soap_instantiate___ns1__RevokeSuspicionInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__RevokeSuspicionInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__RevokeSuspicionInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__RevokeSuspicionInfo);
		if (size)
			*size = sizeof(struct __ns1__RevokeSuspicionInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__RevokeSuspicionInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__RevokeSuspicionInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__RevokeSuspicionInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__RevokeSuspicionInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__RevokeSuspicionInfo %p -> %p\n", q, p));
	*(struct __ns1__RevokeSuspicionInfo*)p = *(struct __ns1__RevokeSuspicionInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InSuspicionInfo(struct soap *soap, struct __ns1__InSuspicionInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InSuspicionInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InSuspicionInfo(struct soap *soap, const struct __ns1__InSuspicionInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__InSuspicionInfo(soap, &a->ns1__InSuspicionInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InSuspicionInfo(struct soap *soap, const char *tag, int id, const struct __ns1__InSuspicionInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__InSuspicionInfo(soap, "ns1:InSuspicionInfo", -1, &a->ns1__InSuspicionInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InSuspicionInfo * SOAP_FMAC4 soap_in___ns1__InSuspicionInfo(struct soap *soap, const char *tag, struct __ns1__InSuspicionInfo *a, const char *type)
{
	size_t soap_flag_ns1__InSuspicionInfo = 1;
	short soap_flag;
	a = (struct __ns1__InSuspicionInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InSuspicionInfo, sizeof(struct __ns1__InSuspicionInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InSuspicionInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InSuspicionInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__InSuspicionInfo(soap, "ns1:InSuspicionInfo", &a->ns1__InSuspicionInfo, ""))
				{	soap_flag_ns1__InSuspicionInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InSuspicionInfo(struct soap *soap, const struct __ns1__InSuspicionInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__InSuspicionInfo(soap, tag?tag:"-ns1:InSuspicionInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InSuspicionInfo * SOAP_FMAC4 soap_get___ns1__InSuspicionInfo(struct soap *soap, struct __ns1__InSuspicionInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InSuspicionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__InSuspicionInfo * SOAP_FMAC2 soap_instantiate___ns1__InSuspicionInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InSuspicionInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__InSuspicionInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__InSuspicionInfo);
		if (size)
			*size = sizeof(struct __ns1__InSuspicionInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__InSuspicionInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__InSuspicionInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__InSuspicionInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__InSuspicionInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__InSuspicionInfo %p -> %p\n", q, p));
	*(struct __ns1__InSuspicionInfo*)p = *(struct __ns1__InSuspicionInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__IntExtralistInfo(struct soap *soap, struct __ns1__IntExtralistInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__IntExtralistInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__IntExtralistInfo(struct soap *soap, const struct __ns1__IntExtralistInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__IntExtralistInfo(soap, &a->ns1__IntExtralistInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__IntExtralistInfo(struct soap *soap, const char *tag, int id, const struct __ns1__IntExtralistInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__IntExtralistInfo(soap, "ns1:IntExtralistInfo", -1, &a->ns1__IntExtralistInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__IntExtralistInfo * SOAP_FMAC4 soap_in___ns1__IntExtralistInfo(struct soap *soap, const char *tag, struct __ns1__IntExtralistInfo *a, const char *type)
{
	size_t soap_flag_ns1__IntExtralistInfo = 1;
	short soap_flag;
	a = (struct __ns1__IntExtralistInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__IntExtralistInfo, sizeof(struct __ns1__IntExtralistInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__IntExtralistInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__IntExtralistInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__IntExtralistInfo(soap, "ns1:IntExtralistInfo", &a->ns1__IntExtralistInfo, ""))
				{	soap_flag_ns1__IntExtralistInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__IntExtralistInfo(struct soap *soap, const struct __ns1__IntExtralistInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__IntExtralistInfo(soap, tag?tag:"-ns1:IntExtralistInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__IntExtralistInfo * SOAP_FMAC4 soap_get___ns1__IntExtralistInfo(struct soap *soap, struct __ns1__IntExtralistInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__IntExtralistInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__IntExtralistInfo * SOAP_FMAC2 soap_instantiate___ns1__IntExtralistInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__IntExtralistInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__IntExtralistInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__IntExtralistInfo);
		if (size)
			*size = sizeof(struct __ns1__IntExtralistInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__IntExtralistInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__IntExtralistInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__IntExtralistInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__IntExtralistInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__IntExtralistInfo %p -> %p\n", q, p));
	*(struct __ns1__IntExtralistInfo*)p = *(struct __ns1__IntExtralistInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InChecklessInfo(struct soap *soap, struct __ns1__InChecklessInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InChecklessInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InChecklessInfo(struct soap *soap, const struct __ns1__InChecklessInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__InChecklessInfo(soap, &a->ns1__InChecklessInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InChecklessInfo(struct soap *soap, const char *tag, int id, const struct __ns1__InChecklessInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__InChecklessInfo(soap, "ns1:InChecklessInfo", -1, &a->ns1__InChecklessInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InChecklessInfo * SOAP_FMAC4 soap_in___ns1__InChecklessInfo(struct soap *soap, const char *tag, struct __ns1__InChecklessInfo *a, const char *type)
{
	size_t soap_flag_ns1__InChecklessInfo = 1;
	short soap_flag;
	a = (struct __ns1__InChecklessInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InChecklessInfo, sizeof(struct __ns1__InChecklessInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InChecklessInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InChecklessInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__InChecklessInfo(soap, "ns1:InChecklessInfo", &a->ns1__InChecklessInfo, ""))
				{	soap_flag_ns1__InChecklessInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InChecklessInfo(struct soap *soap, const struct __ns1__InChecklessInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__InChecklessInfo(soap, tag?tag:"-ns1:InChecklessInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InChecklessInfo * SOAP_FMAC4 soap_get___ns1__InChecklessInfo(struct soap *soap, struct __ns1__InChecklessInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InChecklessInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__InChecklessInfo * SOAP_FMAC2 soap_instantiate___ns1__InChecklessInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InChecklessInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__InChecklessInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__InChecklessInfo);
		if (size)
			*size = sizeof(struct __ns1__InChecklessInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__InChecklessInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__InChecklessInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__InChecklessInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__InChecklessInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__InChecklessInfo %p -> %p\n", q, p));
	*(struct __ns1__InChecklessInfo*)p = *(struct __ns1__InChecklessInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InBlacklistInfo(struct soap *soap, struct __ns1__InBlacklistInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InBlacklistInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InBlacklistInfo(struct soap *soap, const struct __ns1__InBlacklistInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__InBlacklistInfo(soap, &a->ns1__InBlacklistInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InBlacklistInfo(struct soap *soap, const char *tag, int id, const struct __ns1__InBlacklistInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__InBlacklistInfo(soap, "ns1:InBlacklistInfo", -1, &a->ns1__InBlacklistInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InBlacklistInfo * SOAP_FMAC4 soap_in___ns1__InBlacklistInfo(struct soap *soap, const char *tag, struct __ns1__InBlacklistInfo *a, const char *type)
{
	size_t soap_flag_ns1__InBlacklistInfo = 1;
	short soap_flag;
	a = (struct __ns1__InBlacklistInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InBlacklistInfo, sizeof(struct __ns1__InBlacklistInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InBlacklistInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InBlacklistInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__InBlacklistInfo(soap, "ns1:InBlacklistInfo", &a->ns1__InBlacklistInfo, ""))
				{	soap_flag_ns1__InBlacklistInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InBlacklistInfo(struct soap *soap, const struct __ns1__InBlacklistInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__InBlacklistInfo(soap, tag?tag:"-ns1:InBlacklistInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InBlacklistInfo * SOAP_FMAC4 soap_get___ns1__InBlacklistInfo(struct soap *soap, struct __ns1__InBlacklistInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InBlacklistInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__InBlacklistInfo * SOAP_FMAC2 soap_instantiate___ns1__InBlacklistInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InBlacklistInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__InBlacklistInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__InBlacklistInfo);
		if (size)
			*size = sizeof(struct __ns1__InBlacklistInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__InBlacklistInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__InBlacklistInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__InBlacklistInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__InBlacklistInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__InBlacklistInfo %p -> %p\n", q, p));
	*(struct __ns1__InBlacklistInfo*)p = *(struct __ns1__InBlacklistInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InCheckedPeccancyInfo(struct soap *soap, struct __ns1__InCheckedPeccancyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InCheckedPeccancyInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InCheckedPeccancyInfo(struct soap *soap, const struct __ns1__InCheckedPeccancyInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__InCheckedPeccancyInfo(soap, &a->ns1__InCheckedPeccancyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InCheckedPeccancyInfo(struct soap *soap, const char *tag, int id, const struct __ns1__InCheckedPeccancyInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__InCheckedPeccancyInfo(soap, "ns1:InCheckedPeccancyInfo", -1, &a->ns1__InCheckedPeccancyInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InCheckedPeccancyInfo * SOAP_FMAC4 soap_in___ns1__InCheckedPeccancyInfo(struct soap *soap, const char *tag, struct __ns1__InCheckedPeccancyInfo *a, const char *type)
{
	size_t soap_flag_ns1__InCheckedPeccancyInfo = 1;
	short soap_flag;
	a = (struct __ns1__InCheckedPeccancyInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InCheckedPeccancyInfo, sizeof(struct __ns1__InCheckedPeccancyInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InCheckedPeccancyInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InCheckedPeccancyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__InCheckedPeccancyInfo(soap, "ns1:InCheckedPeccancyInfo", &a->ns1__InCheckedPeccancyInfo, ""))
				{	soap_flag_ns1__InCheckedPeccancyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InCheckedPeccancyInfo(struct soap *soap, const struct __ns1__InCheckedPeccancyInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__InCheckedPeccancyInfo(soap, tag?tag:"-ns1:InCheckedPeccancyInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InCheckedPeccancyInfo * SOAP_FMAC4 soap_get___ns1__InCheckedPeccancyInfo(struct soap *soap, struct __ns1__InCheckedPeccancyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InCheckedPeccancyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__InCheckedPeccancyInfo * SOAP_FMAC2 soap_instantiate___ns1__InCheckedPeccancyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InCheckedPeccancyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__InCheckedPeccancyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__InCheckedPeccancyInfo);
		if (size)
			*size = sizeof(struct __ns1__InCheckedPeccancyInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__InCheckedPeccancyInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__InCheckedPeccancyInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__InCheckedPeccancyInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__InCheckedPeccancyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__InCheckedPeccancyInfo %p -> %p\n", q, p));
	*(struct __ns1__InCheckedPeccancyInfo*)p = *(struct __ns1__InCheckedPeccancyInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InPeccancyInfo(struct soap *soap, struct __ns1__InPeccancyInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InPeccancyInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InPeccancyInfo(struct soap *soap, const struct __ns1__InPeccancyInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__InPeccancyInfo(soap, &a->ns1__InPeccancyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InPeccancyInfo(struct soap *soap, const char *tag, int id, const struct __ns1__InPeccancyInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__InPeccancyInfo(soap, "ns1:InPeccancyInfo", -1, &a->ns1__InPeccancyInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InPeccancyInfo * SOAP_FMAC4 soap_in___ns1__InPeccancyInfo(struct soap *soap, const char *tag, struct __ns1__InPeccancyInfo *a, const char *type)
{
	size_t soap_flag_ns1__InPeccancyInfo = 1;
	short soap_flag;
	a = (struct __ns1__InPeccancyInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InPeccancyInfo, sizeof(struct __ns1__InPeccancyInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InPeccancyInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InPeccancyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__InPeccancyInfo(soap, "ns1:InPeccancyInfo", &a->ns1__InPeccancyInfo, ""))
				{	soap_flag_ns1__InPeccancyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InPeccancyInfo(struct soap *soap, const struct __ns1__InPeccancyInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__InPeccancyInfo(soap, tag?tag:"-ns1:InPeccancyInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InPeccancyInfo * SOAP_FMAC4 soap_get___ns1__InPeccancyInfo(struct soap *soap, struct __ns1__InPeccancyInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InPeccancyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__InPeccancyInfo * SOAP_FMAC2 soap_instantiate___ns1__InPeccancyInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InPeccancyInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__InPeccancyInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__InPeccancyInfo);
		if (size)
			*size = sizeof(struct __ns1__InPeccancyInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__InPeccancyInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__InPeccancyInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__InPeccancyInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__InPeccancyInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__InPeccancyInfo %p -> %p\n", q, p));
	*(struct __ns1__InPeccancyInfo*)p = *(struct __ns1__InPeccancyInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__InPassCarInfo(struct soap *soap, struct __ns1__InPassCarInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__InPassCarInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__InPassCarInfo(struct soap *soap, const struct __ns1__InPassCarInfo *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__InPassCarInfo(soap, &a->ns1__InPassCarInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__InPassCarInfo(struct soap *soap, const char *tag, int id, const struct __ns1__InPassCarInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__InPassCarInfo(soap, "ns1:InPassCarInfo", -1, &a->ns1__InPassCarInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InPassCarInfo * SOAP_FMAC4 soap_in___ns1__InPassCarInfo(struct soap *soap, const char *tag, struct __ns1__InPassCarInfo *a, const char *type)
{
	size_t soap_flag_ns1__InPassCarInfo = 1;
	short soap_flag;
	a = (struct __ns1__InPassCarInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__InPassCarInfo, sizeof(struct __ns1__InPassCarInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__InPassCarInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__InPassCarInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__InPassCarInfo(soap, "ns1:InPassCarInfo", &a->ns1__InPassCarInfo, ""))
				{	soap_flag_ns1__InPassCarInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__InPassCarInfo(struct soap *soap, const struct __ns1__InPassCarInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__InPassCarInfo(soap, tag?tag:"-ns1:InPassCarInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__InPassCarInfo * SOAP_FMAC4 soap_get___ns1__InPassCarInfo(struct soap *soap, struct __ns1__InPassCarInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__InPassCarInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__InPassCarInfo * SOAP_FMAC2 soap_instantiate___ns1__InPassCarInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__InPassCarInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__InPassCarInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__InPassCarInfo);
		if (size)
			*size = sizeof(struct __ns1__InPassCarInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__InPassCarInfo, n);
		if (size)
			*size = n * sizeof(struct __ns1__InPassCarInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__InPassCarInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__InPassCarInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__InPassCarInfo %p -> %p\n", q, p));
	*(struct __ns1__InPassCarInfo*)p = *(struct __ns1__InPassCarInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CarPlateRecog(struct soap *soap, struct __ns1__CarPlateRecog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CarPlateRecog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CarPlateRecog(struct soap *soap, const struct __ns1__CarPlateRecog *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__CarPlateRecog(soap, &a->ns1__CarPlateRecog);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CarPlateRecog(struct soap *soap, const char *tag, int id, const struct __ns1__CarPlateRecog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__CarPlateRecog(soap, "ns1:CarPlateRecog", -1, &a->ns1__CarPlateRecog, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CarPlateRecog * SOAP_FMAC4 soap_in___ns1__CarPlateRecog(struct soap *soap, const char *tag, struct __ns1__CarPlateRecog *a, const char *type)
{
	size_t soap_flag_ns1__CarPlateRecog = 1;
	short soap_flag;
	a = (struct __ns1__CarPlateRecog *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CarPlateRecog, sizeof(struct __ns1__CarPlateRecog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CarPlateRecog(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CarPlateRecog && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CarPlateRecog(soap, "ns1:CarPlateRecog", &a->ns1__CarPlateRecog, ""))
				{	soap_flag_ns1__CarPlateRecog--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CarPlateRecog(struct soap *soap, const struct __ns1__CarPlateRecog *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__CarPlateRecog(soap, tag?tag:"-ns1:CarPlateRecog", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CarPlateRecog * SOAP_FMAC4 soap_get___ns1__CarPlateRecog(struct soap *soap, struct __ns1__CarPlateRecog *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CarPlateRecog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__CarPlateRecog * SOAP_FMAC2 soap_instantiate___ns1__CarPlateRecog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CarPlateRecog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__CarPlateRecog, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__CarPlateRecog);
		if (size)
			*size = sizeof(struct __ns1__CarPlateRecog);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__CarPlateRecog, n);
		if (size)
			*size = n * sizeof(struct __ns1__CarPlateRecog);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__CarPlateRecog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__CarPlateRecog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__CarPlateRecog %p -> %p\n", q, p));
	*(struct __ns1__CarPlateRecog*)p = *(struct __ns1__CarPlateRecog*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetXMlFormat(struct soap *soap, struct __ns1__GetXMlFormat *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetXMlFormat = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetXMlFormat(struct soap *soap, const struct __ns1__GetXMlFormat *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetXMlFormat(soap, &a->ns1__GetXMlFormat);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetXMlFormat(struct soap *soap, const char *tag, int id, const struct __ns1__GetXMlFormat *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetXMlFormat(soap, "ns1:GetXMlFormat", -1, &a->ns1__GetXMlFormat, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetXMlFormat * SOAP_FMAC4 soap_in___ns1__GetXMlFormat(struct soap *soap, const char *tag, struct __ns1__GetXMlFormat *a, const char *type)
{
	size_t soap_flag_ns1__GetXMlFormat = 1;
	short soap_flag;
	a = (struct __ns1__GetXMlFormat *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetXMlFormat, sizeof(struct __ns1__GetXMlFormat), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetXMlFormat(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetXMlFormat && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetXMlFormat(soap, "ns1:GetXMlFormat", &a->ns1__GetXMlFormat, ""))
				{	soap_flag_ns1__GetXMlFormat--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetXMlFormat(struct soap *soap, const struct __ns1__GetXMlFormat *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetXMlFormat(soap, tag?tag:"-ns1:GetXMlFormat", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetXMlFormat * SOAP_FMAC4 soap_get___ns1__GetXMlFormat(struct soap *soap, struct __ns1__GetXMlFormat *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetXMlFormat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetXMlFormat * SOAP_FMAC2 soap_instantiate___ns1__GetXMlFormat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetXMlFormat(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetXMlFormat, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetXMlFormat);
		if (size)
			*size = sizeof(struct __ns1__GetXMlFormat);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetXMlFormat, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetXMlFormat);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetXMlFormat*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetXMlFormat(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetXMlFormat %p -> %p\n", q, p));
	*(struct __ns1__GetXMlFormat*)p = *(struct __ns1__GetXMlFormat*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetCurrentVersion(struct soap *soap, struct __ns1__GetCurrentVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetCurrentVersion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetCurrentVersion(struct soap *soap, const struct __ns1__GetCurrentVersion *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__GetCurrentVersion(soap, &a->ns1__GetCurrentVersion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetCurrentVersion(struct soap *soap, const char *tag, int id, const struct __ns1__GetCurrentVersion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__GetCurrentVersion(soap, "ns1:GetCurrentVersion", -1, &a->ns1__GetCurrentVersion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetCurrentVersion * SOAP_FMAC4 soap_in___ns1__GetCurrentVersion(struct soap *soap, const char *tag, struct __ns1__GetCurrentVersion *a, const char *type)
{
	size_t soap_flag_ns1__GetCurrentVersion = 1;
	short soap_flag;
	a = (struct __ns1__GetCurrentVersion *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetCurrentVersion, sizeof(struct __ns1__GetCurrentVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetCurrentVersion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetCurrentVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetCurrentVersion(soap, "ns1:GetCurrentVersion", &a->ns1__GetCurrentVersion, ""))
				{	soap_flag_ns1__GetCurrentVersion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetCurrentVersion(struct soap *soap, const struct __ns1__GetCurrentVersion *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__GetCurrentVersion(soap, tag?tag:"-ns1:GetCurrentVersion", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetCurrentVersion * SOAP_FMAC4 soap_get___ns1__GetCurrentVersion(struct soap *soap, struct __ns1__GetCurrentVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetCurrentVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__GetCurrentVersion * SOAP_FMAC2 soap_instantiate___ns1__GetCurrentVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetCurrentVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__GetCurrentVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__GetCurrentVersion);
		if (size)
			*size = sizeof(struct __ns1__GetCurrentVersion);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__GetCurrentVersion, n);
		if (size)
			*size = n * sizeof(struct __ns1__GetCurrentVersion);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__GetCurrentVersion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__GetCurrentVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__GetCurrentVersion %p -> %p\n", q, p));
	*(struct __ns1__GetCurrentVersion*)p = *(struct __ns1__GetCurrentVersion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__WebserviceTest(struct soap *soap, struct __ns1__WebserviceTest *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__WebserviceTest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__WebserviceTest(struct soap *soap, const struct __ns1__WebserviceTest *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__WebserviceTest(soap, &a->ns1__WebserviceTest);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__WebserviceTest(struct soap *soap, const char *tag, int id, const struct __ns1__WebserviceTest *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_ns1__WebserviceTest(soap, "ns1:WebserviceTest", -1, &a->ns1__WebserviceTest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__WebserviceTest * SOAP_FMAC4 soap_in___ns1__WebserviceTest(struct soap *soap, const char *tag, struct __ns1__WebserviceTest *a, const char *type)
{
	size_t soap_flag_ns1__WebserviceTest = 1;
	short soap_flag;
	a = (struct __ns1__WebserviceTest *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__WebserviceTest, sizeof(struct __ns1__WebserviceTest), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__WebserviceTest(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__WebserviceTest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__WebserviceTest(soap, "ns1:WebserviceTest", &a->ns1__WebserviceTest, ""))
				{	soap_flag_ns1__WebserviceTest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__WebserviceTest(struct soap *soap, const struct __ns1__WebserviceTest *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__WebserviceTest(soap, tag?tag:"-ns1:WebserviceTest", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__WebserviceTest * SOAP_FMAC4 soap_get___ns1__WebserviceTest(struct soap *soap, struct __ns1__WebserviceTest *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__WebserviceTest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__WebserviceTest * SOAP_FMAC2 soap_instantiate___ns1__WebserviceTest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__WebserviceTest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__WebserviceTest, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__WebserviceTest);
		if (size)
			*size = sizeof(struct __ns1__WebserviceTest);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__WebserviceTest, n);
		if (size)
			*size = n * sizeof(struct __ns1__WebserviceTest);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__WebserviceTest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__WebserviceTest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__WebserviceTest %p -> %p\n", q, p));
	*(struct __ns1__WebserviceTest*)p = *(struct __ns1__WebserviceTest*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CheckUserInfoResponse(struct soap *soap, _ns1__CheckUserInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CheckUserInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CheckUserInfoResponse(struct soap *soap, const char *tag, int id, _ns1__CheckUserInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CheckUserInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CheckUserInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__CheckUserInfoResponse(struct soap *soap, const char *tag, _ns1__CheckUserInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CheckUserInfoResponse **)soap_malloc(soap, sizeof(_ns1__CheckUserInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CheckUserInfoResponse *)soap_instantiate__ns1__CheckUserInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__CheckUserInfoResponse ** p = (_ns1__CheckUserInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CheckUserInfoResponse, sizeof(_ns1__CheckUserInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CheckUserInfoResponse(struct soap *soap, _ns1__CheckUserInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__CheckUserInfoResponse);
	if (soap_out_PointerTo_ns1__CheckUserInfoResponse(soap, tag?tag:"ns1:CheckUserInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CheckUserInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__CheckUserInfoResponse(struct soap *soap, _ns1__CheckUserInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CheckUserInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CheckUserInfo(struct soap *soap, _ns1__CheckUserInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CheckUserInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CheckUserInfo(struct soap *soap, const char *tag, int id, _ns1__CheckUserInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CheckUserInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CheckUserInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__CheckUserInfo(struct soap *soap, const char *tag, _ns1__CheckUserInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CheckUserInfo **)soap_malloc(soap, sizeof(_ns1__CheckUserInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CheckUserInfo *)soap_instantiate__ns1__CheckUserInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__CheckUserInfo ** p = (_ns1__CheckUserInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CheckUserInfo, sizeof(_ns1__CheckUserInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CheckUserInfo(struct soap *soap, _ns1__CheckUserInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__CheckUserInfo);
	if (soap_out_PointerTo_ns1__CheckUserInfo(soap, tag?tag:"ns1:CheckUserInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CheckUserInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__CheckUserInfo(struct soap *soap, _ns1__CheckUserInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CheckUserInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addTransRecInfoResponse(struct soap *soap, _ns1__addTransRecInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addTransRecInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addTransRecInfoResponse(struct soap *soap, const char *tag, int id, _ns1__addTransRecInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addTransRecInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__addTransRecInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__addTransRecInfoResponse(struct soap *soap, const char *tag, _ns1__addTransRecInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__addTransRecInfoResponse **)soap_malloc(soap, sizeof(_ns1__addTransRecInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__addTransRecInfoResponse *)soap_instantiate__ns1__addTransRecInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__addTransRecInfoResponse ** p = (_ns1__addTransRecInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addTransRecInfoResponse, sizeof(_ns1__addTransRecInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addTransRecInfoResponse(struct soap *soap, _ns1__addTransRecInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addTransRecInfoResponse);
	if (soap_out_PointerTo_ns1__addTransRecInfoResponse(soap, tag?tag:"ns1:addTransRecInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__addTransRecInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__addTransRecInfoResponse(struct soap *soap, _ns1__addTransRecInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addTransRecInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__addTransRecInfo(struct soap *soap, _ns1__addTransRecInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__addTransRecInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__addTransRecInfo(struct soap *soap, const char *tag, int id, _ns1__addTransRecInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__addTransRecInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__addTransRecInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__addTransRecInfo(struct soap *soap, const char *tag, _ns1__addTransRecInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__addTransRecInfo **)soap_malloc(soap, sizeof(_ns1__addTransRecInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__addTransRecInfo *)soap_instantiate__ns1__addTransRecInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__addTransRecInfo ** p = (_ns1__addTransRecInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__addTransRecInfo, sizeof(_ns1__addTransRecInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__addTransRecInfo(struct soap *soap, _ns1__addTransRecInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__addTransRecInfo);
	if (soap_out_PointerTo_ns1__addTransRecInfo(soap, tag?tag:"ns1:addTransRecInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__addTransRecInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__addTransRecInfo(struct soap *soap, _ns1__addTransRecInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__addTransRecInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetJdsbhRecoveryInfoResponse(struct soap *soap, _ns1__GetJdsbhRecoveryInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetJdsbhRecoveryInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetJdsbhRecoveryInfoResponse(struct soap *soap, const char *tag, int id, _ns1__GetJdsbhRecoveryInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetJdsbhRecoveryInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetJdsbhRecoveryInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetJdsbhRecoveryInfoResponse(struct soap *soap, const char *tag, _ns1__GetJdsbhRecoveryInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetJdsbhRecoveryInfoResponse **)soap_malloc(soap, sizeof(_ns1__GetJdsbhRecoveryInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetJdsbhRecoveryInfoResponse *)soap_instantiate__ns1__GetJdsbhRecoveryInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetJdsbhRecoveryInfoResponse ** p = (_ns1__GetJdsbhRecoveryInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetJdsbhRecoveryInfoResponse, sizeof(_ns1__GetJdsbhRecoveryInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetJdsbhRecoveryInfoResponse(struct soap *soap, _ns1__GetJdsbhRecoveryInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetJdsbhRecoveryInfoResponse);
	if (soap_out_PointerTo_ns1__GetJdsbhRecoveryInfoResponse(soap, tag?tag:"ns1:GetJdsbhRecoveryInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetJdsbhRecoveryInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetJdsbhRecoveryInfoResponse(struct soap *soap, _ns1__GetJdsbhRecoveryInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetJdsbhRecoveryInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetJdsbhRecoveryInfo(struct soap *soap, _ns1__GetJdsbhRecoveryInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetJdsbhRecoveryInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetJdsbhRecoveryInfo(struct soap *soap, const char *tag, int id, _ns1__GetJdsbhRecoveryInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetJdsbhRecoveryInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetJdsbhRecoveryInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetJdsbhRecoveryInfo(struct soap *soap, const char *tag, _ns1__GetJdsbhRecoveryInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetJdsbhRecoveryInfo **)soap_malloc(soap, sizeof(_ns1__GetJdsbhRecoveryInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetJdsbhRecoveryInfo *)soap_instantiate__ns1__GetJdsbhRecoveryInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetJdsbhRecoveryInfo ** p = (_ns1__GetJdsbhRecoveryInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetJdsbhRecoveryInfo, sizeof(_ns1__GetJdsbhRecoveryInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetJdsbhRecoveryInfo(struct soap *soap, _ns1__GetJdsbhRecoveryInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetJdsbhRecoveryInfo);
	if (soap_out_PointerTo_ns1__GetJdsbhRecoveryInfo(soap, tag?tag:"ns1:GetJdsbhRecoveryInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetJdsbhRecoveryInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetJdsbhRecoveryInfo(struct soap *soap, _ns1__GetJdsbhRecoveryInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetJdsbhRecoveryInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetJdsbhRecoveryResponse(struct soap *soap, _ns1__GetJdsbhRecoveryResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetJdsbhRecoveryResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetJdsbhRecoveryResponse(struct soap *soap, const char *tag, int id, _ns1__GetJdsbhRecoveryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetJdsbhRecoveryResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetJdsbhRecoveryResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetJdsbhRecoveryResponse(struct soap *soap, const char *tag, _ns1__GetJdsbhRecoveryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetJdsbhRecoveryResponse **)soap_malloc(soap, sizeof(_ns1__GetJdsbhRecoveryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetJdsbhRecoveryResponse *)soap_instantiate__ns1__GetJdsbhRecoveryResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetJdsbhRecoveryResponse ** p = (_ns1__GetJdsbhRecoveryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetJdsbhRecoveryResponse, sizeof(_ns1__GetJdsbhRecoveryResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetJdsbhRecoveryResponse(struct soap *soap, _ns1__GetJdsbhRecoveryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetJdsbhRecoveryResponse);
	if (soap_out_PointerTo_ns1__GetJdsbhRecoveryResponse(soap, tag?tag:"ns1:GetJdsbhRecoveryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetJdsbhRecoveryResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetJdsbhRecoveryResponse(struct soap *soap, _ns1__GetJdsbhRecoveryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetJdsbhRecoveryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetJdsbhRecovery(struct soap *soap, _ns1__GetJdsbhRecovery *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetJdsbhRecovery))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetJdsbhRecovery(struct soap *soap, const char *tag, int id, _ns1__GetJdsbhRecovery *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetJdsbhRecovery);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetJdsbhRecovery ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetJdsbhRecovery(struct soap *soap, const char *tag, _ns1__GetJdsbhRecovery **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetJdsbhRecovery **)soap_malloc(soap, sizeof(_ns1__GetJdsbhRecovery *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetJdsbhRecovery *)soap_instantiate__ns1__GetJdsbhRecovery(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetJdsbhRecovery ** p = (_ns1__GetJdsbhRecovery **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetJdsbhRecovery, sizeof(_ns1__GetJdsbhRecovery), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetJdsbhRecovery(struct soap *soap, _ns1__GetJdsbhRecovery *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetJdsbhRecovery);
	if (soap_out_PointerTo_ns1__GetJdsbhRecovery(soap, tag?tag:"ns1:GetJdsbhRecovery", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetJdsbhRecovery ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetJdsbhRecovery(struct soap *soap, _ns1__GetJdsbhRecovery **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetJdsbhRecovery(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetViolationInfoResponse(struct soap *soap, _ns1__GetViolationInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetViolationInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetViolationInfoResponse(struct soap *soap, const char *tag, int id, _ns1__GetViolationInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetViolationInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetViolationInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetViolationInfoResponse(struct soap *soap, const char *tag, _ns1__GetViolationInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetViolationInfoResponse **)soap_malloc(soap, sizeof(_ns1__GetViolationInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetViolationInfoResponse *)soap_instantiate__ns1__GetViolationInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetViolationInfoResponse ** p = (_ns1__GetViolationInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetViolationInfoResponse, sizeof(_ns1__GetViolationInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetViolationInfoResponse(struct soap *soap, _ns1__GetViolationInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetViolationInfoResponse);
	if (soap_out_PointerTo_ns1__GetViolationInfoResponse(soap, tag?tag:"ns1:GetViolationInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetViolationInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetViolationInfoResponse(struct soap *soap, _ns1__GetViolationInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetViolationInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetViolationInfo(struct soap *soap, _ns1__GetViolationInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetViolationInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetViolationInfo(struct soap *soap, const char *tag, int id, _ns1__GetViolationInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetViolationInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetViolationInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetViolationInfo(struct soap *soap, const char *tag, _ns1__GetViolationInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetViolationInfo **)soap_malloc(soap, sizeof(_ns1__GetViolationInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetViolationInfo *)soap_instantiate__ns1__GetViolationInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetViolationInfo ** p = (_ns1__GetViolationInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetViolationInfo, sizeof(_ns1__GetViolationInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetViolationInfo(struct soap *soap, _ns1__GetViolationInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetViolationInfo);
	if (soap_out_PointerTo_ns1__GetViolationInfo(soap, tag?tag:"ns1:GetViolationInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetViolationInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetViolationInfo(struct soap *soap, _ns1__GetViolationInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetViolationInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InViolationInfoResponse(struct soap *soap, _ns1__InViolationInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InViolationInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InViolationInfoResponse(struct soap *soap, const char *tag, int id, _ns1__InViolationInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InViolationInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__InViolationInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__InViolationInfoResponse(struct soap *soap, const char *tag, _ns1__InViolationInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InViolationInfoResponse **)soap_malloc(soap, sizeof(_ns1__InViolationInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InViolationInfoResponse *)soap_instantiate__ns1__InViolationInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__InViolationInfoResponse ** p = (_ns1__InViolationInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InViolationInfoResponse, sizeof(_ns1__InViolationInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InViolationInfoResponse(struct soap *soap, _ns1__InViolationInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__InViolationInfoResponse);
	if (soap_out_PointerTo_ns1__InViolationInfoResponse(soap, tag?tag:"ns1:InViolationInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InViolationInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__InViolationInfoResponse(struct soap *soap, _ns1__InViolationInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InViolationInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InViolationInfo(struct soap *soap, _ns1__InViolationInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InViolationInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InViolationInfo(struct soap *soap, const char *tag, int id, _ns1__InViolationInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InViolationInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__InViolationInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__InViolationInfo(struct soap *soap, const char *tag, _ns1__InViolationInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InViolationInfo **)soap_malloc(soap, sizeof(_ns1__InViolationInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InViolationInfo *)soap_instantiate__ns1__InViolationInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__InViolationInfo ** p = (_ns1__InViolationInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InViolationInfo, sizeof(_ns1__InViolationInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InViolationInfo(struct soap *soap, _ns1__InViolationInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__InViolationInfo);
	if (soap_out_PointerTo_ns1__InViolationInfo(soap, tag?tag:"ns1:InViolationInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InViolationInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__InViolationInfo(struct soap *soap, _ns1__InViolationInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InViolationInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdataDeviceStateResponse(struct soap *soap, _ns1__UpdataDeviceStateResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdataDeviceStateResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdataDeviceStateResponse(struct soap *soap, const char *tag, int id, _ns1__UpdataDeviceStateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdataDeviceStateResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdataDeviceStateResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdataDeviceStateResponse(struct soap *soap, const char *tag, _ns1__UpdataDeviceStateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdataDeviceStateResponse **)soap_malloc(soap, sizeof(_ns1__UpdataDeviceStateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdataDeviceStateResponse *)soap_instantiate__ns1__UpdataDeviceStateResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdataDeviceStateResponse ** p = (_ns1__UpdataDeviceStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdataDeviceStateResponse, sizeof(_ns1__UpdataDeviceStateResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdataDeviceStateResponse(struct soap *soap, _ns1__UpdataDeviceStateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdataDeviceStateResponse);
	if (soap_out_PointerTo_ns1__UpdataDeviceStateResponse(soap, tag?tag:"ns1:UpdataDeviceStateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdataDeviceStateResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdataDeviceStateResponse(struct soap *soap, _ns1__UpdataDeviceStateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdataDeviceStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdataDeviceState(struct soap *soap, _ns1__UpdataDeviceState *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdataDeviceState))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdataDeviceState(struct soap *soap, const char *tag, int id, _ns1__UpdataDeviceState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdataDeviceState);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdataDeviceState ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdataDeviceState(struct soap *soap, const char *tag, _ns1__UpdataDeviceState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdataDeviceState **)soap_malloc(soap, sizeof(_ns1__UpdataDeviceState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdataDeviceState *)soap_instantiate__ns1__UpdataDeviceState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdataDeviceState ** p = (_ns1__UpdataDeviceState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdataDeviceState, sizeof(_ns1__UpdataDeviceState), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdataDeviceState(struct soap *soap, _ns1__UpdataDeviceState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdataDeviceState);
	if (soap_out_PointerTo_ns1__UpdataDeviceState(soap, tag?tag:"ns1:UpdataDeviceState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdataDeviceState ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdataDeviceState(struct soap *soap, _ns1__UpdataDeviceState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdataDeviceState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAlarmInfoResponse(struct soap *soap, _ns1__GetAlarmInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAlarmInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAlarmInfoResponse(struct soap *soap, const char *tag, int id, _ns1__GetAlarmInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAlarmInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetAlarmInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAlarmInfoResponse(struct soap *soap, const char *tag, _ns1__GetAlarmInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAlarmInfoResponse **)soap_malloc(soap, sizeof(_ns1__GetAlarmInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAlarmInfoResponse *)soap_instantiate__ns1__GetAlarmInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetAlarmInfoResponse ** p = (_ns1__GetAlarmInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAlarmInfoResponse, sizeof(_ns1__GetAlarmInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAlarmInfoResponse(struct soap *soap, _ns1__GetAlarmInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetAlarmInfoResponse);
	if (soap_out_PointerTo_ns1__GetAlarmInfoResponse(soap, tag?tag:"ns1:GetAlarmInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAlarmInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAlarmInfoResponse(struct soap *soap, _ns1__GetAlarmInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAlarmInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAlarmInfo(struct soap *soap, _ns1__GetAlarmInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAlarmInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAlarmInfo(struct soap *soap, const char *tag, int id, _ns1__GetAlarmInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAlarmInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetAlarmInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAlarmInfo(struct soap *soap, const char *tag, _ns1__GetAlarmInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAlarmInfo **)soap_malloc(soap, sizeof(_ns1__GetAlarmInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAlarmInfo *)soap_instantiate__ns1__GetAlarmInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetAlarmInfo ** p = (_ns1__GetAlarmInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAlarmInfo, sizeof(_ns1__GetAlarmInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAlarmInfo(struct soap *soap, _ns1__GetAlarmInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetAlarmInfo);
	if (soap_out_PointerTo_ns1__GetAlarmInfo(soap, tag?tag:"ns1:GetAlarmInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAlarmInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAlarmInfo(struct soap *soap, _ns1__GetAlarmInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAlarmInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdateVioPeccancyInfoResponse(struct soap *soap, _ns1__UpdateVioPeccancyInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdateVioPeccancyInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdateVioPeccancyInfoResponse(struct soap *soap, const char *tag, int id, _ns1__UpdateVioPeccancyInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdateVioPeccancyInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdateVioPeccancyInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdateVioPeccancyInfoResponse(struct soap *soap, const char *tag, _ns1__UpdateVioPeccancyInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdateVioPeccancyInfoResponse **)soap_malloc(soap, sizeof(_ns1__UpdateVioPeccancyInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdateVioPeccancyInfoResponse *)soap_instantiate__ns1__UpdateVioPeccancyInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdateVioPeccancyInfoResponse ** p = (_ns1__UpdateVioPeccancyInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdateVioPeccancyInfoResponse, sizeof(_ns1__UpdateVioPeccancyInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdateVioPeccancyInfoResponse(struct soap *soap, _ns1__UpdateVioPeccancyInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdateVioPeccancyInfoResponse);
	if (soap_out_PointerTo_ns1__UpdateVioPeccancyInfoResponse(soap, tag?tag:"ns1:UpdateVioPeccancyInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdateVioPeccancyInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdateVioPeccancyInfoResponse(struct soap *soap, _ns1__UpdateVioPeccancyInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdateVioPeccancyInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdateVioPeccancyInfo(struct soap *soap, _ns1__UpdateVioPeccancyInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdateVioPeccancyInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdateVioPeccancyInfo(struct soap *soap, const char *tag, int id, _ns1__UpdateVioPeccancyInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdateVioPeccancyInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdateVioPeccancyInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdateVioPeccancyInfo(struct soap *soap, const char *tag, _ns1__UpdateVioPeccancyInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdateVioPeccancyInfo **)soap_malloc(soap, sizeof(_ns1__UpdateVioPeccancyInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdateVioPeccancyInfo *)soap_instantiate__ns1__UpdateVioPeccancyInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdateVioPeccancyInfo ** p = (_ns1__UpdateVioPeccancyInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdateVioPeccancyInfo, sizeof(_ns1__UpdateVioPeccancyInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdateVioPeccancyInfo(struct soap *soap, _ns1__UpdateVioPeccancyInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdateVioPeccancyInfo);
	if (soap_out_PointerTo_ns1__UpdateVioPeccancyInfo(soap, tag?tag:"ns1:UpdateVioPeccancyInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdateVioPeccancyInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdateVioPeccancyInfo(struct soap *soap, _ns1__UpdateVioPeccancyInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdateVioPeccancyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetVioPeccancyNoCheckInfoResponse(struct soap *soap, _ns1__GetVioPeccancyNoCheckInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetVioPeccancyNoCheckInfoResponse(struct soap *soap, const char *tag, int id, _ns1__GetVioPeccancyNoCheckInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetVioPeccancyNoCheckInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetVioPeccancyNoCheckInfoResponse(struct soap *soap, const char *tag, _ns1__GetVioPeccancyNoCheckInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetVioPeccancyNoCheckInfoResponse **)soap_malloc(soap, sizeof(_ns1__GetVioPeccancyNoCheckInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetVioPeccancyNoCheckInfoResponse *)soap_instantiate__ns1__GetVioPeccancyNoCheckInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetVioPeccancyNoCheckInfoResponse ** p = (_ns1__GetVioPeccancyNoCheckInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfoResponse, sizeof(_ns1__GetVioPeccancyNoCheckInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetVioPeccancyNoCheckInfoResponse(struct soap *soap, _ns1__GetVioPeccancyNoCheckInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetVioPeccancyNoCheckInfoResponse);
	if (soap_out_PointerTo_ns1__GetVioPeccancyNoCheckInfoResponse(soap, tag?tag:"ns1:GetVioPeccancyNoCheckInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetVioPeccancyNoCheckInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetVioPeccancyNoCheckInfoResponse(struct soap *soap, _ns1__GetVioPeccancyNoCheckInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetVioPeccancyNoCheckInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetVioPeccancyNoCheckInfo(struct soap *soap, _ns1__GetVioPeccancyNoCheckInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetVioPeccancyNoCheckInfo(struct soap *soap, const char *tag, int id, _ns1__GetVioPeccancyNoCheckInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetVioPeccancyNoCheckInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetVioPeccancyNoCheckInfo(struct soap *soap, const char *tag, _ns1__GetVioPeccancyNoCheckInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetVioPeccancyNoCheckInfo **)soap_malloc(soap, sizeof(_ns1__GetVioPeccancyNoCheckInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetVioPeccancyNoCheckInfo *)soap_instantiate__ns1__GetVioPeccancyNoCheckInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetVioPeccancyNoCheckInfo ** p = (_ns1__GetVioPeccancyNoCheckInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetVioPeccancyNoCheckInfo, sizeof(_ns1__GetVioPeccancyNoCheckInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetVioPeccancyNoCheckInfo(struct soap *soap, _ns1__GetVioPeccancyNoCheckInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetVioPeccancyNoCheckInfo);
	if (soap_out_PointerTo_ns1__GetVioPeccancyNoCheckInfo(soap, tag?tag:"ns1:GetVioPeccancyNoCheckInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetVioPeccancyNoCheckInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetVioPeccancyNoCheckInfo(struct soap *soap, _ns1__GetVioPeccancyNoCheckInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetVioPeccancyNoCheckInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdatePeccancyInfoResponse(struct soap *soap, _ns1__UpdatePeccancyInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdatePeccancyInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdatePeccancyInfoResponse(struct soap *soap, const char *tag, int id, _ns1__UpdatePeccancyInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdatePeccancyInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdatePeccancyInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdatePeccancyInfoResponse(struct soap *soap, const char *tag, _ns1__UpdatePeccancyInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdatePeccancyInfoResponse **)soap_malloc(soap, sizeof(_ns1__UpdatePeccancyInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdatePeccancyInfoResponse *)soap_instantiate__ns1__UpdatePeccancyInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdatePeccancyInfoResponse ** p = (_ns1__UpdatePeccancyInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdatePeccancyInfoResponse, sizeof(_ns1__UpdatePeccancyInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdatePeccancyInfoResponse(struct soap *soap, _ns1__UpdatePeccancyInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdatePeccancyInfoResponse);
	if (soap_out_PointerTo_ns1__UpdatePeccancyInfoResponse(soap, tag?tag:"ns1:UpdatePeccancyInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdatePeccancyInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdatePeccancyInfoResponse(struct soap *soap, _ns1__UpdatePeccancyInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdatePeccancyInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__UpdatePeccancyInfo(struct soap *soap, _ns1__UpdatePeccancyInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__UpdatePeccancyInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__UpdatePeccancyInfo(struct soap *soap, const char *tag, int id, _ns1__UpdatePeccancyInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__UpdatePeccancyInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__UpdatePeccancyInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__UpdatePeccancyInfo(struct soap *soap, const char *tag, _ns1__UpdatePeccancyInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__UpdatePeccancyInfo **)soap_malloc(soap, sizeof(_ns1__UpdatePeccancyInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__UpdatePeccancyInfo *)soap_instantiate__ns1__UpdatePeccancyInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__UpdatePeccancyInfo ** p = (_ns1__UpdatePeccancyInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__UpdatePeccancyInfo, sizeof(_ns1__UpdatePeccancyInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__UpdatePeccancyInfo(struct soap *soap, _ns1__UpdatePeccancyInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__UpdatePeccancyInfo);
	if (soap_out_PointerTo_ns1__UpdatePeccancyInfo(soap, tag?tag:"ns1:UpdatePeccancyInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__UpdatePeccancyInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__UpdatePeccancyInfo(struct soap *soap, _ns1__UpdatePeccancyInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__UpdatePeccancyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPeccancyNoCheckInfoResponse(struct soap *soap, _ns1__GetPeccancyNoCheckInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPeccancyNoCheckInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPeccancyNoCheckInfoResponse(struct soap *soap, const char *tag, int id, _ns1__GetPeccancyNoCheckInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPeccancyNoCheckInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPeccancyNoCheckInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPeccancyNoCheckInfoResponse(struct soap *soap, const char *tag, _ns1__GetPeccancyNoCheckInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPeccancyNoCheckInfoResponse **)soap_malloc(soap, sizeof(_ns1__GetPeccancyNoCheckInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPeccancyNoCheckInfoResponse *)soap_instantiate__ns1__GetPeccancyNoCheckInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPeccancyNoCheckInfoResponse ** p = (_ns1__GetPeccancyNoCheckInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPeccancyNoCheckInfoResponse, sizeof(_ns1__GetPeccancyNoCheckInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPeccancyNoCheckInfoResponse(struct soap *soap, _ns1__GetPeccancyNoCheckInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPeccancyNoCheckInfoResponse);
	if (soap_out_PointerTo_ns1__GetPeccancyNoCheckInfoResponse(soap, tag?tag:"ns1:GetPeccancyNoCheckInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPeccancyNoCheckInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPeccancyNoCheckInfoResponse(struct soap *soap, _ns1__GetPeccancyNoCheckInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPeccancyNoCheckInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPeccancyNoCheckInfo(struct soap *soap, _ns1__GetPeccancyNoCheckInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPeccancyNoCheckInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPeccancyNoCheckInfo(struct soap *soap, const char *tag, int id, _ns1__GetPeccancyNoCheckInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPeccancyNoCheckInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPeccancyNoCheckInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPeccancyNoCheckInfo(struct soap *soap, const char *tag, _ns1__GetPeccancyNoCheckInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPeccancyNoCheckInfo **)soap_malloc(soap, sizeof(_ns1__GetPeccancyNoCheckInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPeccancyNoCheckInfo *)soap_instantiate__ns1__GetPeccancyNoCheckInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPeccancyNoCheckInfo ** p = (_ns1__GetPeccancyNoCheckInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPeccancyNoCheckInfo, sizeof(_ns1__GetPeccancyNoCheckInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPeccancyNoCheckInfo(struct soap *soap, _ns1__GetPeccancyNoCheckInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPeccancyNoCheckInfo);
	if (soap_out_PointerTo_ns1__GetPeccancyNoCheckInfo(soap, tag?tag:"ns1:GetPeccancyNoCheckInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPeccancyNoCheckInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPeccancyNoCheckInfo(struct soap *soap, _ns1__GetPeccancyNoCheckInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPeccancyNoCheckInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPeccancyInfoResponse(struct soap *soap, _ns1__GetPeccancyInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPeccancyInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPeccancyInfoResponse(struct soap *soap, const char *tag, int id, _ns1__GetPeccancyInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPeccancyInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPeccancyInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPeccancyInfoResponse(struct soap *soap, const char *tag, _ns1__GetPeccancyInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPeccancyInfoResponse **)soap_malloc(soap, sizeof(_ns1__GetPeccancyInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPeccancyInfoResponse *)soap_instantiate__ns1__GetPeccancyInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPeccancyInfoResponse ** p = (_ns1__GetPeccancyInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPeccancyInfoResponse, sizeof(_ns1__GetPeccancyInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPeccancyInfoResponse(struct soap *soap, _ns1__GetPeccancyInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPeccancyInfoResponse);
	if (soap_out_PointerTo_ns1__GetPeccancyInfoResponse(soap, tag?tag:"ns1:GetPeccancyInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPeccancyInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPeccancyInfoResponse(struct soap *soap, _ns1__GetPeccancyInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPeccancyInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPeccancyInfo(struct soap *soap, _ns1__GetPeccancyInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPeccancyInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPeccancyInfo(struct soap *soap, const char *tag, int id, _ns1__GetPeccancyInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPeccancyInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPeccancyInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPeccancyInfo(struct soap *soap, const char *tag, _ns1__GetPeccancyInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPeccancyInfo **)soap_malloc(soap, sizeof(_ns1__GetPeccancyInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPeccancyInfo *)soap_instantiate__ns1__GetPeccancyInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPeccancyInfo ** p = (_ns1__GetPeccancyInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPeccancyInfo, sizeof(_ns1__GetPeccancyInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPeccancyInfo(struct soap *soap, _ns1__GetPeccancyInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPeccancyInfo);
	if (soap_out_PointerTo_ns1__GetPeccancyInfo(soap, tag?tag:"ns1:GetPeccancyInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPeccancyInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPeccancyInfo(struct soap *soap, _ns1__GetPeccancyInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPeccancyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPassCarInfoResponse(struct soap *soap, _ns1__GetPassCarInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPassCarInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPassCarInfoResponse(struct soap *soap, const char *tag, int id, _ns1__GetPassCarInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPassCarInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPassCarInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPassCarInfoResponse(struct soap *soap, const char *tag, _ns1__GetPassCarInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPassCarInfoResponse **)soap_malloc(soap, sizeof(_ns1__GetPassCarInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPassCarInfoResponse *)soap_instantiate__ns1__GetPassCarInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPassCarInfoResponse ** p = (_ns1__GetPassCarInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPassCarInfoResponse, sizeof(_ns1__GetPassCarInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPassCarInfoResponse(struct soap *soap, _ns1__GetPassCarInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPassCarInfoResponse);
	if (soap_out_PointerTo_ns1__GetPassCarInfoResponse(soap, tag?tag:"ns1:GetPassCarInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPassCarInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPassCarInfoResponse(struct soap *soap, _ns1__GetPassCarInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPassCarInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetPassCarInfo(struct soap *soap, _ns1__GetPassCarInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetPassCarInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetPassCarInfo(struct soap *soap, const char *tag, int id, _ns1__GetPassCarInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetPassCarInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetPassCarInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetPassCarInfo(struct soap *soap, const char *tag, _ns1__GetPassCarInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetPassCarInfo **)soap_malloc(soap, sizeof(_ns1__GetPassCarInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetPassCarInfo *)soap_instantiate__ns1__GetPassCarInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetPassCarInfo ** p = (_ns1__GetPassCarInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetPassCarInfo, sizeof(_ns1__GetPassCarInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetPassCarInfo(struct soap *soap, _ns1__GetPassCarInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetPassCarInfo);
	if (soap_out_PointerTo_ns1__GetPassCarInfo(soap, tag?tag:"ns1:GetPassCarInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetPassCarInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetPassCarInfo(struct soap *soap, _ns1__GetPassCarInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetPassCarInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetLocationInfoResponse(struct soap *soap, _ns1__GetLocationInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetLocationInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetLocationInfoResponse(struct soap *soap, const char *tag, int id, _ns1__GetLocationInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetLocationInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetLocationInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetLocationInfoResponse(struct soap *soap, const char *tag, _ns1__GetLocationInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetLocationInfoResponse **)soap_malloc(soap, sizeof(_ns1__GetLocationInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetLocationInfoResponse *)soap_instantiate__ns1__GetLocationInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetLocationInfoResponse ** p = (_ns1__GetLocationInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetLocationInfoResponse, sizeof(_ns1__GetLocationInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetLocationInfoResponse(struct soap *soap, _ns1__GetLocationInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetLocationInfoResponse);
	if (soap_out_PointerTo_ns1__GetLocationInfoResponse(soap, tag?tag:"ns1:GetLocationInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetLocationInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetLocationInfoResponse(struct soap *soap, _ns1__GetLocationInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetLocationInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetLocationInfo(struct soap *soap, _ns1__GetLocationInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetLocationInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetLocationInfo(struct soap *soap, const char *tag, int id, _ns1__GetLocationInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetLocationInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetLocationInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetLocationInfo(struct soap *soap, const char *tag, _ns1__GetLocationInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetLocationInfo **)soap_malloc(soap, sizeof(_ns1__GetLocationInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetLocationInfo *)soap_instantiate__ns1__GetLocationInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetLocationInfo ** p = (_ns1__GetLocationInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetLocationInfo, sizeof(_ns1__GetLocationInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetLocationInfo(struct soap *soap, _ns1__GetLocationInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetLocationInfo);
	if (soap_out_PointerTo_ns1__GetLocationInfo(soap, tag?tag:"ns1:GetLocationInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetLocationInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetLocationInfo(struct soap *soap, _ns1__GetLocationInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetLocationInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RevokeSuspicionInfoResponse(struct soap *soap, _ns1__RevokeSuspicionInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RevokeSuspicionInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RevokeSuspicionInfoResponse(struct soap *soap, const char *tag, int id, _ns1__RevokeSuspicionInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RevokeSuspicionInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RevokeSuspicionInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__RevokeSuspicionInfoResponse(struct soap *soap, const char *tag, _ns1__RevokeSuspicionInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RevokeSuspicionInfoResponse **)soap_malloc(soap, sizeof(_ns1__RevokeSuspicionInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RevokeSuspicionInfoResponse *)soap_instantiate__ns1__RevokeSuspicionInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__RevokeSuspicionInfoResponse ** p = (_ns1__RevokeSuspicionInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RevokeSuspicionInfoResponse, sizeof(_ns1__RevokeSuspicionInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RevokeSuspicionInfoResponse(struct soap *soap, _ns1__RevokeSuspicionInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__RevokeSuspicionInfoResponse);
	if (soap_out_PointerTo_ns1__RevokeSuspicionInfoResponse(soap, tag?tag:"ns1:RevokeSuspicionInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RevokeSuspicionInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__RevokeSuspicionInfoResponse(struct soap *soap, _ns1__RevokeSuspicionInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RevokeSuspicionInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RevokeSuspicionInfo(struct soap *soap, _ns1__RevokeSuspicionInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RevokeSuspicionInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RevokeSuspicionInfo(struct soap *soap, const char *tag, int id, _ns1__RevokeSuspicionInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RevokeSuspicionInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__RevokeSuspicionInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__RevokeSuspicionInfo(struct soap *soap, const char *tag, _ns1__RevokeSuspicionInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RevokeSuspicionInfo **)soap_malloc(soap, sizeof(_ns1__RevokeSuspicionInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RevokeSuspicionInfo *)soap_instantiate__ns1__RevokeSuspicionInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__RevokeSuspicionInfo ** p = (_ns1__RevokeSuspicionInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RevokeSuspicionInfo, sizeof(_ns1__RevokeSuspicionInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RevokeSuspicionInfo(struct soap *soap, _ns1__RevokeSuspicionInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__RevokeSuspicionInfo);
	if (soap_out_PointerTo_ns1__RevokeSuspicionInfo(soap, tag?tag:"ns1:RevokeSuspicionInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RevokeSuspicionInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__RevokeSuspicionInfo(struct soap *soap, _ns1__RevokeSuspicionInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RevokeSuspicionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InSuspicionInfoResponse(struct soap *soap, _ns1__InSuspicionInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InSuspicionInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InSuspicionInfoResponse(struct soap *soap, const char *tag, int id, _ns1__InSuspicionInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InSuspicionInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__InSuspicionInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__InSuspicionInfoResponse(struct soap *soap, const char *tag, _ns1__InSuspicionInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InSuspicionInfoResponse **)soap_malloc(soap, sizeof(_ns1__InSuspicionInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InSuspicionInfoResponse *)soap_instantiate__ns1__InSuspicionInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__InSuspicionInfoResponse ** p = (_ns1__InSuspicionInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InSuspicionInfoResponse, sizeof(_ns1__InSuspicionInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InSuspicionInfoResponse(struct soap *soap, _ns1__InSuspicionInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__InSuspicionInfoResponse);
	if (soap_out_PointerTo_ns1__InSuspicionInfoResponse(soap, tag?tag:"ns1:InSuspicionInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InSuspicionInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__InSuspicionInfoResponse(struct soap *soap, _ns1__InSuspicionInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InSuspicionInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InSuspicionInfo(struct soap *soap, _ns1__InSuspicionInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InSuspicionInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InSuspicionInfo(struct soap *soap, const char *tag, int id, _ns1__InSuspicionInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InSuspicionInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__InSuspicionInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__InSuspicionInfo(struct soap *soap, const char *tag, _ns1__InSuspicionInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InSuspicionInfo **)soap_malloc(soap, sizeof(_ns1__InSuspicionInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InSuspicionInfo *)soap_instantiate__ns1__InSuspicionInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__InSuspicionInfo ** p = (_ns1__InSuspicionInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InSuspicionInfo, sizeof(_ns1__InSuspicionInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InSuspicionInfo(struct soap *soap, _ns1__InSuspicionInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__InSuspicionInfo);
	if (soap_out_PointerTo_ns1__InSuspicionInfo(soap, tag?tag:"ns1:InSuspicionInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InSuspicionInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__InSuspicionInfo(struct soap *soap, _ns1__InSuspicionInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InSuspicionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__IntExtralistInfoResponse(struct soap *soap, _ns1__IntExtralistInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__IntExtralistInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__IntExtralistInfoResponse(struct soap *soap, const char *tag, int id, _ns1__IntExtralistInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__IntExtralistInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__IntExtralistInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__IntExtralistInfoResponse(struct soap *soap, const char *tag, _ns1__IntExtralistInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__IntExtralistInfoResponse **)soap_malloc(soap, sizeof(_ns1__IntExtralistInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__IntExtralistInfoResponse *)soap_instantiate__ns1__IntExtralistInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__IntExtralistInfoResponse ** p = (_ns1__IntExtralistInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__IntExtralistInfoResponse, sizeof(_ns1__IntExtralistInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__IntExtralistInfoResponse(struct soap *soap, _ns1__IntExtralistInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__IntExtralistInfoResponse);
	if (soap_out_PointerTo_ns1__IntExtralistInfoResponse(soap, tag?tag:"ns1:IntExtralistInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__IntExtralistInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__IntExtralistInfoResponse(struct soap *soap, _ns1__IntExtralistInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__IntExtralistInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__IntExtralistInfo(struct soap *soap, _ns1__IntExtralistInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__IntExtralistInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__IntExtralistInfo(struct soap *soap, const char *tag, int id, _ns1__IntExtralistInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__IntExtralistInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__IntExtralistInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__IntExtralistInfo(struct soap *soap, const char *tag, _ns1__IntExtralistInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__IntExtralistInfo **)soap_malloc(soap, sizeof(_ns1__IntExtralistInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__IntExtralistInfo *)soap_instantiate__ns1__IntExtralistInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__IntExtralistInfo ** p = (_ns1__IntExtralistInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__IntExtralistInfo, sizeof(_ns1__IntExtralistInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__IntExtralistInfo(struct soap *soap, _ns1__IntExtralistInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__IntExtralistInfo);
	if (soap_out_PointerTo_ns1__IntExtralistInfo(soap, tag?tag:"ns1:IntExtralistInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__IntExtralistInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__IntExtralistInfo(struct soap *soap, _ns1__IntExtralistInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__IntExtralistInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InChecklessInfoResponse(struct soap *soap, _ns1__InChecklessInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InChecklessInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InChecklessInfoResponse(struct soap *soap, const char *tag, int id, _ns1__InChecklessInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InChecklessInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__InChecklessInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__InChecklessInfoResponse(struct soap *soap, const char *tag, _ns1__InChecklessInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InChecklessInfoResponse **)soap_malloc(soap, sizeof(_ns1__InChecklessInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InChecklessInfoResponse *)soap_instantiate__ns1__InChecklessInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__InChecklessInfoResponse ** p = (_ns1__InChecklessInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InChecklessInfoResponse, sizeof(_ns1__InChecklessInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InChecklessInfoResponse(struct soap *soap, _ns1__InChecklessInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__InChecklessInfoResponse);
	if (soap_out_PointerTo_ns1__InChecklessInfoResponse(soap, tag?tag:"ns1:InChecklessInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InChecklessInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__InChecklessInfoResponse(struct soap *soap, _ns1__InChecklessInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InChecklessInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InChecklessInfo(struct soap *soap, _ns1__InChecklessInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InChecklessInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InChecklessInfo(struct soap *soap, const char *tag, int id, _ns1__InChecklessInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InChecklessInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__InChecklessInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__InChecklessInfo(struct soap *soap, const char *tag, _ns1__InChecklessInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InChecklessInfo **)soap_malloc(soap, sizeof(_ns1__InChecklessInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InChecklessInfo *)soap_instantiate__ns1__InChecklessInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__InChecklessInfo ** p = (_ns1__InChecklessInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InChecklessInfo, sizeof(_ns1__InChecklessInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InChecklessInfo(struct soap *soap, _ns1__InChecklessInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__InChecklessInfo);
	if (soap_out_PointerTo_ns1__InChecklessInfo(soap, tag?tag:"ns1:InChecklessInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InChecklessInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__InChecklessInfo(struct soap *soap, _ns1__InChecklessInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InChecklessInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InBlacklistInfoResponse(struct soap *soap, _ns1__InBlacklistInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InBlacklistInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InBlacklistInfoResponse(struct soap *soap, const char *tag, int id, _ns1__InBlacklistInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InBlacklistInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__InBlacklistInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__InBlacklistInfoResponse(struct soap *soap, const char *tag, _ns1__InBlacklistInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InBlacklistInfoResponse **)soap_malloc(soap, sizeof(_ns1__InBlacklistInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InBlacklistInfoResponse *)soap_instantiate__ns1__InBlacklistInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__InBlacklistInfoResponse ** p = (_ns1__InBlacklistInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InBlacklistInfoResponse, sizeof(_ns1__InBlacklistInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InBlacklistInfoResponse(struct soap *soap, _ns1__InBlacklistInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__InBlacklistInfoResponse);
	if (soap_out_PointerTo_ns1__InBlacklistInfoResponse(soap, tag?tag:"ns1:InBlacklistInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InBlacklistInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__InBlacklistInfoResponse(struct soap *soap, _ns1__InBlacklistInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InBlacklistInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InBlacklistInfo(struct soap *soap, _ns1__InBlacklistInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InBlacklistInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InBlacklistInfo(struct soap *soap, const char *tag, int id, _ns1__InBlacklistInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InBlacklistInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__InBlacklistInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__InBlacklistInfo(struct soap *soap, const char *tag, _ns1__InBlacklistInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InBlacklistInfo **)soap_malloc(soap, sizeof(_ns1__InBlacklistInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InBlacklistInfo *)soap_instantiate__ns1__InBlacklistInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__InBlacklistInfo ** p = (_ns1__InBlacklistInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InBlacklistInfo, sizeof(_ns1__InBlacklistInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InBlacklistInfo(struct soap *soap, _ns1__InBlacklistInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__InBlacklistInfo);
	if (soap_out_PointerTo_ns1__InBlacklistInfo(soap, tag?tag:"ns1:InBlacklistInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InBlacklistInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__InBlacklistInfo(struct soap *soap, _ns1__InBlacklistInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InBlacklistInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InCheckedPeccancyInfoResponse(struct soap *soap, _ns1__InCheckedPeccancyInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InCheckedPeccancyInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InCheckedPeccancyInfoResponse(struct soap *soap, const char *tag, int id, _ns1__InCheckedPeccancyInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InCheckedPeccancyInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__InCheckedPeccancyInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__InCheckedPeccancyInfoResponse(struct soap *soap, const char *tag, _ns1__InCheckedPeccancyInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InCheckedPeccancyInfoResponse **)soap_malloc(soap, sizeof(_ns1__InCheckedPeccancyInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InCheckedPeccancyInfoResponse *)soap_instantiate__ns1__InCheckedPeccancyInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__InCheckedPeccancyInfoResponse ** p = (_ns1__InCheckedPeccancyInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InCheckedPeccancyInfoResponse, sizeof(_ns1__InCheckedPeccancyInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InCheckedPeccancyInfoResponse(struct soap *soap, _ns1__InCheckedPeccancyInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__InCheckedPeccancyInfoResponse);
	if (soap_out_PointerTo_ns1__InCheckedPeccancyInfoResponse(soap, tag?tag:"ns1:InCheckedPeccancyInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InCheckedPeccancyInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__InCheckedPeccancyInfoResponse(struct soap *soap, _ns1__InCheckedPeccancyInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InCheckedPeccancyInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InCheckedPeccancyInfo(struct soap *soap, _ns1__InCheckedPeccancyInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InCheckedPeccancyInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InCheckedPeccancyInfo(struct soap *soap, const char *tag, int id, _ns1__InCheckedPeccancyInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InCheckedPeccancyInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__InCheckedPeccancyInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__InCheckedPeccancyInfo(struct soap *soap, const char *tag, _ns1__InCheckedPeccancyInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InCheckedPeccancyInfo **)soap_malloc(soap, sizeof(_ns1__InCheckedPeccancyInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InCheckedPeccancyInfo *)soap_instantiate__ns1__InCheckedPeccancyInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__InCheckedPeccancyInfo ** p = (_ns1__InCheckedPeccancyInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InCheckedPeccancyInfo, sizeof(_ns1__InCheckedPeccancyInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InCheckedPeccancyInfo(struct soap *soap, _ns1__InCheckedPeccancyInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__InCheckedPeccancyInfo);
	if (soap_out_PointerTo_ns1__InCheckedPeccancyInfo(soap, tag?tag:"ns1:InCheckedPeccancyInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InCheckedPeccancyInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__InCheckedPeccancyInfo(struct soap *soap, _ns1__InCheckedPeccancyInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InCheckedPeccancyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InPeccancyInfoResponse(struct soap *soap, _ns1__InPeccancyInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InPeccancyInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InPeccancyInfoResponse(struct soap *soap, const char *tag, int id, _ns1__InPeccancyInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InPeccancyInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__InPeccancyInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__InPeccancyInfoResponse(struct soap *soap, const char *tag, _ns1__InPeccancyInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InPeccancyInfoResponse **)soap_malloc(soap, sizeof(_ns1__InPeccancyInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InPeccancyInfoResponse *)soap_instantiate__ns1__InPeccancyInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__InPeccancyInfoResponse ** p = (_ns1__InPeccancyInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InPeccancyInfoResponse, sizeof(_ns1__InPeccancyInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InPeccancyInfoResponse(struct soap *soap, _ns1__InPeccancyInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__InPeccancyInfoResponse);
	if (soap_out_PointerTo_ns1__InPeccancyInfoResponse(soap, tag?tag:"ns1:InPeccancyInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InPeccancyInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__InPeccancyInfoResponse(struct soap *soap, _ns1__InPeccancyInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InPeccancyInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InPeccancyInfo(struct soap *soap, _ns1__InPeccancyInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InPeccancyInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InPeccancyInfo(struct soap *soap, const char *tag, int id, _ns1__InPeccancyInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InPeccancyInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__InPeccancyInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__InPeccancyInfo(struct soap *soap, const char *tag, _ns1__InPeccancyInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InPeccancyInfo **)soap_malloc(soap, sizeof(_ns1__InPeccancyInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InPeccancyInfo *)soap_instantiate__ns1__InPeccancyInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__InPeccancyInfo ** p = (_ns1__InPeccancyInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InPeccancyInfo, sizeof(_ns1__InPeccancyInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InPeccancyInfo(struct soap *soap, _ns1__InPeccancyInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__InPeccancyInfo);
	if (soap_out_PointerTo_ns1__InPeccancyInfo(soap, tag?tag:"ns1:InPeccancyInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InPeccancyInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__InPeccancyInfo(struct soap *soap, _ns1__InPeccancyInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InPeccancyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InPassCarInfoResponse(struct soap *soap, _ns1__InPassCarInfoResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InPassCarInfoResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InPassCarInfoResponse(struct soap *soap, const char *tag, int id, _ns1__InPassCarInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InPassCarInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__InPassCarInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__InPassCarInfoResponse(struct soap *soap, const char *tag, _ns1__InPassCarInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InPassCarInfoResponse **)soap_malloc(soap, sizeof(_ns1__InPassCarInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InPassCarInfoResponse *)soap_instantiate__ns1__InPassCarInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__InPassCarInfoResponse ** p = (_ns1__InPassCarInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InPassCarInfoResponse, sizeof(_ns1__InPassCarInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InPassCarInfoResponse(struct soap *soap, _ns1__InPassCarInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__InPassCarInfoResponse);
	if (soap_out_PointerTo_ns1__InPassCarInfoResponse(soap, tag?tag:"ns1:InPassCarInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InPassCarInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__InPassCarInfoResponse(struct soap *soap, _ns1__InPassCarInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InPassCarInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__InPassCarInfo(struct soap *soap, _ns1__InPassCarInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__InPassCarInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__InPassCarInfo(struct soap *soap, const char *tag, int id, _ns1__InPassCarInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__InPassCarInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__InPassCarInfo ** SOAP_FMAC4 soap_in_PointerTo_ns1__InPassCarInfo(struct soap *soap, const char *tag, _ns1__InPassCarInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__InPassCarInfo **)soap_malloc(soap, sizeof(_ns1__InPassCarInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__InPassCarInfo *)soap_instantiate__ns1__InPassCarInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__InPassCarInfo ** p = (_ns1__InPassCarInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__InPassCarInfo, sizeof(_ns1__InPassCarInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__InPassCarInfo(struct soap *soap, _ns1__InPassCarInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__InPassCarInfo);
	if (soap_out_PointerTo_ns1__InPassCarInfo(soap, tag?tag:"ns1:InPassCarInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__InPassCarInfo ** SOAP_FMAC4 soap_get_PointerTo_ns1__InPassCarInfo(struct soap *soap, _ns1__InPassCarInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__InPassCarInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CarPlateRecogResponse(struct soap *soap, _ns1__CarPlateRecogResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CarPlateRecogResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CarPlateRecogResponse(struct soap *soap, const char *tag, int id, _ns1__CarPlateRecogResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CarPlateRecogResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CarPlateRecogResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__CarPlateRecogResponse(struct soap *soap, const char *tag, _ns1__CarPlateRecogResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CarPlateRecogResponse **)soap_malloc(soap, sizeof(_ns1__CarPlateRecogResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CarPlateRecogResponse *)soap_instantiate__ns1__CarPlateRecogResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__CarPlateRecogResponse ** p = (_ns1__CarPlateRecogResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CarPlateRecogResponse, sizeof(_ns1__CarPlateRecogResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CarPlateRecogResponse(struct soap *soap, _ns1__CarPlateRecogResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__CarPlateRecogResponse);
	if (soap_out_PointerTo_ns1__CarPlateRecogResponse(soap, tag?tag:"ns1:CarPlateRecogResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CarPlateRecogResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__CarPlateRecogResponse(struct soap *soap, _ns1__CarPlateRecogResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CarPlateRecogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CarPlateRecog(struct soap *soap, _ns1__CarPlateRecog *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CarPlateRecog))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CarPlateRecog(struct soap *soap, const char *tag, int id, _ns1__CarPlateRecog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CarPlateRecog);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__CarPlateRecog ** SOAP_FMAC4 soap_in_PointerTo_ns1__CarPlateRecog(struct soap *soap, const char *tag, _ns1__CarPlateRecog **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CarPlateRecog **)soap_malloc(soap, sizeof(_ns1__CarPlateRecog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CarPlateRecog *)soap_instantiate__ns1__CarPlateRecog(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__CarPlateRecog ** p = (_ns1__CarPlateRecog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CarPlateRecog, sizeof(_ns1__CarPlateRecog), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CarPlateRecog(struct soap *soap, _ns1__CarPlateRecog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__CarPlateRecog);
	if (soap_out_PointerTo_ns1__CarPlateRecog(soap, tag?tag:"ns1:CarPlateRecog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CarPlateRecog ** SOAP_FMAC4 soap_get_PointerTo_ns1__CarPlateRecog(struct soap *soap, _ns1__CarPlateRecog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CarPlateRecog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetXMlFormatResponse(struct soap *soap, _ns1__GetXMlFormatResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetXMlFormatResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetXMlFormatResponse(struct soap *soap, const char *tag, int id, _ns1__GetXMlFormatResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetXMlFormatResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetXMlFormatResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetXMlFormatResponse(struct soap *soap, const char *tag, _ns1__GetXMlFormatResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetXMlFormatResponse **)soap_malloc(soap, sizeof(_ns1__GetXMlFormatResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetXMlFormatResponse *)soap_instantiate__ns1__GetXMlFormatResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetXMlFormatResponse ** p = (_ns1__GetXMlFormatResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetXMlFormatResponse, sizeof(_ns1__GetXMlFormatResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetXMlFormatResponse(struct soap *soap, _ns1__GetXMlFormatResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetXMlFormatResponse);
	if (soap_out_PointerTo_ns1__GetXMlFormatResponse(soap, tag?tag:"ns1:GetXMlFormatResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetXMlFormatResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetXMlFormatResponse(struct soap *soap, _ns1__GetXMlFormatResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetXMlFormatResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetXMlFormat(struct soap *soap, _ns1__GetXMlFormat *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetXMlFormat))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetXMlFormat(struct soap *soap, const char *tag, int id, _ns1__GetXMlFormat *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetXMlFormat);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetXMlFormat ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetXMlFormat(struct soap *soap, const char *tag, _ns1__GetXMlFormat **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetXMlFormat **)soap_malloc(soap, sizeof(_ns1__GetXMlFormat *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetXMlFormat *)soap_instantiate__ns1__GetXMlFormat(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetXMlFormat ** p = (_ns1__GetXMlFormat **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetXMlFormat, sizeof(_ns1__GetXMlFormat), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetXMlFormat(struct soap *soap, _ns1__GetXMlFormat *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetXMlFormat);
	if (soap_out_PointerTo_ns1__GetXMlFormat(soap, tag?tag:"ns1:GetXMlFormat", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetXMlFormat ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetXMlFormat(struct soap *soap, _ns1__GetXMlFormat **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetXMlFormat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetCurrentVersionResponse(struct soap *soap, _ns1__GetCurrentVersionResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetCurrentVersionResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetCurrentVersionResponse(struct soap *soap, const char *tag, int id, _ns1__GetCurrentVersionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetCurrentVersionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetCurrentVersionResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetCurrentVersionResponse(struct soap *soap, const char *tag, _ns1__GetCurrentVersionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetCurrentVersionResponse **)soap_malloc(soap, sizeof(_ns1__GetCurrentVersionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetCurrentVersionResponse *)soap_instantiate__ns1__GetCurrentVersionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetCurrentVersionResponse ** p = (_ns1__GetCurrentVersionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetCurrentVersionResponse, sizeof(_ns1__GetCurrentVersionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetCurrentVersionResponse(struct soap *soap, _ns1__GetCurrentVersionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetCurrentVersionResponse);
	if (soap_out_PointerTo_ns1__GetCurrentVersionResponse(soap, tag?tag:"ns1:GetCurrentVersionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetCurrentVersionResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetCurrentVersionResponse(struct soap *soap, _ns1__GetCurrentVersionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetCurrentVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetCurrentVersion(struct soap *soap, _ns1__GetCurrentVersion *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetCurrentVersion))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetCurrentVersion(struct soap *soap, const char *tag, int id, _ns1__GetCurrentVersion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetCurrentVersion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__GetCurrentVersion ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetCurrentVersion(struct soap *soap, const char *tag, _ns1__GetCurrentVersion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetCurrentVersion **)soap_malloc(soap, sizeof(_ns1__GetCurrentVersion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetCurrentVersion *)soap_instantiate__ns1__GetCurrentVersion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__GetCurrentVersion ** p = (_ns1__GetCurrentVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetCurrentVersion, sizeof(_ns1__GetCurrentVersion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetCurrentVersion(struct soap *soap, _ns1__GetCurrentVersion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetCurrentVersion);
	if (soap_out_PointerTo_ns1__GetCurrentVersion(soap, tag?tag:"ns1:GetCurrentVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetCurrentVersion ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetCurrentVersion(struct soap *soap, _ns1__GetCurrentVersion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetCurrentVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__WebserviceTestResponse(struct soap *soap, _ns1__WebserviceTestResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__WebserviceTestResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__WebserviceTestResponse(struct soap *soap, const char *tag, int id, _ns1__WebserviceTestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__WebserviceTestResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__WebserviceTestResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__WebserviceTestResponse(struct soap *soap, const char *tag, _ns1__WebserviceTestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__WebserviceTestResponse **)soap_malloc(soap, sizeof(_ns1__WebserviceTestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__WebserviceTestResponse *)soap_instantiate__ns1__WebserviceTestResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__WebserviceTestResponse ** p = (_ns1__WebserviceTestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__WebserviceTestResponse, sizeof(_ns1__WebserviceTestResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__WebserviceTestResponse(struct soap *soap, _ns1__WebserviceTestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__WebserviceTestResponse);
	if (soap_out_PointerTo_ns1__WebserviceTestResponse(soap, tag?tag:"ns1:WebserviceTestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__WebserviceTestResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__WebserviceTestResponse(struct soap *soap, _ns1__WebserviceTestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__WebserviceTestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__WebserviceTest(struct soap *soap, _ns1__WebserviceTest *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__WebserviceTest))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__WebserviceTest(struct soap *soap, const char *tag, int id, _ns1__WebserviceTest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__WebserviceTest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__WebserviceTest ** SOAP_FMAC4 soap_in_PointerTo_ns1__WebserviceTest(struct soap *soap, const char *tag, _ns1__WebserviceTest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__WebserviceTest **)soap_malloc(soap, sizeof(_ns1__WebserviceTest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__WebserviceTest *)soap_instantiate__ns1__WebserviceTest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__WebserviceTest ** p = (_ns1__WebserviceTest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__WebserviceTest, sizeof(_ns1__WebserviceTest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__WebserviceTest(struct soap *soap, _ns1__WebserviceTest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__WebserviceTest);
	if (soap_out_PointerTo_ns1__WebserviceTest(soap, tag?tag:"ns1:WebserviceTest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__WebserviceTest ** SOAP_FMAC4 soap_get_PointerTo_ns1__WebserviceTest(struct soap *soap, _ns1__WebserviceTest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__WebserviceTest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
